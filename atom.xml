<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>笺札</title>
  
  
  <link href="https://id-zy.github.io/atom.xml" rel="self"/>
  
  <link href="https://id-zy.github.io/"/>
  <updated>2025-11-14T11:19:03.182Z</updated>
  <id>https://id-zy.github.io/</id>
  
  <author>
    <name>zhaoyuan</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>比赛中的配对次数</title>
    <link href="https://id-zy.github.io/2025/11/14/%E9%A2%988/"/>
    <id>https://id-zy.github.io/2025/11/14/%E9%A2%988/</id>
    <published>2025-11-14T12:07:23.655Z</published>
    <updated>2025-11-14T11:19:03.182Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="题目描述题目来源于leetcode"><a class="markdownIt-Anchor" href="#题目描述题目来源于leetcode"></a> 题目描述(题目来源于LeetCode)</h2><p>给你一个整数 <code>n</code> ，表示比赛中的队伍数。比赛遵循一种独特的赛制：</p><ul><li>如果当前队伍数是 <strong>偶数</strong> ，那么每支队伍都会与另一支队伍配对。总共进行 <code>n / 2</code> 场比赛，且产生 <code>n / 2</code> 支队伍进入下一轮。</li><li>如果当前队伍数为 <strong>奇数</strong> ，那么将会随机轮空并晋级一支队伍，其余的队伍配对。总共进行 <code>(n - 1) / 2</code> 场比赛，且产生 <code>(n - 1) / 2 + 1</code> 支队伍进入下一轮。<br />返回在比赛中进行的配对次数，直到决出获胜队伍为止。</li></ul><h2 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">numberOfMatches</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line"></span><br><span class="line">        x=<span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> n!=<span class="number">1</span>:</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> n%<span class="number">2</span>==<span class="number">0</span>:</span><br><span class="line"></span><br><span class="line">                x+=n//<span class="number">2</span></span><br><span class="line"></span><br><span class="line">                n=n//<span class="number">2</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line"></span><br><span class="line">                x+=(n-<span class="number">1</span>)//<span class="number">2</span></span><br><span class="line"></span><br><span class="line">                n=(n-<span class="number">1</span>)//<span class="number">2</span>+<span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure><h2 id="代码分析"><a class="markdownIt-Anchor" href="#代码分析"></a> 代码分析</h2><h3 id="算法思路"><a class="markdownIt-Anchor" href="#算法思路"></a> 算法思路</h3><p>代码采用迭代方法模拟比赛过程：</p><ol><li><p>初始化配对次数 <code>x</code> 为 0</p></li><li><p>当队伍数 <code>n</code> 大于 1 时循环：</p><ul><li><p>如果 <code>n</code> 是偶数：配对次数增加 <code>n/2</code>，下一轮队伍数为 <code>n/2</code></p></li><li><p>如果 <code>n</code> 是奇数：配对次数增加 <code>(n-1)/2</code>，下一轮队伍数为 <code>(n-1)/2 + 1</code></p></li></ul></li><li><p>当队伍数减少到 1 时，返回总配对次数</p></li></ol><h3 id="时间复杂度分析"><a class="markdownIt-Anchor" href="#时间复杂度分析"></a> 时间复杂度分析</h3><ul><li><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(log N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span></p><ul><li><p>每次迭代队伍数至少减半</p></li><li><p>最坏情况下需要 O(log N) 次迭代</p></li></ul></li><li><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p><ul><li>只使用了常数级别的额外空间</li></ul></li></ul><h3 id="代码正确性"><a class="markdownIt-Anchor" href="#代码正确性"></a> 代码正确性</h3><p>代码逻辑清晰，正确处理了奇偶两种情况：</p><ul><li><p>偶数情况：<code>x += n//2</code> 和 <code>n = n//2</code></p></li><li><p>奇数情况：<code>x += (n-1)//2</code> 和 <code>n = (n-1)//2 + 1</code></p></li></ul><h2 id="优化建议"><a class="markdownIt-Anchor" href="#优化建议"></a> 优化建议</h2><p>实际上，这个问题有一个数学上的封闭解：配对次数总是等于 <code>n-1</code>，因为每场比赛淘汰一支队伍，最终只剩一支冠军队伍。</p><p>可以直接简化为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">numberOfMatches</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="keyword">return</span> n - <span class="number">1</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="作业练习" scheme="https://id-zy.github.io/categories/%E4%BD%9C%E4%B8%9A%E7%BB%83%E4%B9%A0/"/>
    
    
    <category term="LeetCode" scheme="https://id-zy.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>title: 11.14 日常 | 思考的终结与头像的暗示</title>
    <link href="https://id-zy.github.io/2025/11/14/11.14%E6%97%A5%E5%B8%B8/"/>
    <id>https://id-zy.github.io/2025/11/14/11.14%E6%97%A5%E5%B8%B8/</id>
    <published>2025-11-14T12:07:13.707Z</published>
    <updated>2025-11-14T12:06:05.481Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>今天，我读完了《思考，快与慢》这本书。它系统性地揭示了&quot;快思考&quot;（系统1）与&quot;慢思考&quot;（系统2）如何深刻影响我们的行为、心理与人生抉择。书中不仅剖析了多种常见的认知偏见——如锚定效应、可得性启发、过度自信等，也融入了丰富的经济学原理与统计学视角，让我意识到直觉在带来效率的同时，也可能成为误导的源头。</p><p>作者提醒我们，在生活中做重要决策时，既要<strong>警惕直觉可能带来的偏见</strong>，也要<strong>积极寻求外部意见作为参照</strong>，并尝试运用&quot;四重模型&quot;来系统分析得失。这不仅是一种思维方法，更是一种生活态度的转变——从被动反应到主动觉察。</p><p>今天的英语短文探讨了一个有趣的现象：在网络交流中，<strong>你的头像会不自觉地和你的文字内容绑定在一起</strong>，影响他人对你的感知。同一段话，配上不同的头像，可能传递出完全不同的情绪与可信度。文章还指出，频繁更换头像往往反映了生活中的变动——无论是出于自我调节的需要，还是内心波动的外显。<br /><img src="https://pic1.imgdb.cn/item/69171b533203f7be0003e424.jpg" alt="" /></p><p>晚上，我系统整理了微机原理第二章的笔记，重点梳理了8086/8088 CPU的基本结构与引脚特性，并总结了&quot;器件学习方法论&quot;：</p><ol><li><strong>功能了解</strong> → 2. <strong>引脚特性分析</strong> → 3. <strong>内部结构理解</strong> → 4. <strong>硬件电路设计</strong> → 5. <strong>软件编程实现</strong></li></ol><p>此外，我也完成了一道LeetCode题目——“比赛中的配对次数”。最初我使用循环模拟比赛过程，后来发现这个问题存在一个优美的数学本质：<strong>每场比赛淘汰一支队伍，因此总配对次数始终为 n-1</strong>。这让我再次体会到，跳出程序思维，从数学视角审视问题，往往能发现更简洁的本质解。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">numberOfMatches</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="keyword">return</span> n - <span class="number">1</span></span><br></pre></td></tr></table></figure><hr /><h3 id="每日三思"><a class="markdownIt-Anchor" href="#每日三思"></a> 💭 每日三思</h3><p><strong>技术思辨</strong></p><blockquote><p>当调试代码时遇到棘手bug，是相信&quot;系统1&quot;的直觉定位，还是启动&quot;系统2&quot;的系统性排查？——《思考，快与慢》提醒我们：<strong>直觉是经验的礼物，但系统性思考才是工程的基石</strong></p></blockquote><p><strong>网络心理学</strong></p><blockquote><p>我的微信头像传递了什么潜在信号？是无意识的自我表达，还是有意识的形象管理？这小小的图片背后，藏着我对&quot;被如何看待&quot;的何种期待？</p></blockquote><p><strong>学习方法</strong></p><blockquote><p>整理微机原理笔记时，是在机械重复书本内容，还是在构建属于自己的知识体系？<strong>真正的理解，发生在将他人知识重构为自己语言的那一刻</strong></p></blockquote><hr /><p><strong>一点感悟：</strong><br />读完《思考，快与慢》，我意识到在学习编程和硬件时，那些一闪而过的&quot;直觉解&quot;有时是经验带来的礼物，有时却是思维陷阱。而整理笔记、总结方法，正是调用&quot;慢思考&quot;对抗认知偏见的实践。我们不仅是在学技术，也是在训练自己如何清醒地思考。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="日常闲谈" scheme="https://id-zy.github.io/categories/%E6%97%A5%E5%B8%B8%E9%97%B2%E8%B0%88/"/>
    
    
    <category term="《思考，快与慢》" scheme="https://id-zy.github.io/tags/%E3%80%8A%E6%80%9D%E8%80%83%EF%BC%8C%E5%BF%AB%E4%B8%8E%E6%85%A2%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>8086/8088 CPU</title>
    <link href="https://id-zy.github.io/2025/11/14/16(32)%E4%BD%8D%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8/"/>
    <id>https://id-zy.github.io/2025/11/14/16(32)%E4%BD%8D%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8/</id>
    <published>2025-11-14T12:07:03.851Z</published>
    <updated>2025-11-14T12:00:05.196Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>运用上一部分学到的器件使用的学习方法研究8086 CPU</p><h3 id="8086功能了解"><a class="markdownIt-Anchor" href="#8086功能了解"></a> 8086功能了解</h3><ol><li><p>1978年，8086第一代16位微处理器。</p></li><li><p>第一次将流水线思想引进微处理器：指令级流水。</p></li><li><p>存储器分段管理机制引入处理器，扩大寻址能力。</p></li><li><p>只有整数运算指令。可配套数值协处理器8087、</p></li><li><p>输入/输出协处理器8089，具备较强大计算能力和I/O处理能力。</p></li><li><p>1979年推出8088，8位外部数据总线，兼容丰富的8位配套器件， 8088内部结构与8086基本相同。</p></li><li><p>基于8088微处理器的IBM PC-XT以及兼容系统。</p></li></ol><h3 id="8086引脚特性分析"><a class="markdownIt-Anchor" href="#8086引脚特性分析"></a> 8086引脚特性分析</h3><h4 id="8086引脚基本功能"><a class="markdownIt-Anchor" href="#8086引脚基本功能"></a> 8086引脚基本功能</h4><h5 id="1电源引脚"><a class="markdownIt-Anchor" href="#1电源引脚"></a> 1.电源引脚</h5><p>GND、VCC，工作电压为5V</p><h5 id="2时钟-复位"><a class="markdownIt-Anchor" href="#2时钟-复位"></a> 2.时钟、复位</h5><p>CLK =5MHZ<br />复位信号（高电平有效)</p><h5 id="3最小模式最大模式"><a class="markdownIt-Anchor" href="#3最小模式最大模式"></a> 3.最小模式/最大模式</h5><h5 id="4地址-数据线"><a class="markdownIt-Anchor" href="#4地址-数据线"></a> 4.地址、数据线</h5><h5 id="5高字节数据选择"><a class="markdownIt-Anchor" href="#5高字节数据选择"></a> 5.高字节数据选择</h5>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="微原" scheme="https://id-zy.github.io/categories/%E5%BE%AE%E5%8E%9F/"/>
    
    
    <category term="微机原理" scheme="https://id-zy.github.io/tags/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>学习器件使用的方法</title>
    <link href="https://id-zy.github.io/2025/11/14/%E5%99%A8%E4%BB%B6%E4%BD%BF%E7%94%A8/"/>
    <id>https://id-zy.github.io/2025/11/14/%E5%99%A8%E4%BB%B6%E4%BD%BF%E7%94%A8/</id>
    <published>2025-11-14T12:07:03.849Z</published>
    <updated>2025-11-14T11:46:29.404Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="学习器件使用的方法"><a class="markdownIt-Anchor" href="#学习器件使用的方法"></a> 学习器件使用的方法</h2><h3 id="器件功能了解"><a class="markdownIt-Anchor" href="#器件功能了解"></a> 器件功能了解</h3><h3 id="器件引脚特性分析"><a class="markdownIt-Anchor" href="#器件引脚特性分析"></a> 器件引脚特性分析</h3><h4 id="引脚的功能"><a class="markdownIt-Anchor" href="#引脚的功能"></a> 引脚的功能</h4><p>引脚信号的定义、作用；<br />通常采用英文单词或其缩写表示</p><h4 id="信号的方向"><a class="markdownIt-Anchor" href="#信号的方向"></a> 信号的方向</h4><p>信号从芯片向外输出，还是从外部输入芯片或者是双向的</p><h4 id="有效电平"><a class="markdownIt-Anchor" href="#有效电平"></a> 有效电平</h4><p>起作用的逻辑电平<br />高电平<br />低电平<br />上升沿<br />下降沿</p><h4 id="三态能力"><a class="markdownIt-Anchor" href="#三态能力"></a> 三态能力</h4><p>除却正常的高低电平，还可以输出高阻的第三态</p><h3 id="内部结构工作原理分析"><a class="markdownIt-Anchor" href="#内部结构工作原理分析"></a> 内部结构/工作原理分析</h3><p>当我们了解引脚特性后，我们需要对器件的内部结构或者工作原理进行分析，比如CPU如何实现了存储器的读写操作，读写的时序是什么</p><h3 id="硬件电路设计"><a class="markdownIt-Anchor" href="#硬件电路设计"></a> 硬件电路设计</h3><p>将这个器件与外围器件进行具体硬件电路的连接，跟前面的引脚特性就密切相关了。<br />哪个是数据总线，哪个是地址总线，哪些是读写控制线，如何进行连接，都需要分析清楚。</p><h3 id="软件编程设计"><a class="markdownIt-Anchor" href="#软件编程设计"></a> 软件编程设计</h3><pre><code>(a)根据电路原理图中器件引脚连接关系(b)器件控制时序(c)题目的功能要求</code></pre><h2 id="习题"><a class="markdownIt-Anchor" href="#习题"></a> 习题</h2><h3 id="1器件引脚的有效电平"><a class="markdownIt-Anchor" href="#1器件引脚的有效电平"></a> 1.器件引脚的有效电平</h3><p>解答：高电平、低电平、上升沿、下降沿</p><h3 id="2在器件引脚分析中需要关注引脚的哪些方面"><a class="markdownIt-Anchor" href="#2在器件引脚分析中需要关注引脚的哪些方面"></a> 2.在器件引脚分析中，需要关注引脚的哪些方面</h3><p>解答：引脚的功能、信号的方向、有效电平、三态能力</p><h3 id="3软件编程设计需要根据哪些方面进行编程设计"><a class="markdownIt-Anchor" href="#3软件编程设计需要根据哪些方面进行编程设计"></a> 3.软件编程设计需要根据哪些方面进行编程设计</h3><p>解答：更具电路原理图器件引脚连接关系、器件控制时序、题目的功能要求</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="微原" scheme="https://id-zy.github.io/categories/%E5%BE%AE%E5%8E%9F/"/>
    
    
    <category term="微机原理" scheme="https://id-zy.github.io/tags/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>统计能整除数字的位数</title>
    <link href="https://id-zy.github.io/2025/11/13/%E9%A2%987/"/>
    <id>https://id-zy.github.io/2025/11/13/%E9%A2%987/</id>
    <published>2025-11-13T14:09:37.564Z</published>
    <updated>2025-11-13T14:34:33.759Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="问题描述来源于leetcode"><a class="markdownIt-Anchor" href="#问题描述来源于leetcode"></a> 问题描述(来源于LeetCode)</h2><p>给定一个整数 <code>num</code>，返回 <code>num</code> 中能整除 <code>num</code> 的数位的数目。</p><p>如果满足 <code>num % val == 0</code>，则认为整数 <code>val</code> 可以整除 <code>num</code>。</p><h2 id="解题思路分析"><a class="markdownIt-Anchor" href="#解题思路分析"></a> 解题思路分析</h2><h3 id="问题本质"><a class="markdownIt-Anchor" href="#问题本质"></a> 问题本质</h3><p>遍历整数的每一位数字，检查该数字是否能整除原数。</p><h3 id="核心挑战"><a class="markdownIt-Anchor" href="#核心挑战"></a> 核心挑战</h3><ol><li>如何提取整数的每一位数字</li><li>如何处理数字0（不能作为除数）</li><li>如何高效遍历所有数位</li></ol><h2 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">countDigits</span>(<span class="params">self, num: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        x=<span class="number">0</span></span><br><span class="line">        nums=num</span><br><span class="line">        <span class="keyword">while</span> num:</span><br><span class="line">            val = num %<span class="number">10</span></span><br><span class="line">            <span class="keyword">if</span> nums % val ==<span class="number">0</span> <span class="keyword">and</span> val!=<span class="number">0</span>:</span><br><span class="line">                x+=<span class="number">1</span></span><br><span class="line">            num=num//<span class="number">10</span></span><br><span class="line">        <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure><h2 id="算法详解"><a class="markdownIt-Anchor" href="#算法详解"></a> 算法详解</h2><h3 id="步骤分解"><a class="markdownIt-Anchor" href="#步骤分解"></a> 步骤分解</h3><ol><li><strong>初始化计数器</strong>：<code>x=0</code> 用于统计满足条件的位数</li><li><strong>保存原数字</strong>：<code>nums=num</code> 保存原始数字用于后续除法检查</li><li><strong>循环遍历每一位</strong>：<ul><li>使用 <code>num % 10</code> 获取最后一位数字</li><li>检查该数字是否能整除原数字 <code>nums % val == 0</code> 且数字不为0 <code>val != 0</code></li><li>如果满足条件，计数器 <code>x</code> 加1</li><li>使用 <code>num = num // 10</code> 移除最后一位</li></ul></li><li><strong>返回结果</strong>：返回计数器 <code>x</code> 的值</li></ol><h3 id="关键技术点"><a class="markdownIt-Anchor" href="#关键技术点"></a> 关键技术点</h3><ul><li><strong>数字分解</strong>：通过取模和整除操作提取数位</li><li><strong>循环控制</strong>：当 <code>num</code> 变为0时循环结束</li><li><strong>原数字保存</strong>：保存原始数字用于除法检查</li><li><strong>除零防护</strong>：添加 <code>val != 0</code> 检查避免除零错误</li></ul><h2 id="复杂度分析"><a class="markdownIt-Anchor" href="#复杂度分析"></a> 复杂度分析</h2><ul><li><strong>时间复杂度</strong>：O(log n)<ul><li>循环次数等于数字的位数，对于整数n，位数为 ⌊log₁₀n⌋ + 1</li></ul></li><li><strong>空间复杂度</strong>：O(1)<ul><li>只使用了固定数量的变量，不随输入规模变化</li></ul></li></ul><h2 id="示例分析"><a class="markdownIt-Anchor" href="#示例分析"></a> 示例分析</h2><h3 id="示例1num-1248"><a class="markdownIt-Anchor" href="#示例1num-1248"></a> 示例1：num = 1248</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">原始数字：1248</span><br><span class="line">循环过程：</span><br><span class="line">- 第一次：val=8, 1248%8=0 → x=1</span><br><span class="line">- 第二次：val=4, 1248%4=0 → x=2  </span><br><span class="line">- 第三次：val=2, 1248%2=0 → x=3</span><br><span class="line">- 第四次：val=1, 1248%1=0 → x=4</span><br><span class="line">结果：4</span><br></pre></td></tr></table></figure><h3 id="示例2num-121"><a class="markdownIt-Anchor" href="#示例2num-121"></a> 示例2：num = 121</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">原始数字：121</span><br><span class="line">循环过程：</span><br><span class="line">- 第一次：val=1, 121%1=0 → x=1</span><br><span class="line">- 第二次：val=2, 121%2=1 ≠0 → x=1</span><br><span class="line">- 第三次：val=1, 121%1=0 → x=2</span><br><span class="line">结果：2</span><br></pre></td></tr></table></figure><h3 id="示例3num-101"><a class="markdownIt-Anchor" href="#示例3num-101"></a> 示例3：num = 101</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">原始数字：101</span><br><span class="line">循环过程：</span><br><span class="line">- 第一次：val=1, 101%1=0 → x=1</span><br><span class="line">- 第二次：val=0, 跳过（因为val=0）→ x=1</span><br><span class="line">- 第三次：val=1, 101%1=0 → x=2</span><br><span class="line">结果：2</span><br></pre></td></tr></table></figure><h2 id="测试用例"><a class="markdownIt-Anchor" href="#测试用例"></a> 测试用例</h2><table><thead><tr><th>测试用例</th><th>输入num</th><th>位数</th><th>满足条件的位数</th><th>输出</th></tr></thead><tbody><tr><td>1</td><td>7</td><td>[7]</td><td>[7]</td><td>1</td></tr><tr><td>2</td><td>121</td><td>[1,2,1]</td><td>[1,1]</td><td>2</td></tr><tr><td>3</td><td>1248</td><td>[1,2,4,8]</td><td>[1,2,4,8]</td><td>4</td></tr><tr><td>4</td><td>37</td><td>[3,7]</td><td>[]</td><td>0</td></tr><tr><td>5</td><td>101</td><td>[1,0,1]</td><td>[1,1]</td><td>2</td></tr></tbody></table><h2 id="边界情况考虑"><a class="markdownIt-Anchor" href="#边界情况考虑"></a> 边界情况考虑</h2><h3 id="已处理的边界情况"><a class="markdownIt-Anchor" href="#已处理的边界情况"></a> 已处理的边界情况</h3><ol><li><strong>包含零的情况</strong>：通过 <code>val != 0</code> 检查避免除零错误</li><li><strong>个位数情况</strong>：正确处理只有一位数字的情况</li><li><strong>重复数字</strong>：正确处理包含重复数字的情况</li><li><strong>质数情况</strong>：所有位数都不能整除的情况</li></ol><h3 id="其他边界情况"><a class="markdownIt-Anchor" href="#其他边界情况"></a> 其他边界情况</h3><ul><li><strong>负整数</strong>：题目保证输入是非负整数</li><li><strong>零本身</strong>：输入为0时，循环不会执行，返回0</li></ul><h2 id="算法正确性分析"><a class="markdownIt-Anchor" href="#算法正确性分析"></a> 算法正确性分析</h2><h3 id="算法优势"><a class="markdownIt-Anchor" href="#算法优势"></a> 算法优势</h3><ol><li><strong>正确性</strong>：对于所有非负整数输入，算法能正确统计能整除原数的位数</li><li><strong>健壮性</strong>：通过 <code>val != 0</code> 检查避免了除零错误</li><li><strong>高效性</strong>：时间复杂度与数字位数成正比，是最优解</li></ol><h3 id="算法局限性"><a class="markdownIt-Anchor" href="#算法局限性"></a> 算法局限性</h3><ul><li>仅适用于非负整数（符合题目要求）</li><li>对于非常大的数字，仍能高效处理</li></ul><h2 id="扩展思考"><a class="markdownIt-Anchor" href="#扩展思考"></a> 扩展思考</h2><h3 id="相关数学概念"><a class="markdownIt-Anchor" href="#相关数学概念"></a> 相关数学概念</h3><ol><li><strong>整除性质</strong>：理解整除的基本定义和性质</li><li><strong>数位分解</strong>：掌握数字的位值表示法</li><li><strong>模运算</strong>：熟练运用模运算解决问题</li></ol><h3 id="实际应用场景"><a class="markdownIt-Anchor" href="#实际应用场景"></a> 实际应用场景</h3><ul><li>数字属性分析工具</li><li>数学游戏中的特殊数字判定</li><li>密码学中的数字特征检查</li><li>数字筛选和分类系统</li></ul><h3 id="算法变体"><a class="markdownIt-Anchor" href="#算法变体"></a> 算法变体</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用字符串转换的方法</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">countDigits</span>(<span class="params">self, num: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> digit_char <span class="keyword">in</span> <span class="built_in">str</span>(num):</span><br><span class="line">        digit = <span class="built_in">int</span>(digit_char)</span><br><span class="line">        <span class="keyword">if</span> digit != <span class="number">0</span> <span class="keyword">and</span> num % digit == <span class="number">0</span>:</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure><h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2><p>这个算法展示了完整的数字处理解决方案：</p><ol><li><strong>问题分析能力</strong>：准确理解问题要求和约束条件</li><li><strong>数字分解技术</strong>：熟练使用模运算和整除运算提取数位</li><li><strong>循环控制技巧</strong>：通过循环高效遍历数字的所有位数</li><li><strong>边界情况处理</strong>：正确处理除零错误等边界情况</li><li><strong>条件判断逻辑</strong>：精确检查数位是否能整除原数</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="作业练习" scheme="https://id-zy.github.io/categories/%E4%BD%9C%E4%B8%9A%E7%BB%83%E4%B9%A0/"/>
    
    
    <category term="LeetCode" scheme="https://id-zy.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>拆分数位后四位数字的最小和</title>
    <link href="https://id-zy.github.io/2025/11/13/%E9%A2%986/"/>
    <id>https://id-zy.github.io/2025/11/13/%E9%A2%986/</id>
    <published>2025-11-13T14:09:37.562Z</published>
    <updated>2025-11-13T14:34:25.722Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="问题描述来源于leetcode"><a class="markdownIt-Anchor" href="#问题描述来源于leetcode"></a> 问题描述(来源于LeetCode)</h2><p>给定一个四位正整数 <code>num</code>，使用所有数位拆成两个新的整数 <code>new1</code> 和 <code>new2</code>（可以有前导0），返回可以得到的最小和。</p><h2 id="解题思路分析"><a class="markdownIt-Anchor" href="#解题思路分析"></a> 解题思路分析</h2><h3 id="问题本质"><a class="markdownIt-Anchor" href="#问题本质"></a> 问题本质</h3><p>这是一个组合优化问题，需要找到将四个数字分成两组的最佳方式，使得两个两位数的和最小。</p><h3 id="核心洞察"><a class="markdownIt-Anchor" href="#核心洞察"></a> 核心洞察</h3><p>要使两个两位数的和最小：</p><ol><li><p>将最小的两个数字放在十位</p></li><li><p>将较大的两个数字放在个位</p></li><li><p>这样能确保两个数都尽可能小</p></li></ol><h3 id="数学证明"><a class="markdownIt-Anchor" href="#数学证明"></a> 数学证明</h3><p>对于四个排序后的数字 a ≤ b ≤ c ≤ d：</p><ul><li><p>最优分配：10a + d 和 10b + c</p></li><li><p>总和：10(a + b) + (c + d)</p></li></ul><h2 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minimumSum</span>(<span class="params">self, num: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        分解四位数字</span><br><span class="line">        a = num % <span class="number">10</span>           <span class="comment"># 个位</span></span><br><span class="line">        b = (num // <span class="number">10</span>) % <span class="number">10</span>   <span class="comment"># 十位  </span></span><br><span class="line">        c = (num // <span class="number">100</span>) % <span class="number">10</span>  <span class="comment"># 百位</span></span><br><span class="line">        d = num // <span class="number">1000</span>        <span class="comment"># 千位</span></span><br><span class="line">            <span class="comment"># 排序四个数字</span></span><br><span class="line">    digits = [a, b, c, d]</span><br><span class="line">       digits.sort()</span><br><span class="line">    </span><br><span class="line">        <span class="comment"># 构造最优组合</span></span><br><span class="line">        num1 = digits[<span class="number">0</span>] * <span class="number">10</span> + digits[<span class="number">3</span>]  <span class="comment"># 最小和最大组合</span></span><br><span class="line">        num2 = digits[<span class="number">1</span>] * <span class="number">10</span> + digits[<span class="number">2</span>]  <span class="comment"># 中间两个组合</span></span><br><span class="line">    </span><br><span class="line">        <span class="keyword">return</span> num1 + num2</span><br></pre></td></tr></table></figure><h2 id="算法详解"><a class="markdownIt-Anchor" href="#算法详解"></a> 算法详解</h2><h3 id="步骤分解"><a class="markdownIt-Anchor" href="#步骤分解"></a> 步骤分解</h3><ol><li><p><strong>数字分解</strong>：提取四位数的每一位</p></li><li><p><strong>数字排序</strong>：将四个数字按升序排列</p></li><li><p><strong>最优组合</strong>：</p><ul><li><p>第一个数：最小的数字在十位，最大的数字在个位</p></li><li><p>第二个数：第二小的数字在十位，第三小的数字在个位</p></li></ul></li><li><p><strong>计算和</strong>：返回两个数的和</p></li></ol><h3 id="为什么这样最优"><a class="markdownIt-Anchor" href="#为什么这样最优"></a> 为什么这样最优？</h3><p>假设排序后数字为 a ≤ b ≤ c ≤ d：</p><ul><li><p>十位应该放最小的数字 a 和 b</p></li><li><p>个位应该放较大的数字 c 和 d</p></li><li><p>组合方式：10a + d 和 10b + c 的和最小</p></li></ul><h2 id="复杂度分析"><a class="markdownIt-Anchor" href="#复杂度分析"></a> 复杂度分析</h2><ul><li><p><strong>时间复杂度</strong>：O(1)</p><ul><li>固定处理4个数字，排序也是常数时间</li></ul></li><li><p><strong>空间复杂度</strong>：O(1)</p><ul><li>使用固定大小的数组存储数字</li></ul></li></ul><h2 id="示例分析"><a class="markdownIt-Anchor" href="#示例分析"></a> 示例分析</h2><h3 id="示例1num-2932"><a class="markdownIt-Anchor" href="#示例1num-2932"></a> 示例1：num = 2932</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">分解数字：2, 9, 3, 2</span><br><span class="line">排序后：2, 2, 3, 9</span><br><span class="line">构造数字：</span><br><span class="line"></span><br><span class="line">- num1 = 2×10 + 9 = 29</span><br><span class="line">- num2 = 2×10 + 3 = 23</span><br><span class="line">  和：29 + 23 = 52</span><br></pre></td></tr></table></figure><h3 id="示例2num-4009"><a class="markdownIt-Anchor" href="#示例2num-4009"></a> 示例2：num = 4009</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">分解数字：4, 0, 0, 9  </span><br><span class="line">排序后：0, 0, 4, 9</span><br><span class="line">构造数字：</span><br><span class="line"></span><br><span class="line">- num1 = 0×10 + 9 = 9</span><br><span class="line">- num2 = 0×10 + 4 = 4</span><br><span class="line">  和：9 + 4 = 13</span><br></pre></td></tr></table></figure><h2 id="测试用例"><a class="markdownIt-Anchor" href="#测试用例"></a> 测试用例</h2><table><thead><tr><th>测试用例</th><th>输入num</th><th>分解数字</th><th>排序后</th><th>构造数字</th><th>输出和</th></tr></thead><tbody><tr><td>1</td><td>2932</td><td>[2,9,3,2]</td><td>[2,2,3,9]</td><td>29+23</td><td>52</td></tr><tr><td>2</td><td>4009</td><td>[4,0,0,9]</td><td>[0,0,4,9]</td><td>9+4</td><td>13</td></tr><tr><td>3</td><td>1234</td><td>[1,2,3,4]</td><td>[1,2,3,4]</td><td>14+23</td><td>37</td></tr><tr><td>4</td><td>1000</td><td>[1,0,0,0]</td><td>[0,0,0,1]</td><td>1+0</td><td>1</td></tr></tbody></table><h2 id="边界情况考虑"><a class="markdownIt-Anchor" href="#边界情况考虑"></a> 边界情况考虑</h2><ol><li><p><strong>包含零的情况</strong>：正确处理前导零</p></li><li><p><strong>重复数字</strong>：多个相同数字的处理</p></li><li><p><strong>极值情况</strong>：1000, 9999等边界值</p></li></ol><h2 id="算法正确性证明"><a class="markdownIt-Anchor" href="#算法正确性证明"></a> 算法正确性证明</h2><h3 id="贪心选择性质"><a class="markdownIt-Anchor" href="#贪心选择性质"></a> 贪心选择性质</h3><p>每次选择当前最小的可用数字放在十位，这种局部最优选择能导致全局最优解。</p><h3 id="最优子结构"><a class="markdownIt-Anchor" href="#最优子结构"></a> 最优子结构</h3><p>问题的解包含子问题的最优解，四个数字的最优分配包含三个数字的最优分配思想。</p><h2 id="扩展思考"><a class="markdownIt-Anchor" href="#扩展思考"></a> 扩展思考</h2><h3 id="相关问题"><a class="markdownIt-Anchor" href="#相关问题"></a> 相关问题</h3><ol><li><p><strong>三位数拆分</strong>：如何拆分三位数为两个数的和最小</p></li><li><p><strong>五位数拆分</strong>：扩展到更多位数的情况</p></li><li><p><strong>乘积最小</strong>：求两个数的乘积最小而不是和最小</p></li></ol><h3 id="实际应用"><a class="markdownIt-Anchor" href="#实际应用"></a> 实际应用</h3><ul><li><p>资源分配优化</p></li><li><p>负载均衡问题</p></li><li><p>数据分片策略</p></li></ul><h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2><p>这道题目展示了贪心算法在组合优化问题中的应用：</p><ol><li><p><strong>问题分析</strong>：理解问题的组合特性</p></li><li><p><strong>规律发现</strong>：找到数字分配的最优模式</p></li><li><p><strong>算法设计</strong>：设计简单有效的贪心策略</p></li><li><p><strong>正确性验证</strong>：确保贪心选择的合理性</p></li></ol><p>解题的关键在于发现&quot;小数字放在高位&quot;这一核心洞察，体现了<strong>通过观察发现规律</strong>的重要解题技巧。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="作业练习" scheme="https://id-zy.github.io/categories/%E4%BD%9C%E4%B8%9A%E7%BB%83%E4%B9%A0/"/>
    
    
    <category term="LeetCode" scheme="https://id-zy.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>最小偶倍数</title>
    <link href="https://id-zy.github.io/2025/11/13/%E9%A2%985/"/>
    <id>https://id-zy.github.io/2025/11/13/%E9%A2%985/</id>
    <published>2025-11-13T14:09:37.561Z</published>
    <updated>2025-11-13T14:34:22.197Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="问题描述来源于leetcode"><a class="markdownIt-Anchor" href="#问题描述来源于leetcode"></a> 问题描述(来源于LeetCode)</h2><p>给定一个正整数 <code>n</code>，返回 2 和 <code>n</code> 的最小公倍数（正整数）。</p><h2 id="解题思路分析"><a class="markdownIt-Anchor" href="#解题思路分析"></a> 解题思路分析</h2><h3 id="问题本质"><a class="markdownIt-Anchor" href="#问题本质"></a> 问题本质</h3><p>求两个数的最小公倍数(LCM)问题，但其中一个数是固定的2。</p><h3 id="数学原理"><a class="markdownIt-Anchor" href="#数学原理"></a> 数学原理</h3><ul><li><p>两个数的最小公倍数 = (a × b) ÷ 最大公约数(GCD)</p></li><li><p>对于数字2和任意整数n：</p><ul><li><p>如果n是偶数，2和n的最大公约数是2，最小公倍数是n</p></li><li><p>如果n是奇数，2和n的最大公约数是1，最小公倍数是2 × n</p></li></ul></li></ul><h2 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h2><h3 id="方法一条件判断法"><a class="markdownIt-Anchor" href="#方法一条件判断法"></a> 方法一：条件判断法</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">smallestEvenMultiple</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> n % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> n</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span> * n</span><br></pre></td></tr></table></figure><h2 id="算法详解"><a class="markdownIt-Anchor" href="#算法详解"></a> 算法详解</h2><p>通过判断n的奇偶性来决定结果：</p><ul><li><p><strong>偶数情况</strong>：n能被2整除，2和n的最小公倍数就是n本身</p></li><li><p><strong>奇数情况</strong>：n不能被2整除，2和n的最小公倍数是2 × n</p></li></ul><h2 id="复杂度分析"><a class="markdownIt-Anchor" href="#复杂度分析"></a> 复杂度分析</h2><ul><li><p><strong>时间复杂度</strong>： O(1) - 一次模运算和条件判断</p></li><li><p><strong>空间复杂度</strong>：O(1) - 常数空间</p></li></ul><h2 id="数学证明"><a class="markdownIt-Anchor" href="#数学证明"></a> 数学证明</h2><h3 id="定理证明"><a class="markdownIt-Anchor" href="#定理证明"></a> 定理证明</h3><p>对于任意正整数n：</p><ol><li><p>当n为偶数时，n = 2k (k∈N⁺)</p><ul><li><p>GCD(2, n) = 2</p></li><li><p>LCM(2, n) = (2 × n) ÷ 2 = n</p></li></ul></li><li><p>当n为奇数时，n = 2k + 1 (k∈N)</p><ul><li><p>GCD(2, n) = 1</p></li><li><p>LCM(2, n) = (2 × n) ÷ 1 = 2n</p></li></ul></li></ol><h2 id="测试用例"><a class="markdownIt-Anchor" href="#测试用例"></a> 测试用例</h2><table><thead><tr><th>测试用例</th><th>输入n</th><th>预期输出</th><th>说明</th></tr></thead><tbody><tr><td>1</td><td>5</td><td>10</td><td>奇数情况</td></tr><tr><td>2</td><td>6</td><td>6</td><td>偶数情况</td></tr><tr><td>3</td><td>1</td><td>2</td><td>最小奇数</td></tr><tr><td>4</td><td>2</td><td>2</td><td>最小偶数</td></tr><tr><td>5</td><td>100</td><td>100</td><td>较大偶数</td></tr></tbody></table><h2 id="边界情况考虑"><a class="markdownIt-Anchor" href="#边界情况考虑"></a> 边界情况考虑</h2><ol><li><p><strong>n = 1</strong>（最小奇数）</p><ul><li>输出：2</li></ul></li><li><p><strong>n = 2</strong>（最小偶数）</p><ul><li>输出：2</li></ul></li><li><p><strong>大数情况</strong></p><ul><li><p>n = 10⁹（奇数）：输出2 × 10⁹</p></li><li><p>n = 10⁹（偶数）：输出10⁹</p></li></ul></li></ol><h2 id="扩展应用"><a class="markdownIt-Anchor" href="#扩展应用"></a> 扩展应用</h2><h3 id="相关概念"><a class="markdownIt-Anchor" href="#相关概念"></a> 相关概念</h3><ol><li><p><strong>最大公约数(GCD)</strong></p></li><li><p><strong>最小公倍数(LCM)</strong></p></li><li><p><strong>质数与合数</strong></p></li></ol><h3 id="实际应用场景"><a class="markdownIt-Anchor" href="#实际应用场景"></a> 实际应用场景</h3><ul><li><p>周期性任务调度</p></li><li><p>信号处理的采样频率</p></li><li><p>工程中的齿轮传动比计算</p></li></ul><h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2><p>这道题目虽然简单，但涉及了数论中的基本概念：</p><ol><li><p><strong>奇偶性判断</strong>：使用模运算</p></li><li><p><strong>最小公倍数</strong>：理解LCM的计算原理</p></li><li><p><strong>条件逻辑</strong>：根据不同情况采用不同策略</p></li></ol><p>解题的关键在于发现数字2的特殊性，从而简化计算。这种方法体现了<strong>利用问题特性优化解</strong>的重要思想。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="作业练习" scheme="https://id-zy.github.io/categories/%E4%BD%9C%E4%B8%9A%E7%BB%83%E4%B9%A0/"/>
    
    
    <category term="LeetCode" scheme="https://id-zy.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>两整数相加</title>
    <link href="https://id-zy.github.io/2025/11/13/%E9%A2%984/"/>
    <id>https://id-zy.github.io/2025/11/13/%E9%A2%984/</id>
    <published>2025-11-13T14:09:37.559Z</published>
    <updated>2025-11-13T14:34:18.103Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="问题描述来源于leetcode"><a class="markdownIt-Anchor" href="#问题描述来源于leetcode"></a> 问题描述(来源于LeetCode)</h2><p>给定两个整数 <code>num1</code> 和 <code>num2</code>，返回这两个整数的和。</p><h2 id="解题思路分析"><a class="markdownIt-Anchor" href="#解题思路分析"></a> 解题思路分析</h2><h3 id="问题本质"><a class="markdownIt-Anchor" href="#问题本质"></a> 问题本质</h3><p>这是一个基础的算术运算问题，考察对编程语言基本运算符的掌握程度。</p><h3 id="核心思路"><a class="markdownIt-Anchor" href="#核心思路"></a> 核心思路</h3><p>直接使用加法运算符 <code>+</code> 计算两个整数的和。</p><h2 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sum</span>(<span class="params">self, num1: <span class="built_in">int</span>, num2: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">return</span> num1 + num2</span><br></pre></td></tr></table></figure><h2 id="算法详解"><a class="markdownIt-Anchor" href="#算法详解"></a> 算法详解</h2><h3 id="实现步骤"><a class="markdownIt-Anchor" href="#实现步骤"></a> 实现步骤</h3><ol><li><p><strong>接收参数</strong>：获取两个整数 <code>num1</code> 和 <code>num2</code></p></li><li><p><strong>计算和</strong>：使用加法运算符直接计算</p></li><li><p><strong>返回结果</strong>：返回计算结果</p></li></ol><h3 id="关键点"><a class="markdownIt-Anchor" href="#关键点"></a> 关键点</h3><ul><li><p>直接使用语言内置的加法运算符</p></li><li><p>不需要任何额外的数据处理或转换</p></li></ul><h2 id="复杂度分析"><a class="markdownIt-Anchor" href="#复杂度分析"></a> 复杂度分析</h2><ul><li><p><strong>时间复杂度</strong>：O(1)</p><ul><li>只进行一次加法运算</li></ul></li><li><p><strong>空间复杂度</strong>：O(1)</p><ul><li>不使用额外的存储空间</li></ul></li></ul><h2 id="边界情况考虑"><a class="markdownIt-Anchor" href="#边界情况考虑"></a> 边界情况考虑</h2><h3 id="正常情况"><a class="markdownIt-Anchor" href="#正常情况"></a> 正常情况</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：num1 = 12, num2 = 5</span><br><span class="line">输出：17</span><br></pre></td></tr></table></figure><h3 id="特殊情况"><a class="markdownIt-Anchor" href="#特殊情况"></a> 特殊情况</h3><ol><li><p><strong>包含零的情况</strong></p> <figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：num1 = 0, num2 = 5</span><br><span class="line">输出：5</span><br></pre></td></tr></table></figure></li><li><p><strong>负数情况</strong></p> <figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：num1 = -3, num2 = 7</span><br><span class="line">输出：4</span><br></pre></td></tr></table></figure></li><li><p><strong>两个负数</strong></p> <figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：num1 = -5, num2 = -3</span><br><span class="line">输出：-8</span><br></pre></td></tr></table></figure></li></ol><h2 id="测试用例"><a class="markdownIt-Anchor" href="#测试用例"></a> 测试用例</h2><table><thead><tr><th>测试用例</th><th>输入</th><th>预期输出</th><th>说明</th></tr></thead><tbody><tr><td>1</td><td>num1=12, num2=5</td><td>17</td><td>正常正整数</td></tr><tr><td>2</td><td>num1=0, num2=0</td><td>0</td><td>两个零</td></tr><tr><td>3</td><td>num1=-10, num2=5</td><td>-5</td><td>包含负数</td></tr><tr><td>4</td><td>num1=1000, num2=2000</td><td>3000</td><td>较大数字</td></tr></tbody></table><h2 id="扩展思考"><a class="markdownIt-Anchor" href="#扩展思考"></a> 扩展思考</h2><h3 id="相关题目"><a class="markdownIt-Anchor" href="#相关题目"></a> 相关题目</h3><ol><li><p><strong>两数相减</strong>：实现两个整数的减法</p></li><li><p><strong>三数之和</strong>：计算三个整数的和</p></li><li><p><strong>链表相加</strong>：处理大数相加（超过整数范围）</p></li></ol><h3 id="实际应用"><a class="markdownIt-Anchor" href="#实际应用"></a> 实际应用</h3><ul><li><p>计算器应用中的基本运算</p></li><li><p>财务系统中的金额计算</p></li><li><p>游戏中的分数累加</p></li></ul><h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2><p>这道题目是LeetCode中最基础的题目之一，主要目的是：</p><ol><li><p>熟悉编程环境的基本操作</p></li><li><p>掌握基本的数据类型和运算符</p></li><li><p>理解函数的输入输出格式</p></li></ol><p>虽然题目简单，但它体现了编程的核心思想：<strong>用最直接的方式解决问题</strong>。在解决更复杂问题时，这种&quot;化繁为简&quot;的思维方式同样重要。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="作业练习" scheme="https://id-zy.github.io/categories/%E4%BD%9C%E4%B8%9A%E7%BB%83%E4%B9%A0/"/>
    
    
    <category term="LeetCode" scheme="https://id-zy.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>11.13 日常 | 直觉的陷阱与品牌的力量</title>
    <link href="https://id-zy.github.io/2025/11/13/11.13%E6%97%A5%E5%B8%B8/"/>
    <id>https://id-zy.github.io/2025/11/13/11.13%E6%97%A5%E5%B8%B8/</id>
    <published>2025-11-13T14:09:26.895Z</published>
    <updated>2025-11-13T14:09:12.845Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>今天继续阅读《思考，快与慢》的第三部分，深入了解了几个影响我们判断的重要概念：</p><ul><li><p><strong>大数定律</strong>：样本量越大，结果越接近理论预期</p></li><li><p><strong>小数定理</strong>：人们倾向于从小样本中过度推断结论</p></li><li><p><strong>锚定效应</strong>：初始值会像“锚”一样制约后续判断</p></li></ul><p>这些原理揭示了系统1（快思考）如何在无意识中主导我们的决策。书中提醒我们：<strong>无论直觉准确与否，都需要保持警惕</strong>。通过大量专注的练习和在合适环境下的应用，我们能够提升直觉的可靠性，但这需要持续的自我觉察。</p><p>今天还读到一篇关于苹果公司新款手机袋的短文。这款与三宅一生合作设计的布质手机袋起价150美元，引发了广泛争议。有人批评其定价过高，也有人赞赏其设计理念。这让我深刻感受到<strong>品牌效应</strong>的力量——当品牌积累足够的影响力时，即使看似简单的产品也能获得市场关注。<br /><img src="https://pic1.imgdb.cn/item/6915e6753203f7be0000a325.jpg" alt="" /></p><p>今日学习进展：</p><ul><li><p>上午完成了离散数学作业</p></li><li><p>中午刷了4道LeetCode算法题（包括两数相加、最小偶倍数等基础题型）</p></li><li><p>晚上学习了微机原理第三章，计划明天整理笔记</p></li></ul><p>从认知偏见到商业策略，从数学证明到系统编程，今天依然是在多重思维维度间穿梭的一天。保持理性的思考，同时理解感性的选择，或许就是我们这个时代需要的平衡。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="日常闲谈" scheme="https://id-zy.github.io/categories/%E6%97%A5%E5%B8%B8%E9%97%B2%E8%B0%88/"/>
    
    
    <category term="《思考，快与慢》" scheme="https://id-zy.github.io/tags/%E3%80%8A%E6%80%9D%E8%80%83%EF%BC%8C%E5%BF%AB%E4%B8%8E%E6%85%A2%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>11.12 日常 | 思考的顺序与善意的本能</title>
    <link href="https://id-zy.github.io/2025/11/12/11.12%E6%97%A5%E5%B8%B8/"/>
    <id>https://id-zy.github.io/2025/11/12/11.12%E6%97%A5%E5%B8%B8/</id>
    <published>2025-11-12T14:37:33.980Z</published>
    <updated>2025-11-12T14:36:14.750Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>今天继续阅读《思考，快与慢》。在第一部分中，我了解到人类思维运作的两种基本模式——系统1（快思考）与系统2（慢思考）。它们并无绝对的高下之分，而是各有所长：系统1依赖直觉与经验，是我们日常决策的主力；系统2则更理性、审慎，在复杂情境下被唤醒。</p><p>书中提到一个经典心理学实验，让我印象深刻：</p><blockquote><p>“所罗门·阿希曾描述两个人——艾伦与本，请受试者评价他们的性格：</p><ul><li><p>艾伦：聪明—勤奋—冲动—爱挑剔—固执—忌妒心强</p></li><li><p>本：忌妒心强—固执—爱挑剔—冲动—勤奋—聪明</p></li></ul><p>尽管两人特质完全相同，仅顺序相反，大多数人却更喜欢艾伦。前几条特质会改变我们对后续特质的理解——我们愿原谅聪明人的固执，却会因忌妒者的聪明而警觉。”</p></blockquote><p>原来，<strong>顺序本身就在无声地塑造我们的认知</strong>。这也让我联想到，“白月光之所以无可替代”，或许不仅因为那个人本身，也因ta出现在我们生命序列中最恰当的位置。</p><p>晚上读了一篇关于“潜在英雄”的短文。研究指出，人在危急时刻并非如电影中那样恐慌逃散，反而常会展现出自然的利他倾向。“旁观者冷漠”实为误解，团结互助才是人性底色。这令人感到温暖，也提醒我们：<strong>善意本就埋藏在每个人的本能之中</strong>。<br /><img src="https://pic1.imgdb.cn/item/69149b253203f7be00f99d53.jpg" alt="" /><br />今天，是从认知的秩序走向人性的微光的一天。我们如何思考，又如何选择成为谁——或许都藏在这些看似偶然的顺序与瞬间里。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="日常闲谈" scheme="https://id-zy.github.io/categories/%E6%97%A5%E5%B8%B8%E9%97%B2%E8%B0%88/"/>
    
    
    <category term="《思考，快与慢》" scheme="https://id-zy.github.io/tags/%E3%80%8A%E6%80%9D%E8%80%83%EF%BC%8C%E5%BF%AB%E4%B8%8E%E6%85%A2%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>温度转换</title>
    <link href="https://id-zy.github.io/2025/11/12/%E9%A2%983/"/>
    <id>https://id-zy.github.io/2025/11/12/%E9%A2%983/</id>
    <published>2025-11-12T14:37:25.902Z</published>
    <updated>2025-11-12T08:59:05.618Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="问题描述来源于leetcode"><a class="markdownIt-Anchor" href="#问题描述来源于leetcode"></a> 问题描述（来源于leetcode）</h2><p>给定一个四舍五入到两位小数的非负浮点数 <code>celsius</code> 表示摄氏度，需要将其转换为开氏度和华氏度，并以数组 <code>[kelvin, fahrenheit]</code> 的形式返回结果。</p><h3 id="转换公式"><a class="markdownIt-Anchor" href="#转换公式"></a> 转换公式</h3><ul><li><strong>开氏度</strong> = 摄氏度 + 273.15</li><li><strong>华氏度</strong> = 摄氏度 × 1.80 + 32.00</li></ul><p><strong>注意：</strong> 与实际答案误差不超过 10⁻⁵ 的结果被视为正确。</p><h2 id="解法分析"><a class="markdownIt-Anchor" href="#解法分析"></a> 解法分析</h2><p>这是一个基础的数学计算问题，直接应用给定的转换公式即可解决。</p><h3 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">convertTemperature</span>(<span class="params">self, celsius: <span class="built_in">float</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">float</span>]:</span><br><span class="line">        Kelvin = celsius + <span class="number">273.15</span></span><br><span class="line">        Fahrenheit = celsius * <span class="number">1.80</span> + <span class="number">32.00</span></span><br><span class="line">        <span class="keyword">return</span> [Kelvin, Fahrenheit]</span><br></pre></td></tr></table></figure><h2 id="算法详解"><a class="markdownIt-Anchor" href="#算法详解"></a> 算法详解</h2><h3 id="步骤分解"><a class="markdownIt-Anchor" href="#步骤分解"></a> 步骤分解</h3><ol><li><strong>接收输入</strong>：获取表示摄氏度的浮点数 <code>celsius</code></li><li><strong>计算开氏度</strong>：使用公式 <code>Kelvin = celsius + 273.15</code></li><li><strong>计算华氏度</strong>：使用公式 <code>Fahrenheit = celsius × 1.80 + 32.00</code></li><li><strong>返回结果</strong>：以数组形式返回 <code>[Kelvin, Fahrenheit]</code></li></ol><h3 id="复杂度分析"><a class="markdownIt-Anchor" href="#复杂度分析"></a> 复杂度分析</h3><ul><li><strong>时间复杂度</strong>：O(1) - 只涉及常数次数学运算</li><li><strong>空间复杂度</strong>：O(1) - 只使用了固定数量的变量</li></ul><h2 id="示例演示"><a class="markdownIt-Anchor" href="#示例演示"></a> 示例演示</h2><h3 id="示例-1"><a class="markdownIt-Anchor" href="#示例-1"></a> 示例 1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：celsius = 36.50</span><br><span class="line">输出：[309.65000, 97.70000]</span><br><span class="line">解释：</span><br><span class="line">开氏度 = 36.50 + 273.15 = 309.65</span><br><span class="line">华氏度 = 36.50 × 1.80 + 32.00 = 97.70</span><br></pre></td></tr></table></figure><h3 id="示例-2"><a class="markdownIt-Anchor" href="#示例-2"></a> 示例 2</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：celsius = 122.11</span><br><span class="line">输出：[395.26000, 251.79800]</span><br><span class="line">解释：</span><br><span class="line">开氏度 = 122.11 + 273.15 = 395.26</span><br><span class="line">华氏度 = 122.11 × 1.80 + 32.00 = 251.798</span><br></pre></td></tr></table></figure><h2 id="温度单位知识扩展"><a class="markdownIt-Anchor" href="#温度单位知识扩展"></a> 温度单位知识扩展</h2><h3 id="三种温度标度对比"><a class="markdownIt-Anchor" href="#三种温度标度对比"></a> 三种温度标度对比</h3><table><thead><tr><th>温度标度</th><th>发明者</th><th>零点定义</th><th>沸点定义</th><th>应用领域</th></tr></thead><tbody><tr><td>摄氏度(°C)</td><td>安德斯·摄尔修斯</td><td>水的冰点</td><td>水的沸点</td><td>日常生活、科学</td></tr><tr><td>开氏度(K)</td><td>开尔文勋爵</td><td>绝对零度</td><td>水的沸点</td><td>科学研究</td></tr><tr><td>华氏度(°F)</td><td>丹尼尔·华伦海特</td><td>盐水冰点</td><td>人体温度</td><td>美国日常</td></tr></tbody></table><h3 id="转换公式总结"><a class="markdownIt-Anchor" href="#转换公式总结"></a> 转换公式总结</h3><ul><li><strong>摄氏转开氏</strong>：K = °C + 273.15</li><li><strong>开氏转摄氏</strong>：°C = K - 273.15</li><li><strong>摄氏转华氏</strong>：°F = °C × 1.8 + 32</li><li><strong>华氏转摄氏</strong>：°C = (°F - 32) ÷ 1.8</li></ul><h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2><p>这道题目是一个基础的数学计算问题，主要考察：</p><ol><li>对基本数学公式的理解和应用能力</li><li>浮点数运算的准确性</li><li>数组的构建和返回</li></ol><p>虽然题目简单，但它涉及了实际生活中常用的温度单位转换，具有实用价值。通过解决这个问题，我们可以更好地理解不同温度标度之间的关系，为后续更复杂的计算问题打下基础。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="作业练习" scheme="https://id-zy.github.io/categories/%E4%BD%9C%E4%B8%9A%E7%BB%83%E4%B9%A0/"/>
    
    
    <category term="LeetCode" scheme="https://id-zy.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>两数之和</title>
    <link href="https://id-zy.github.io/2025/11/11/%E9%A2%982/"/>
    <id>https://id-zy.github.io/2025/11/11/%E9%A2%982/</id>
    <published>2025-11-11T13:06:27.966Z</published>
    <updated>2025-11-11T12:55:38.852Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="问题描述问题来源于leetcode"><a class="markdownIt-Anchor" href="#问题描述问题来源于leetcode"></a> 问题描述(问题来源于LeetCode)</h2><p>给定一个整数数组 <code>nums</code> 和一个整数目标值 <code>target</code>，在数组中找出<strong>和为目标值</strong>的那<strong>两个</strong>整数，并返回它们的数组下标。</p><p>假设每种输入只会对应一个答案，并且不能使用两次相同的元素。</p><p><strong>示例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">text</span><br><span class="line"></span><br><span class="line">输入：nums = [2,7,11,15], target = 9</span><br><span class="line">输出：[0,1]</span><br><span class="line">解释：nums[0] + nums[1] = 2 + 7 = 9</span><br></pre></td></tr></table></figure><h2 id="解法暴力枚举"><a class="markdownIt-Anchor" href="#解法暴力枚举"></a> 解法：暴力枚举</h2><h3 id="思路分析"><a class="markdownIt-Anchor" href="#思路分析"></a> 思路分析</h3><p>通过两层循环遍历所有可能的数字组合，检查它们的和是否等于目标值。</p><h3 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">python</span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def twoSum(self, nums: List[int], target: int) -&gt; List[int]:</span><br><span class="line">        for i in range(len(nums)):</span><br><span class="line">            for j in range(i + 1, len(nums)):</span><br><span class="line">                if nums[i] + nums[j] == target:</span><br><span class="line">                    return [i, j]</span><br></pre></td></tr></table></figure><h3 id="复杂度分析"><a class="markdownIt-Anchor" href="#复杂度分析"></a> 复杂度分析</h3><ul><li><p><strong>时间复杂度</strong>：O(n²) - 需要两层循环遍历所有组合</p></li><li><p><strong>空间复杂度</strong>：O(1) - 只使用了常数级别的额外空间</p></li></ul><h3 id="优缺点"><a class="markdownIt-Anchor" href="#优缺点"></a> 优缺点</h3><p><strong>优点：</strong></p><ul><li><p>思路简单直观，容易理解和实现</p></li><li><p>不需要额外空间</p></li></ul><p><strong>缺点：</strong></p><ul><li>时间复杂度高，在大数据量下性能较差</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="作业练习" scheme="https://id-zy.github.io/categories/%E4%BD%9C%E4%B8%9A%E7%BB%83%E4%B9%A0/"/>
    
    
    <category term="LeetCode" scheme="https://id-zy.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>11.11 日常 | 细菌、量子与延迟工作</title>
    <link href="https://id-zy.github.io/2025/11/11/11.11%E6%97%A5%E5%B8%B8/"/>
    <id>https://id-zy.github.io/2025/11/11/11.11%E6%97%A5%E5%B8%B8/</id>
    <published>2025-11-11T13:06:20.385Z</published>
    <updated>2025-11-11T13:05:21.073Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>今天早上读了一篇很有意思的科普短文，探讨了我们穿着外衣直接坐在床上是否会带来细菌污染。文章指出，虽然理论上衣物可能成为病菌传播的媒介，但实际风险很低——大多数病原体在织物上存活时间很短，且需要达到一定数量才能致病。不过，如果家里有免疫力较弱的成员，或是衣物被明显污染时，及时更换仍是明智之举。<br /><img src="https://pic1.imgdb.cn/item/691333b43203f7be00f4bd6a.jpg" alt="" /></p><p>中午终于读完了《上帝掷骰子吗》这本量子物理科普书。虽然之前通过《时间简史》对部分内容有所了解，但这次阅读仍让我收获颇丰，特别是对“观察者效应”和“超弦理论”有了更深入的理解。量子世界的发展史充满了意外与突破，许多伟大发现往往在多年后才显现其深远意义。<br />下午完成了操作系统实验二，晚上则练习了一道LeetCode算法题——经典的“两数之和”。我采用了暴力枚举的解法，虽然时间复杂度较高（O(n²)），但胜在思路直观，适合小规模数据。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">python</span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def twoSum(self, nums: List[int], target: int) -&gt; List[int]:</span><br><span class="line">        for i in range(len(nums)):</span><br><span class="line">            for j in range(i + 1, len(nums)):</span><br><span class="line">                if nums[i] + nums[j] == target:</span><br><span class="line">                    return [i, j]</span><br></pre></td></tr></table></figure><p>此外，还研究了一个Linux内核模块的代码，涉及延迟工作队列（workqueue）和内核线程（kthread）的实现。通过创建10个工作项和10个内核线程，观察它们在不同延迟下的执行顺序，深入理解了内核中异步处理机制的运作方式。</p><p>今天是在科普知识、量子物理、系统编程和算法练习之间穿梭的一天。从微观世界的奇妙规律到代码世界的精确逻辑，每一种探索都在拓展认知的边界。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="日常闲谈" scheme="https://id-zy.github.io/categories/%E6%97%A5%E5%B8%B8%E9%97%B2%E8%B0%88/"/>
    
    
    <category term="《上帝掷骰子吗》" scheme="https://id-zy.github.io/tags/%E3%80%8A%E4%B8%8A%E5%B8%9D%E6%8E%B7%E9%AA%B0%E5%AD%90%E5%90%97%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>微型计算机概述</title>
    <link href="https://id-zy.github.io/2025/11/10/%E5%BE%AE%E5%9E%8B%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%A6%82%E8%BF%B0/"/>
    <id>https://id-zy.github.io/2025/11/10/%E5%BE%AE%E5%9E%8B%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%A6%82%E8%BF%B0/</id>
    <published>2025-11-10T12:36:46.012Z</published>
    <updated>2025-11-10T12:39:15.595Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1基本概念"><a class="markdownIt-Anchor" href="#1基本概念"></a> 1基本概念</h3><h4 id="11"><a class="markdownIt-Anchor" href="#11"></a> 1.1</h4><p>微处理器：</p><ul><li>CPU内核</li><li>单核处理器</li><li>多核处理器<br />微型计算机<br />微型计算机系统<br />单片机<br />单片机系统<br />Soc(System on Chip)<br />嵌入式系统<br /><img src="https://pic1.imgdb.cn/item/6911a6133203f7be00ed2eb5.png" alt="" /></li></ul><h4 id="12微型计算机系统的简化结构"><a class="markdownIt-Anchor" href="#12微型计算机系统的简化结构"></a> 1.2微型计算机系统的简化结构</h4><p><img src="https://pic1.imgdb.cn/item/6911a6133203f7be00ed2eb8.png" alt="" /></p><h4 id="13嵌入式系统的特点"><a class="markdownIt-Anchor" href="#13嵌入式系统的特点"></a> 1.3嵌入式系统的特点</h4><ul><li><p><strong>以应用为核心，</strong></p></li><li><p><strong>以计算机技术为基础，</strong></p></li><li><p><strong>软、硬件可“裁剪”，</strong></p></li><li><p><strong>适合对功能、实时性、可靠性、安全性、体积、重量、成本、功耗、环境、安装方式等方面有严格要求的专用计算机系统。</strong></p></li><li><p><strong>更强功能、更小尺寸的高级单片机系统。</strong></p></li></ul><h3 id="2-微处理器概述"><a class="markdownIt-Anchor" href="#2-微处理器概述"></a> 2 微处理器概述</h3><h3 id="3-微型计算机pc概述"><a class="markdownIt-Anchor" href="#3-微型计算机pc概述"></a> 3 微型计算机（PC）概述</h3><h4 id="31-硬件"><a class="markdownIt-Anchor" href="#31-硬件"></a> 3.1 硬件</h4><ul><li><strong>①微型计算机（主机）：</strong><ul><li><strong>CPU、系统总线、内存、接口</strong></li></ul></li><li><strong>②外围设备：</strong><ul><li><strong>外部设备</strong><ul><li><strong>输入设备、输出设备、辅助存储器</strong></li></ul></li><li><strong>辅助设备：电源电路、时钟电路</strong></li></ul></li></ul><h4 id="32-软件"><a class="markdownIt-Anchor" href="#32-软件"></a> 3.2 软件</h4><ul><li><strong>①系统软件：</strong><ul><li><strong>对各部分硬件管理、协调：OS</strong></li><li><strong>编程语言开发工具、数据库管理系统、</strong></li><li><strong>硬件监测诊断工具</strong></li></ul></li><li><strong>②应用软件（用户软件）</strong></li></ul><h4 id="33-pc的基本组成"><a class="markdownIt-Anchor" href="#33-pc的基本组成"></a> 3.3 PC的基本组成</h4><p>内存：也称主存，CPU可直接访问的存储器。<br /><img src="https://pic1.imgdb.cn/item/6911a6133203f7be00ed2eb6.png" alt="" /><br /><img src="https://pic1.imgdb.cn/item/6911a6133203f7be00ed2eb7.png" alt="" /></p><h3 id="4-习题练习"><a class="markdownIt-Anchor" href="#4-习题练习"></a> 4 习题练习</h3><h4 id="18088是____位处理器"><a class="markdownIt-Anchor" href="#18088是____位处理器"></a> 1.8088是____位处理器</h4><p>解答：8088是16位处理器</p><h4 id="2-intel第一款32位处理器为"><a class="markdownIt-Anchor" href="#2-intel第一款32位处理器为"></a> 2. Intel第一款32位处理器为</h4><p>解答：80386</p><h4 id="3-intel-core-i7-处理器属于-______"><a class="markdownIt-Anchor" href="#3-intel-core-i7-处理器属于-______"></a> 3. Intel Core i7 处理器属于 ______</h4><p>解答：SOC</p><h4 id="4-计算机启动后最先执行的是______代码"><a class="markdownIt-Anchor" href="#4-计算机启动后最先执行的是______代码"></a> 4. 计算机启动后，最先执行的是______代码</h4><p>解答：BIOS 或 UEFI</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="微原" scheme="https://id-zy.github.io/categories/%E5%BE%AE%E5%8E%9F/"/>
    
    
    <category term="微机原理" scheme="https://id-zy.github.io/tags/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>11.10 日常 | 量子、单调栈与生活的细节</title>
    <link href="https://id-zy.github.io/2025/11/10/11.10%E6%97%A5%E5%B8%B8/"/>
    <id>https://id-zy.github.io/2025/11/10/11.10%E6%97%A5%E5%B8%B8/</id>
    <published>2025-11-10T12:36:27.524Z</published>
    <updated>2025-11-10T12:38:48.218Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>上午写完了离散数学的作业，在集合与逻辑的世界里完成了一次思维的漫步。</p><p>下午则整理了微机原理的第一章——微型计算机概述，将那些基础的架构与概念重新梳理，为后续的学习打下地基。</p><p>今天的阅读依旧是《上帝掷骰子吗？》。这本关于量子物理发展的科普书，其中大部分内容我其实已在《时间简史》中有所涉猎，因此阅读的新鲜感不免减弱。但既然打开了，还是决定把它读完——每一本科普作品都凝聚着作者的心血，不应被轻易辜负。</p><p>今天读到了“薛定谔的猫”这一经典思想实验的提出。再次回顾量子力学这段充满争议与突破的历史，不禁感叹：许多伟大的发现，往往诞生于不经意的瞬间，或是其深远意义要经过漫长时光才能被真正理解。这种“延迟的震撼”，恰恰是科学史最迷人的地方之一。<br /><img src="https://pic1.imgdb.cn/item/6911d9b23203f7be00ed60db.jpg" alt="1" /><br /><img src="https://pic1.imgdb.cn/item/6911d9b03203f7be00ed60d4.jpg" alt="" /></p><p>今天还读了两篇短文。一篇谈及<strong>塑造我们的，往往是生活中那些微小的细节</strong>；另一篇则介绍了一个关于人际交流的<strong>四种状态模型</strong>，简洁而富有启发性。</p><p>晚上继续刷题，学习了<strong>单调栈算法</strong>。这种数据结构在处理“下一个更大元素”类问题时，展现出一种优雅的简洁与高效。</p><p>今天，是从数学到物理，从理论到实践，从宏大叙事到生活细节的一天。世界由量子的不确定性与人际交流的确定性共同构成，而我们，在学习中试图理解这一切。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="日常闲谈" scheme="https://id-zy.github.io/categories/%E6%97%A5%E5%B8%B8%E9%97%B2%E8%B0%88/"/>
    
    
    <category term="个人成长" scheme="https://id-zy.github.io/tags/%E4%B8%AA%E4%BA%BA%E6%88%90%E9%95%BF/"/>
    
    <category term="《上帝掷骰子吗》" scheme="https://id-zy.github.io/tags/%E3%80%8A%E4%B8%8A%E5%B8%9D%E6%8E%B7%E9%AA%B0%E5%AD%90%E5%90%97%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>将所有元素变为 0 的最少操作次数</title>
    <link href="https://id-zy.github.io/2025/11/10/%E5%88%B7%E9%A2%981/"/>
    <id>https://id-zy.github.io/2025/11/10/%E5%88%B7%E9%A2%981/</id>
    <published>2025-11-10T12:36:10.792Z</published>
    <updated>2025-11-10T12:28:46.886Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="问题描述"><a class="markdownIt-Anchor" href="#问题描述"></a> 问题描述</h2><p>给定一个大小为 n 的非负整数数组 nums，我们需要通过若干次操作将数组中的所有元素变为 0。每次操作可以选择一个子数组 [i, j]，将该子数组中所有最小的非负整数设为 0。目标是找到使整个数组变为 0 所需的最少操作次数。</p><h2 id="关键思路"><a class="markdownIt-Anchor" href="#关键思路"></a> 关键思路</h2><p>经过分析，发现这个问题可以通过<strong>单调栈</strong>高效解决。核心思路是：</p><ul><li><p>维护一个单调递减栈，栈中元素表示需要单独处理的不同数值</p></li><li><p>当遇到比栈顶元素小的数字时，需要先处理掉栈顶元素（弹出并计数）</p></li><li><p>最终栈中剩余的元素也需要各自处理</p></li></ul><h2 id="算法实现"><a class="markdownIt-Anchor" href="#算法实现"></a> 算法实现</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def minOperations(self, nums: List[int]) -&gt; int:</span><br><span class="line">        stack = []  # 单调递减栈</span><br><span class="line">        operations = 0  # 操作计数器</span><br><span class="line">        </span><br><span class="line">        for num in nums:</span><br><span class="line">            # 当栈不为空且栈顶元素大于当前元素时</span><br><span class="line">            while stack and stack[-1] &gt; num:</span><br><span class="line">                operations += 1  # 需要一次操作来处理栈顶元素</span><br><span class="line">                stack.pop()  # 弹出栈顶元素</span><br><span class="line">            </span><br><span class="line">            # 如果当前元素不为0，且满足入栈条件，则压入栈中</span><br><span class="line">            if num and (not stack or stack[-1] != num):</span><br><span class="line">                stack.append(num)</span><br><span class="line">        </span><br><span class="line">        # 栈中剩余元素也需要操作</span><br><span class="line">        operations += len(stack)</span><br><span class="line">        </span><br><span class="line">        return operations</span><br></pre></td></tr></table></figure><h2 id="算法步骤详解"><a class="markdownIt-Anchor" href="#算法步骤详解"></a> 算法步骤详解</h2><ol><li><p><strong>初始化</strong>：创建一个空栈和一个操作计数器</p></li><li><p><strong>遍历数组</strong>：对于每个元素：</p><ul><li><p>如果栈不为空且栈顶元素大于当前元素，弹出栈顶并增加操作计数</p></li><li><p>如果当前元素不为0且满足入栈条件（栈为空或栈顶不等于当前元素），将其压入栈中</p></li></ul></li><li><p><strong>处理剩余元素</strong>：将栈中剩余元素的数量加到操作计数中</p></li><li><p><strong>返回结果</strong>：返回总操作次数</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="作业练习" scheme="https://id-zy.github.io/categories/%E4%BD%9C%E4%B8%9A%E7%BB%83%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>单调栈</title>
    <link href="https://id-zy.github.io/2025/11/10/%E5%8D%95%E8%B0%83%E6%A0%88/"/>
    <id>https://id-zy.github.io/2025/11/10/%E5%8D%95%E8%B0%83%E6%A0%88/</id>
    <published>2025-11-10T12:36:10.790Z</published>
    <updated>2025-11-10T12:40:38.123Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="单调栈算法"><a class="markdownIt-Anchor" href="#单调栈算法"></a> 单调栈算法</h3><p>单调栈是一种特殊的数据结构，分为单调递增栈和单调递减栈，保证元素从栈顶到栈底的单调性。单调栈常用于在<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>的时间复杂度内寻找序列中某些元素的相邻元素，如左侧第一个更大/更小的元素等。</p><h4 id="单调递增栈"><a class="markdownIt-Anchor" href="#单调递增栈"></a> 单调递增栈</h4><p>单调递增栈的特点是从栈顶到栈底的元素是单调递增的。只有比栈顶元素小的元素才能直接进栈，否则需要先将栈中比当前元素小的元素出栈，再将当前元素入栈。这样就保证了栈中保留的都是比当前入栈元素大的值。</p><p>代码示例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">def monotoneIncreasingStack(nums):</span><br><span class="line"></span><br><span class="line">stack = []</span><br><span class="line"></span><br><span class="line">for num in nums:</span><br><span class="line"></span><br><span class="line">while stack and num &gt;= stack[-1]:</span><br><span class="line"></span><br><span class="line">stack.pop()</span><br><span class="line"></span><br><span class="line">stack.append(num)</span><br><span class="line"></span><br><span class="line">return stack</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="单调递减栈"><a class="markdownIt-Anchor" href="#单调递减栈"></a> 单调递减栈</h4><p>单调递减栈的特点是从栈顶到栈底的元素是单调递减的。只有比栈顶元素大的元素才能直接进栈，否则需要先将栈中比当前元素大的元素出栈，再将当前元素入栈。这样就保证了栈中保留的都是比当前入栈元素小的值。</p><p>代码示例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">def monotoneDecreasingStack(nums):</span><br><span class="line"></span><br><span class="line">stack = []</span><br><span class="line"></span><br><span class="line">for num in nums:</span><br><span class="line"></span><br><span class="line">while stack and num &lt;= stack[-1]:</span><br><span class="line"></span><br><span class="line">stack.pop()</span><br><span class="line"></span><br><span class="line">stack.append(num)</span><br><span class="line"></span><br><span class="line">return stack</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="应用场景"><a class="markdownIt-Anchor" href="#应用场景"></a> 应用场景</h4><p>单调栈可以在时间复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>的情况下，求解出某个元素左边或者右边第一个比它大或者小的元素。常见的应用场景包括：</p><ol><li><p><strong>寻找左侧第一个比当前元素大的元素</strong>：从左到右遍历元素，构造单调递增栈。</p></li><li><p><strong>寻找左侧第一个比当前元素小的元素</strong>：从左到右遍历元素，构造单调递减栈。</p></li><li><p><strong>寻找右侧第一个比当前元素大的元素</strong>：从右到左遍历元素，构造单调递增栈。</p></li><li><p><strong>寻找右侧第一个比当前元素小的元素</strong>：从右到左遍历元素，构造单调递减栈。</p></li></ol><h4 id="实际问题示例"><a class="markdownIt-Anchor" href="#实际问题示例"></a> 实际问题示例</h4><h5 id="下一个更大元素"><a class="markdownIt-Anchor" href="#下一个更大元素"></a> 下一个更大元素</h5><p>给定两个没有重复元素的数组_nums1_和_nums2_，其中_nums1_是_nums2_的子集。要求找出_nums1_中每个元素在_nums2_中的下一个比其大的值。</p><p>代码示例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line"></span><br><span class="line">def nextGreaterElement(self, nums1, nums2):</span><br><span class="line"></span><br><span class="line">res = []</span><br><span class="line"></span><br><span class="line">stack = []</span><br><span class="line"></span><br><span class="line">num_map = &#123;&#125;</span><br><span class="line"></span><br><span class="line">for num in nums2:</span><br><span class="line"></span><br><span class="line">while stack and num &gt; stack[-1]:</span><br><span class="line"></span><br><span class="line">num_map[stack.pop()] = num</span><br><span class="line"></span><br><span class="line">stack.append(num)</span><br><span class="line"></span><br><span class="line">for num in nums1:</span><br><span class="line"></span><br><span class="line">res.append(num_map.get(num, -1))</span><br><span class="line"></span><br><span class="line">return res</span><br></pre></td></tr></table></figure><p>通过以上代码和示例，可以看出单调栈在解决某些特定问题时非常高效，能够将时间复杂度从<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>降低到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="数据结构" scheme="https://id-zy.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="LeetCode" scheme="https://id-zy.github.io/tags/LeetCode/"/>
    
    <category term="数据结构" scheme="https://id-zy.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="算法" scheme="https://id-zy.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>11.9 日常| 默默耕耘中</title>
    <link href="https://id-zy.github.io/2025/11/09/11.9%E6%97%A5%E5%B8%B8/"/>
    <id>https://id-zy.github.io/2025/11/09/11.9%E6%97%A5%E5%B8%B8/</id>
    <published>2025-11-09T13:31:55.310Z</published>
    <updated>2025-11-09T13:31:45.576Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>今天是周日，放任自己暂别课业，在英雄联盟中消磨时光，等待下午在成都举行的全球总决赛。</p><p>比赛异常精彩，最终，恭喜 <strong>T1 拿下队史第六冠，Faker成就个人三连冠</strong>。当金色的雨为他们落下，屏幕内外皆是山呼海啸——这是电竞的魔力，也是坚持的回报。</p><p>激动过后，是安静的阅读时光。<br />今天读完了《质数的孤独》。合上书页，心里萦绕着那句：</p><blockquote><p>“我看见你，却试图不看你；我闭上眼，你却来到我的身边。”</p></blockquote><p>我在想，如果马蒂亚和爱丽丝能再勇敢一点，再坦诚一点，把那些欲语未言的话全都说出口，结局会不会不一样？<br />因为害怕吐露真心，他们错过了一次；又因为自以为成全了对方的幸福，他们再次错过。他以为她尚未离婚，她以为他在她心中只占一隅。</p><p>哎。他们就像数学中那一对不断接近却永不相邻的质数，明明是灵魂最近的人，却隔着一道无法跨越的、名为“沉默”与“误解”的距离。</p><p>今天的报纸阅读，是关于嘉兴桐乡濮院的互联网生活嘉年华。游客们可以在那里体验各式各样的数字活动——世界在热烈地向前，而总有人在某个安静的角落，咀嚼着属于两个人的、漫长的错过。</p><p>今天，是在盛大的狂欢与静默的独白之间，轻轻走过的一天。<br />我们都在学习勇敢，只是有些人，学得慢了一些。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="日常闲谈" scheme="https://id-zy.github.io/categories/%E6%97%A5%E5%B8%B8%E9%97%B2%E8%B0%88/"/>
    
    
    <category term="《质数的孤独》" scheme="https://id-zy.github.io/tags/%E3%80%8A%E8%B4%A8%E6%95%B0%E7%9A%84%E5%AD%A4%E7%8B%AC%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>《无姓之人》：在无限可能中，寻找唯一的真实</title>
    <link href="https://id-zy.github.io/2025/11/08/%E6%97%A0%E5%A7%93%E4%B9%8B%E4%BA%BA/"/>
    <id>https://id-zy.github.io/2025/11/08/%E6%97%A0%E5%A7%93%E4%B9%8B%E4%BA%BA/</id>
    <published>2025-11-08T11:18:31.645Z</published>
    <updated>2025-11-08T07:20:21.572Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在2092年，当宇宙走向坍缩的终点，男主角尼莫的生命也随之终结。然而，死亡亦是新生——他重新经历了自己的一生，并在每一个抉择的岔路口，看见无数种可能的未来如枝叶般分叉、蔓延。</p><p>初次观看《无姓之人》，或许会感到些许纷乱。但耐心走下去，你会发现这是一部结构高度完整的作品。导演以精巧的叙事织出一张时间的网，在影片结尾，将所有伏笔一一收回。</p><p>电影建立在两个迷人的设定上：“维度交叉使矛盾事件同时发生”与“蝴蝶效应”。我们跟随尼莫，看他如何在爱情的站台、家庭的变故、人生的关口做出不同选择，从而展开截然不同的生命图景——某种程度上，这像极了一部沉浸式的“人生模拟器”。</p><p>影片探讨的层次极为丰富：</p><ul><li><p><strong>因果的倒置与重构</strong>：真实世界往往“种因得果”，而电影中的宇宙却常常“先果后因”。尼莫在终点望尽所有结局，而每一种结局，又反过来定义了他所经历的“因”。</p></li><li><p><strong>对自我选择的尊重</strong>：影片告诉我们，人生虽有无尽可能，但每一条路都有其意义。我们无法像尼莫那样预知所有结局，只能在“一命通关”的模式下，真诚地做出每一次选择，并尊重由此展开的生活。</p></li><li><p><strong>何为真实的诘问</strong>：我们所以为的“现实”，究竟是真实发生的叙事，还是意识构筑的幻象？“缸中之脑”的经典命题在片中若隐若现，引导我们反思感知与存在的关系。</p></li><li><p><strong>未来世界的想象</strong>：从太空电梯到细胞电磁化，从虚拟成像技术到火星观光，电影勾勒出一幅既瑰丽又疏离的近未来图景，既令人神往，也暗藏对技术文明的审视。</p></li></ul><p>《无姓之人》不仅是一部科幻电影，更是一首关于时间、记忆与身份的哲学诗。它没有给出关于生命唯一的答案，却温柔地提醒我们：</p><p><strong>我们每个人都是“无姓之人”，在茫茫的可能性中漂流。而所谓人生，不过是在无数条“正确”的道路中，勇敢地走完自己选择的那一条，并热爱它独有的风景。</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="创作" scheme="https://id-zy.github.io/categories/%E5%88%9B%E4%BD%9C/"/>
    
    
    <category term="生活哲思" scheme="https://id-zy.github.io/tags/%E7%94%9F%E6%B4%BB%E5%93%B2%E6%80%9D/"/>
    
    <category term="电影影评" scheme="https://id-zy.github.io/tags/%E7%94%B5%E5%BD%B1%E5%BD%B1%E8%AF%84/"/>
    
  </entry>
  
  <entry>
    <title>11.8 日常 | 考试、电影与质数的距离</title>
    <link href="https://id-zy.github.io/2025/11/08/11.8%E6%97%A5%E5%B8%B8/"/>
    <id>https://id-zy.github.io/2025/11/08/11.8%E6%97%A5%E5%B8%B8/</id>
    <published>2025-11-08T11:18:23.724Z</published>
    <updated>2025-11-08T11:17:39.135Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>上午十点参加了C2考试，过程比预想中顺利。结束后回到寝室，在游戏里放松片刻，随后看完了《无姓之人》，并写下一篇影评。那穿梭于平行人生中的抉择与遗憾，仍在脑海里微微发烫。</p><p>午后，翻开《质数的孤独》。今天读到马蒂亚正在思考是否要接受国外的工作机会。这位带着自毁倾向的数学天才，习惯用沉默筑起高墙，在周身划出一道深渊，既保护自己，也隔绝他人。而女主角爱丽丝，则在家庭的影响下变得自卑又渴望被爱。</p><p>他们在一次聚会中相识，迅速察觉到彼此灵魂里相似的孤独频率。像是数学中两个相邻的质数，他们能清晰地看见对方，理解那份与生俱来的疏离，却始终隔着一道无法跨越的偶数距离——如此相近，又无法真正靠近。</p><p>今天的英文短报是一则简讯：关于推动大湾区进一步的改革开放。世界的运转从未停歇，而个体的孤独与联结，也在每一个角落静静发生。</p><p>今天，是从考场的确定性，到电影的无限可能，再到书页间微妙情感的一天。我们都是各自的质数，在茫茫数轴上，寻找着能理解这段距离的人。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="日常闲谈" scheme="https://id-zy.github.io/categories/%E6%97%A5%E5%B8%B8%E9%97%B2%E8%B0%88/"/>
    
    
    <category term="《质数的孤独》" scheme="https://id-zy.github.io/tags/%E3%80%8A%E8%B4%A8%E6%95%B0%E7%9A%84%E5%AD%A4%E7%8B%AC%E3%80%8B/"/>
    
  </entry>
  
</feed>
