<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>笺札</title>
  
  
  <link href="https://id-zy.github.io/atom.xml" rel="self"/>
  
  <link href="https://id-zy.github.io/"/>
  <updated>2026-01-19T04:18:46.861Z</updated>
  <id>https://id-zy.github.io/</id>
  
  <author>
    <name>zhaoyuan</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>选择排序</title>
    <link href="https://id-zy.github.io/2026/01/19/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/"/>
    <id>https://id-zy.github.io/2026/01/19/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/</id>
    <published>2026-01-19T07:18:08.121Z</published>
    <updated>2026-01-19T04:18:46.861Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="选择排序"><a class="markdownIt-Anchor" href="#选择排序"></a> 选择排序</h1><h2 id="基本概念"><a class="markdownIt-Anchor" href="#基本概念"></a> 基本概念</h2><p><strong>选择排序（Selection Sort）基本思想</strong>：<br />将数组分为两个区间：左侧为已排序区间，右侧为未排序区间。每趟从未排序区间中选择最小的元素，放到已排序区间的末尾。</p><h2 id="算法步骤"><a class="markdownIt-Anchor" href="#算法步骤"></a> 算法步骤</h2><p>假设数组长度为n，选择排序的算法步骤如下：</p><ol><li><strong>初始状态</strong>：已排序区间为空，未排序区间为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mi>n</mi><mtext>−</mtext><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[0,n−1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">n</span><span class="mord">−</span><span class="mord">1</span><span class="mclose">]</span></span></span></span>。</li><li><strong>第i趟选择</strong>（i从1开始）：<ol><li>在未排序区间 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>i</mi><mtext>−</mtext><mn>1</mn><mo separator="true">,</mo><mi>n</mi><mtext>−</mtext><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[i−1,n−1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mord">−</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">n</span><span class="mord">−</span><span class="mord">1</span><span class="mclose">]</span></span></span></span>中找到最小元素的位置 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mi>i</mi><msub><mi>n</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">min_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.80952em;vertical-align:-0.15em;"></span><span class="mord mathnormal">m</span><span class="mord mathnormal">i</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。</li><li>将位置i−1的元素与位置<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mi>i</mi><msub><mi>n</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">min_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.80952em;vertical-align:-0.15em;"></span><span class="mord mathnormal">m</span><span class="mord mathnormal">i</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的元素交换。</li><li>此时<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mi>i</mi><mtext>−</mtext><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[0,i−1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">i</span><span class="mord">−</span><span class="mord">1</span><span class="mclose">]</span></span></span></span>为已排序区间，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>i</mi><mo separator="true">,</mo><mi>n</mi><mtext>−</mtext><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[i,n−1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">n</span><span class="mord">−</span><span class="mord">1</span><span class="mclose">]</span></span></span></span>为未排序区间。</li></ol></li><li><strong>重复步骤 2</strong>，直到未排序区间为空，排序完成。</li></ol><h2 id="内部实现"><a class="markdownIt-Anchor" href="#内部实现"></a> 内部实现：</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">selectionSort</span>(<span class="params">self,nums:[<span class="built_in">int</span>]</span>)-&gt;[<span class="built_in">int</span>]:</span><br><span class="line">n=<span class="built_in">len</span>(nums)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n-<span class="number">1</span>):</span><br><span class="line">min_i=i</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>,n):</span><br><span class="line"><span class="keyword">if</span> nums[j]&lt;nums[min_i]:</span><br><span class="line">min_i=j</span><br><span class="line"><span class="keyword">if</span> i !=min_i:</span><br><span class="line">nums[i],nums[min_i]=nums[min_i],nums[i]</span><br><span class="line"><span class="keyword">return</span> nums</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sortArray</span>(<span class="params">self,nums:[<span class="built_in">int</span>]</span>)-&gt;[<span class="built_in">int</span>]:</span><br><span class="line"><span class="keyword">return</span> <span class="variable language_">self</span>,selectionSort(nums)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="复杂度分析"><a class="markdownIt-Anchor" href="#复杂度分析"></a> 复杂度分析：</h2><table><thead><tr><th>指标</th><th>复杂度</th><th>说明</th></tr></thead><tbody><tr><td><strong>最佳时间复杂度</strong></td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></td><td>无论数组状态如何，都需要 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo stretchy="false">(</mo><mi>n</mi><mtext>−</mtext><mn>1</mn><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">n(n−1)/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mord">−</span><span class="mord">1</span><span class="mclose">)</span><span class="mord">/</span><span class="mord">2</span></span></span></span>​ 次比较</td></tr><tr><td><strong>最坏时间复杂度</strong></td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></td><td>无论数组状态如何，都需要 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo stretchy="false">(</mo><mi>n</mi><mtext>−</mtext><mn>1</mn><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">n(n−1)/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mord">−</span><span class="mord">1</span><span class="mclose">)</span><span class="mord">/</span><span class="mord">2</span></span></span></span>次比较</td></tr><tr><td><strong>平均时间复杂度</strong></td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></td><td>选择排序的时间复杂度与数据状态无关</td></tr><tr><td><strong>空间复杂度</strong></td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></td><td>原地排序，只使用常数空间</td></tr><tr><td><strong>稳定性</strong></td><td>不稳定</td><td>交换操作可能改变相等元素的相对顺序</td></tr><tr><td><strong>适用场景</strong>：</td><td></td><td></td></tr></tbody></table><ul><li>数据量较小（n&lt;50）</li><li>对空间复杂度要求严格的场景<br />选择排序是一种简单直观的排序算法，通过不断选择未排序区间的最小元素来构建有序序列。</li><li><strong>优点</strong>：实现简单，空间复杂度低，交换次数少</li><li><strong>缺点</strong>：时间复杂度高，不适合大规模数据</li></ul><h2 id="应用场景"><a class="markdownIt-Anchor" href="#应用场景"></a> 应用场景：</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="数据结构" scheme="https://id-zy.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>插入排序</title>
    <link href="https://id-zy.github.io/2026/01/19/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/"/>
    <id>https://id-zy.github.io/2026/01/19/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/</id>
    <published>2026-01-19T07:18:08.119Z</published>
    <updated>2026-01-19T05:59:17.589Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="插入排序"><a class="markdownIt-Anchor" href="#插入排序"></a> 插入排序</h1><h2 id="基本概念"><a class="markdownIt-Anchor" href="#基本概念"></a> 基本概念</h2><p><strong>插入排序（Insertion Sort）基本思想</strong>：</p><p>将数组分为有序区间和无序区间，每次从无序区间取出一个元素插入到有序区间的正确位置。</p><h2 id="算法步骤"><a class="markdownIt-Anchor" href="#算法步骤"></a> 算法步骤</h2><p>假设数组长度为 n，算法步骤如下：</p><ol><li><strong>初始化</strong>：有序区间为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mn>0</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[0,0]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mclose">]</span></span></span></span>，无序区间为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>1</mn><mo separator="true">,</mo><mi>n</mi><mtext>−</mtext><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[1,n−1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">n</span><span class="mord">−</span><span class="mord">1</span><span class="mclose">]</span></span></span></span></li><li><strong>第i趟插入</strong>（i 从 11 到 n−1）：<ul><li>取出无序区间第一个元素 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">nums[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span></span></span></span></li><li>从右到左遍历有序区间，将大于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">nums[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span></span></span></span>的元素右移一位</li><li>找到合适位置后插入 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">nums[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span></span></span></span></li><li>有序区间扩展为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[0,i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">i</span><span class="mclose">]</span></span></span></span>，无序区间变为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo separator="true">,</mo><mi>n</mi><mtext>−</mtext><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[i+1,n−1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">n</span><span class="mord">−</span><span class="mord">1</span><span class="mclose">]</span></span></span></span></li></ul></li></ol><h2 id="内部实现"><a class="markdownIt-Anchor" href="#内部实现"></a> 内部实现：</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">insertionSort</span>(<span class="params">self,nums:[<span class="built_in">int</span>]</span>)-&gt;[<span class="built_in">int</span>]:</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(i,<span class="built_in">len</span>(nums)):</span><br><span class="line">temp=nums[i]</span><br><span class="line">j=i</span><br><span class="line"><span class="keyword">while</span> j&gt;<span class="number">0</span> <span class="keyword">and</span> nums[j-<span class="number">1</span>]&gt;temp:</span><br><span class="line">nums[j]=nums[j-<span class="number">1</span>]</span><br><span class="line">j-=<span class="number">1</span></span><br><span class="line">nums[j]=temp</span><br><span class="line"><span class="keyword">return</span> nums</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sortArray</span>(<span class="params">self,nums:[<span class="built_in">int</span>]</span>)-&gt;[<span class="built_in">int</span>]:</span><br><span class="line"><span class="keyword">return</span> <span class="variable language_">self</span>.insertionSort(nums)</span><br></pre></td></tr></table></figure><h2 id="复杂度分析"><a class="markdownIt-Anchor" href="#复杂度分析"></a> 复杂度分析：</h2><table><thead><tr><th>指标</th><th>复杂度</th><th>说明</th></tr></thead><tbody><tr><td><strong>最佳时间复杂度</strong></td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></td><td>数组已有序，每个元素只需比较一次</td></tr><tr><td><strong>最坏时间复杂度</strong></td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></td><td>数组逆序，每个元素需要比较 i−1i−1 次</td></tr><tr><td><strong>平均时间复杂度</strong></td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></td><td>一般情况下的复杂度</td></tr><tr><td><strong>空间复杂度</strong></td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></td><td>原地排序，只使用常数空间</td></tr><tr><td><strong>稳定性</strong></td><td>稳定</td><td>相等元素相对位置不变</td></tr><tr><td><strong>适用场景</strong>：</td><td></td><td></td></tr></tbody></table><ul><li>数据量较小（n&lt;50）</li><li>数据基本有序</li><li>在线排序（数据逐个到达）<br />插入排序是一种简单直观的排序算法，通过逐步构建有序序列实现排序。</li><li><strong>优点</strong>：实现简单，稳定排序，空间复杂度低，对基本有序数据效率高</li><li><strong>缺点</strong>：时间复杂度高，不适合大规模数据</li></ul><h2 id="应用场景"><a class="markdownIt-Anchor" href="#应用场景"></a> 应用场景：</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="数据结构" scheme="https://id-zy.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>堆</title>
    <link href="https://id-zy.github.io/2026/01/19/%E5%A0%86/"/>
    <id>https://id-zy.github.io/2026/01/19/%E5%A0%86/</id>
    <published>2026-01-19T07:18:08.117Z</published>
    <updated>2026-01-19T06:16:19.707Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="堆"><a class="markdownIt-Anchor" href="#堆"></a> 堆</h1><h2 id="基本概念"><a class="markdownIt-Anchor" href="#基本概念"></a> 基本概念</h2><p><strong>堆（Heap）</strong>：一种特殊的完全二叉树，具有以下性质之一：</p><ul><li><strong>大顶堆（Max Heap）</strong>：任意节点值 ≥ 其子节点值</li><li><strong>小顶堆（Min Heap）</strong>：任意节点值 ≤ 其子节点值</li></ul><h2 id="数据结构的三要素"><a class="markdownIt-Anchor" href="#数据结构的三要素"></a> 数据结构的三要素</h2><ul><li>逻辑结构<ul><li>树形结构</li></ul></li><li>存储结构<ul><li>顺序存储<ul><li>父节点索引：<code>(i - 1) // 2</code></li><li>左子节点：<code>2*i + 1</code></li><li>右子节点：<code>2*i + 2</code></li></ul></li></ul></li><li>数据的运算</li></ul><h3 id="费曼理解"><a class="markdownIt-Anchor" href="#费曼理解"></a> 费曼理解</h3><p>堆就像是一个按优先级排队的队伍，队首总是优先级最高（最大或最小）的元素，你随时可以拿走它，也可以插入新人，队伍会自动调整顺序。</p><h2 id="内部实现"><a class="markdownIt-Anchor" href="#内部实现"></a> 内部实现：</h2><h3 id="python"><a class="markdownIt-Anchor" href="#python"></a> python</h3><h4 id="创建空堆"><a class="markdownIt-Anchor" href="#创建空堆"></a> 创建空堆</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MaxHeap</span>:</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">_int_</span>(<span class="params">self</span>):</span><br><span class="line"><span class="variable language_">self</span>.max_heap=[]</span><br></pre></td></tr></table></figure><h4 id="访问堆顶元素"><a class="markdownIt-Anchor" href="#访问堆顶元素"></a> 访问堆顶元素</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">peek</span>(<span class="params">self</span>)-&gt; <span class="built_in">int</span>:</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> <span class="variable language_">self</span>.max_heap:</span><br><span class="line"><span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"><span class="keyword">return</span> <span class="variable language_">self</span>.max_heap[<span class="number">0</span>]</span><br></pre></td></tr></table></figure><h4 id="向堆种插入元素"><a class="markdownIt-Anchor" href="#向堆种插入元素"></a> 向堆种插入元素</h4><p>向堆中插入元素需要两个步骤：</p><ol><li><strong>添加元素</strong>：将新元素添加到堆的末尾，保持完全二叉树的结构</li><li><strong>上移调整</strong>：从新元素开始向上调整，直到满足堆的性质</li></ol><p><strong>上移调整（Shift Up）过程</strong>：</p><ul><li>将新插入的节点与其父节点比较</li><li>如果新节点值大于父节点值，则交换它们</li><li>重复此过程，直到新节点不再大于其父节点或到达根节点</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">push</span>(<span class="params">self,val:<span class="built_in">int</span></span>):</span><br><span class="line"><span class="variable language_">self</span>.max_heap.append(val)</span><br><span class="line"><span class="variable language_">self</span>.__shift_up(<span class="built_in">len</span>(<span class="variable language_">self</span>.max_heap)-<span class="number">1</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">__shift_up</span>(<span class="params">self,i:<span class="built_in">int</span></span>):</span><br><span class="line"><span class="keyword">while</span> (i - <span class="number">1</span>) // <span class="number">2</span> &gt;= <span class="number">0</span> <span class="keyword">and</span> <span class="variable language_">self</span>.max_heap[i] &gt; <span class="variable language_">self</span>.max_heap[(i - <span class="number">1</span>) // <span class="number">2</span>]: </span><br><span class="line"><span class="variable language_">self</span>.max_heap[i], <span class="variable language_">self</span>.max_heap[(i - <span class="number">1</span>) // <span class="number">2</span>] = <span class="variable language_">self</span>.max_heap[(i - <span class="number">1</span>) // <span class="number">2</span>], <span class="variable language_">self</span>.max_heap[i] </span><br><span class="line">i = (i - <span class="number">1</span>) // <span class="number">2</span></span><br></pre></td></tr></table></figure><h4 id="删除堆顶元素"><a class="markdownIt-Anchor" href="#删除堆顶元素"></a> 删除堆顶元素</h4><p>删除堆顶元素需要三个步骤：</p><ol><li><strong>交换元素</strong>：将堆顶元素与末尾元素交换</li><li><strong>删除元素</strong>：移除末尾元素（原堆顶元素）</li><li><strong>下移调整</strong>：从新的堆顶开始向下调整，直到满足堆的性质</li></ol><p><strong>下移调整（Shift Down）过程</strong>：</p><ul><li>将新的堆顶元素与其较大的子节点比较</li><li>如果堆顶元素小于较大子节点，则交换它们</li><li>重复此过程，直到堆顶元素不再小于其子节点或到达叶子节点</li></ul><p>这个过程称为「下移调整」，因为新的堆顶元素会逐步向堆的下方移动，直到找到合适的位置。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">pop</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> <span class="variable language_">self</span>.max_heap:</span><br><span class="line">        <span class="keyword">raise</span> IndexError(<span class="string">&quot;堆为空&quot;</span>)</span><br><span class="line">    size = <span class="built_in">len</span>(<span class="variable language_">self</span>.max_heap)</span><br><span class="line">    <span class="variable language_">self</span>.max_heap[<span class="number">0</span>], <span class="variable language_">self</span>.max_heap[size - <span class="number">1</span>] = <span class="variable language_">self</span>.max_heap[size - <span class="number">1</span>], <span class="variable language_">self</span>.max_heap[<span class="number">0</span>]</span><br><span class="line">    val = <span class="variable language_">self</span>.max_heap.pop()</span><br><span class="line">    <span class="keyword">if</span> <span class="variable language_">self</span>.max_heap:</span><br><span class="line">        <span class="variable language_">self</span>.__shift_down(<span class="number">0</span>, <span class="built_in">len</span>(<span class="variable language_">self</span>.max_heap))</span><br><span class="line">    <span class="keyword">return</span> val</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">__shift_down</span>(<span class="params">self, i: <span class="built_in">int</span>, n: <span class="built_in">int</span></span>):</span><br><span class="line">    <span class="keyword">while</span> <span class="number">2</span> * i + <span class="number">1</span> &lt; n:</span><br><span class="line">        left, right = <span class="number">2</span> * i + <span class="number">1</span>, <span class="number">2</span> * i + <span class="number">2</span></span><br><span class="line">        larger = left</span><br><span class="line">        <span class="keyword">if</span> right &lt; n <span class="keyword">and</span> <span class="variable language_">self</span>.max_heap[right] &gt; <span class="variable language_">self</span>.max_heap[left]:</span><br><span class="line">            larger = right</span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.max_heap[i] &lt; <span class="variable language_">self</span>.max_heap[larger]:</span><br><span class="line">            <span class="variable language_">self</span>.max_heap[i], <span class="variable language_">self</span>.max_heap[larger] = <span class="variable language_">self</span>.max_heap[larger], <span class="variable language_">self</span>.max_heap[i]</span><br><span class="line">            i = larger</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br></pre></td></tr></table></figure><h2 id="复杂度分析"><a class="markdownIt-Anchor" href="#复杂度分析"></a> 复杂度分析</h2><table><thead><tr><th>操作</th><th>平均时间复杂度</th><th>最坏时间复杂度</th><th>空间复杂度</th></tr></thead><tbody><tr><td>插入元素</td><td>O(log n)</td><td>O(log n)</td><td>O(1)</td></tr><tr><td>删除堆顶元素</td><td>O(log n)</td><td>O(log n)</td><td>O(1)</td></tr><tr><td>构建堆</td><td>O(n)</td><td>O(n)</td><td>O(n)</td></tr><tr><td>获取堆顶元素</td><td>O(1)</td><td>O(1)</td><td>O(1)</td></tr><tr><td>堆排序</td><td>O(n log n)</td><td>O(n log n)</td><td>O(1)</td></tr></tbody></table><h2 id="应用场景"><a class="markdownIt-Anchor" href="#应用场景"></a> 应用场景：</h2><ul><li><a href="%E5%A0%86%E6%8E%92%E5%BA%8F">堆排序</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="数据结构" scheme="https://id-zy.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>堆排序</title>
    <link href="https://id-zy.github.io/2026/01/19/%E5%A0%86%E6%8E%92%E5%BA%8F/"/>
    <id>https://id-zy.github.io/2026/01/19/%E5%A0%86%E6%8E%92%E5%BA%8F/</id>
    <published>2026-01-19T07:18:08.111Z</published>
    <updated>2026-01-19T07:17:44.244Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="堆排序"><a class="markdownIt-Anchor" href="#堆排序"></a> 堆排序</h1><h2 id="基本概念"><a class="markdownIt-Anchor" href="#基本概念"></a> 基本概念</h2><p><strong>堆排序（Heap sort）基本思想</strong>：<br />利用堆的特性，将数组构建成大顶堆，然后重复取出堆顶元素（最大值）并调整堆结构，最终得到有序数组。</p><h2 id="算法步骤"><a class="markdownIt-Anchor" href="#算法步骤"></a> 算法步骤</h2><p>堆排序分为两个主要阶段：</p><p><strong>第一阶段：构建初始大顶堆</strong></p><ol><li><p>将原始数组视为完全二叉树</p></li><li><p>从最后一个非叶子节点开始，自底向上进行下移调整</p></li><li><p>将数组转换为大顶堆<br /><strong>第二阶段：重复提取最大值</strong></p></li><li><p>交换堆顶元素与当前末尾元素</p></li><li><p>堆长度减 1，末尾元素已排好序</p></li><li><p>对新的堆顶元素进行下移调整，恢复堆的性质</p></li><li><p>重复步骤 1∼3，直到堆的大小为 1</p></li></ol><h2 id="内部实现"><a class="markdownIt-Anchor" href="#内部实现"></a> 内部实现：</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MaxHeap</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.max_heap = []</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__buildMaxHeap</span>(<span class="params">self, nums: [<span class="built_in">int</span>]</span>):</span><br><span class="line">        <span class="comment"># 将数组元素复制到堆中</span></span><br><span class="line">        <span class="variable language_">self</span>.max_heap = nums.copy()</span><br><span class="line">        size = <span class="built_in">len</span>(nums)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 从最后一个非叶子节点开始，自底向上构建堆</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>((size - <span class="number">2</span>) // <span class="number">2</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            <span class="variable language_">self</span>.__shift_down(i, size)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxHeapSort</span>(<span class="params">self, nums: [<span class="built_in">int</span>]</span>) -&gt; [<span class="built_in">int</span>]:</span><br><span class="line">        <span class="comment"># 第一阶段：构建初始大顶堆</span></span><br><span class="line">        <span class="variable language_">self</span>.__buildMaxHeap(nums)</span><br><span class="line">        </span><br><span class="line">        size = <span class="built_in">len</span>(<span class="variable language_">self</span>.max_heap)</span><br><span class="line">        <span class="comment"># 第二阶段：重复提取最大值</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(size - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            <span class="comment"># 交换堆顶元素与当前末尾元素</span></span><br><span class="line">            <span class="variable language_">self</span>.max_heap[<span class="number">0</span>], <span class="variable language_">self</span>.max_heap[i] = <span class="variable language_">self</span>.max_heap[i], <span class="variable language_">self</span>.max_heap[<span class="number">0</span>]</span><br><span class="line">            <span class="comment"># 对新的堆顶元素进行下移调整，堆的大小为 i</span></span><br><span class="line">            <span class="variable language_">self</span>.__shift_down(<span class="number">0</span>, i)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 返回排序后的数组</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.max_heap</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__shift_down</span>(<span class="params">self, i: <span class="built_in">int</span>, n: <span class="built_in">int</span></span>):</span><br><span class="line">        <span class="comment"># 下移调整：将节点与其较大的子节点比较并交换</span></span><br><span class="line">        <span class="keyword">while</span> <span class="number">2</span> * i + <span class="number">1</span> &lt; n:</span><br><span class="line">            left, right = <span class="number">2</span> * i + <span class="number">1</span>, <span class="number">2</span> * i + <span class="number">2</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 找出较大的子节点</span></span><br><span class="line">            larger = left</span><br><span class="line">            <span class="keyword">if</span> right &lt; n <span class="keyword">and</span> <span class="variable language_">self</span>.max_heap[right] &gt; <span class="variable language_">self</span>.max_heap[left]:</span><br><span class="line">                larger = right</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 如果当前节点小于较大子节点，则交换</span></span><br><span class="line">            <span class="keyword">if</span> <span class="variable language_">self</span>.max_heap[i] &lt; <span class="variable language_">self</span>.max_heap[larger]:</span><br><span class="line">                <span class="variable language_">self</span>.max_heap[i], <span class="variable language_">self</span>.max_heap[larger] = <span class="variable language_">self</span>.max_heap[larger], <span class="variable language_">self</span>.max_heap[i]</span><br><span class="line">                i = larger</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sortArray</span>(<span class="params">self, nums: [<span class="built_in">int</span>]</span>) -&gt; [<span class="built_in">int</span>]:</span><br><span class="line">        <span class="keyword">return</span> MaxHeap().maxHeapSort(nums)</span><br></pre></td></tr></table></figure><h2 id="复杂度分析"><a class="markdownIt-Anchor" href="#复杂度分析"></a> 复杂度分析：</h2><table><thead><tr><th>指标</th><th>复杂度</th><th>说明</th></tr></thead><tbody><tr><td><strong>最佳时间复杂度</strong></td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mtext>⁡</mtext><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(nlog⁡n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord">⁡</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></td><td>无论数组状态如何，都需要构建堆和提取元素</td></tr><tr><td><strong>最坏时间复杂度</strong></td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mtext>⁡</mtext><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(nlog⁡n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord">⁡</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></td><td>无论数组状态如何，都需要构建堆和提取元素</td></tr><tr><td><strong>平均时间复杂度</strong></td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mtext>⁡</mtext><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(nlog⁡n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord">⁡</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></td><td>堆排序的时间复杂度与数据状态无关</td></tr><tr><td><strong>空间复杂度</strong></td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></td><td>原地排序，只使用常数空间</td></tr><tr><td><strong>稳定性</strong></td><td>不稳定</td><td>调整堆的过程中可能改变相等元素的相对顺序</td></tr><tr><td><strong>适用场景</strong>：</td><td></td><td></td></tr></tbody></table><ul><li>大规模数据排序</li><li>内存受限的环境</li><li>需要稳定时间复杂度的场景</li><li>需要保证最坏情况下性能的场景<br />堆排序是一种基于堆数据结构的排序算法，利用堆的特性实现高效排序。<br /><strong>核心思想</strong>：</li><li>将数组构建成大顶堆，堆顶元素始终是最大值</li><li>重复取出堆顶元素并调整堆结构，最终得到有序数组<br /><strong>算法步骤</strong>：</li></ul><ol><li><strong>构建初始堆</strong>：将数组转换为大顶堆</li><li><strong>重复提取</strong>：交换堆顶与末尾元素，调整堆结构，逐步得到有序数组</li></ol><ul><li><strong>优点</strong>：<ul><li>时间复杂度稳定，始终为 O(nlog⁡n)</li><li>空间复杂度低，为 O(1)</li><li>适合处理大规模数据</li><li>原地排序，不需要额外空间</li></ul></li><li><strong>缺点</strong>：<ul><li>不稳定排序</li><li>常数因子较大，实际应用中可能比快速排序稍慢</li><li>对缓存不友好，访问模式不够局部化</li></ul></li></ul><p>堆排序是一种同时具备 O(nlog⁡n)时间复杂度和 O(1) 空间复杂度的比较排序算法，在内存受限或需要稳定时间复杂度的场景下具有重要价值</p><h2 id="应用场景"><a class="markdownIt-Anchor" href="#应用场景"></a> 应用场景：</h2><ul><li>245<a href="%E6%95%B0%E7%BB%84%E7%A7%8D%E7%9A%84%E7%AC%ACk%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0">数组种的第k个最大元素</a></li><li>LCR159<a href="%E5%BA%93%E5%AD%98%E7%AE%A1%E7%90%86III.md">库存管理III</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="数据结构" scheme="https://id-zy.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>冒泡排序</title>
    <link href="https://id-zy.github.io/2026/01/19/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/"/>
    <id>https://id-zy.github.io/2026/01/19/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/</id>
    <published>2026-01-19T07:18:08.080Z</published>
    <updated>2026-01-19T03:41:31.284Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="冒泡排序"><a class="markdownIt-Anchor" href="#冒泡排序"></a> 冒泡排序</h1><h2 id="基本概念"><a class="markdownIt-Anchor" href="#基本概念"></a> 基本概念</h2><p><strong>冒泡排序（Bubble Sort）基本思想</strong>：<br />通过相邻元素的比较与交换，将较大的元素逐步「冒泡」到数组末尾，较小的元素自然「下沉」到数组开头。</p><h2 id="算法步骤"><a class="markdownIt-Anchor" href="#算法步骤"></a> 算法步骤</h2><p>对于长度为 n 的数组，冒泡排序的步骤如下：</p><ol><li>第1趟冒泡：对前n个元素依次比较相邻元素，将较大的元素向右交换，最终使最大值移动到数组末尾（第n个位置）。<ol><li>比较第1个和第2个元素，如果前者大于后者则交换。</li><li>比较第 2 个和第 3 个元素，如果前者大于后者则交换。</li><li>以此类推，直到比较第 n−1 个和第 n 个元素。</li><li>完成后，最大元素已位于末尾。</li></ol></li><li>第 2 趟冒泡：对前 n−1 个元素重复上述过程，将次大值移动到倒数第二个位置（第 n−1 个位置）。<ol><li>比较第1个和第 2 个元素，如果前者大于后者则交换。</li><li>比较第 2 个和第 3 个元素，如果前者大于后者则交换。</li><li>以此类推，直到比较第 n−2 个和第 n−1 个元素。</li><li>完成后，次大元素已位于倒数第二位。</li></ol></li><li>持续进行上述冒泡过程，每一趟比较的元素个数递减，直到某一趟未发生任何交换，说明数组已完全有序，排序结束。</li></ol><h2 id="内部实现"><a class="markdownIt-Anchor" href="#内部实现"></a> 内部实现：</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bubbleSort</span>(<span class="params">self,nums:[<span class="built_in">int</span>]</span>)-&gt;<span class="built_in">int</span>:</span><br><span class="line">n=<span class="built_in">len</span>(nums)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n-<span class="number">1</span>):</span><br><span class="line">swapped=<span class="literal">False</span></span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n-<span class="number">1</span>):</span><br><span class="line"><span class="keyword">if</span> nums[j]&gt;nums[j+<span class="number">1</span>]:</span><br><span class="line">nums[j],nums[j+<span class="number">1</span>]=hums[j+<span class="number">1</span>],nums[j]</span><br><span class="line">swapped=<span class="literal">True</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> swapped:</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line"><span class="keyword">return</span> nums</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sortArray</span>(<span class="params">self,nums:[<span class="built_in">int</span>]</span>)-&gt;[<span class="built_in">int</span>]:</span><br><span class="line"><span class="keyword">return</span> <span class="variable language_">self</span>.bubbleSort(nums)</span><br></pre></td></tr></table></figure><h2 id="复杂度分析"><a class="markdownIt-Anchor" href="#复杂度分析"></a> 复杂度分析：</h2><table><thead><tr><th>指标</th><th>复杂度</th><th>说明</th></tr></thead><tbody><tr><td><strong>最佳时间复杂度</strong></td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></td><td>数组已有序，只需一趟遍历</td></tr><tr><td><strong>最坏时间复杂度</strong></td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></td><td>数组逆序，需要 nn 趟遍历</td></tr><tr><td><strong>平均时间复杂度</strong></td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></td><td>一般情况下的复杂度</td></tr><tr><td><strong>空间复杂度</strong></td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></td><td>原地排序，只使用常数空间</td></tr><tr><td><strong>稳定性</strong></td><td>稳定</td><td>相等元素相对位置不变</td></tr></tbody></table><ul><li>数据量较小（n&lt;50）</li><li>数据基本有序<br />冒泡排序是最简单的排序算法之一，通过相邻元素比较交换实现排序。虽然实现简单，但效率较低。</li><li><strong>优点</strong>：实现简单，稳定排序，空间复杂度低。</li><li><strong>缺点</strong>：时间复杂度高，交换次数多。</li></ul><h2 id="应用场景"><a class="markdownIt-Anchor" href="#应用场景"></a> 应用场景：</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="数据结构" scheme="https://id-zy.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>库存管理III-LeetCode</title>
    <link href="https://id-zy.github.io/2026/01/19/%E5%BA%93%E5%AD%98%E7%AE%A1%E7%90%86III/"/>
    <id>https://id-zy.github.io/2026/01/19/%E5%BA%93%E5%AD%98%E7%AE%A1%E7%90%86III/</id>
    <published>2026-01-18T16:00:00.000Z</published>
    <updated>2026-01-19T07:11:07.670Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="库存管理iii"><a class="markdownIt-Anchor" href="#库存管理iii"></a> 库存管理III</h1><h2 id="问题描述来源于leetcode"><a class="markdownIt-Anchor" href="#问题描述来源于leetcode"></a> 🎯 问题描述（来源于LeetCode）</h2><p><strong>描述</strong>：<br />仓库管理员以数组 <code>stock</code> 形式记录商品库存表，其中 <code>stock[i]</code> 表示对应商品库存余量。请返回库存余量最少的 <code>cnt</code> 个商品余量，返回 <strong>顺序不限</strong>。<br /><strong>说明</strong>：</p><ul><li><code>0 &lt;= cnt &lt;= stock.length &lt;= 10000</code></li><li><code>0 &lt;= stock[i] &lt;= 10000</code></li></ul><p><strong>示例</strong>：</p><ul><li>示例 1：</li></ul><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：stock = [2,5,7,4], cnt = 1</span><br><span class="line">输出：[2]</span><br></pre></td></tr></table></figure><ul><li>示例 2：</li></ul><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：stock = [0,2,3,6], cnt = 2</span><br><span class="line">输出：[0,2] 或 [2,0]</span><br></pre></td></tr></table></figure><h2 id="解题思路"><a class="markdownIt-Anchor" href="#解题思路"></a> 💻 解题思路</h2><h3 id="思路1最小堆排序"><a class="markdownIt-Anchor" href="#思路1最小堆排序"></a> 思路1：最小堆排序</h3><h4 id="思路1代码实现"><a class="markdownIt-Anchor" href="#思路1代码实现"></a> 思路1：代码实现</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxHeap</span>(<span class="params">self,nums:[<span class="built_in">int</span>],i:<span class="built_in">int</span>,heap_size:<span class="built_in">int</span></span>):</span><br><span class="line">        <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">            l_i=<span class="number">2</span>*i+<span class="number">1</span></span><br><span class="line">            r_i=<span class="number">2</span>*i+<span class="number">2</span></span><br><span class="line">            lst=i</span><br><span class="line">            <span class="keyword">if</span> l_i&lt;heap_size <span class="keyword">and</span> nums[l_i]&lt;nums[lst]:</span><br><span class="line">                lst=l_i</span><br><span class="line">            <span class="keyword">if</span> r_i&lt;heap_size <span class="keyword">and</span> nums[r_i]&lt;nums[lst]:</span><br><span class="line">                lst=r_i</span><br><span class="line">            <span class="keyword">if</span> lst==i:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            nums[i],nums[lst]=nums[lst],nums[i]</span><br><span class="line">            i=lst</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">buildmaxHeap</span>(<span class="params">self,nums:[<span class="built_in">int</span>],heap_size:<span class="built_in">int</span></span>)-&gt;<span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span> (heap_size//<span class="number">2</span>-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>):</span><br><span class="line">            <span class="variable language_">self</span>.maxHeap(nums,i,heap_size)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inventoryManagement</span>(<span class="params">self, stock: <span class="type">List</span>[<span class="built_in">int</span>], cnt: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="keyword">if</span> cnt == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        n = <span class="built_in">len</span>(stock)</span><br><span class="line">        heap_size = <span class="built_in">min</span>(cnt, n)</span><br><span class="line">        <span class="variable language_">self</span>.buildmaxHeap(stock, n)</span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">import</span> copy</span><br><span class="line">        temp = copy.deepcopy(stock)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">min</span>(cnt, n)):</span><br><span class="line">            temp[<span class="number">0</span>], temp[n - i - <span class="number">1</span>] = temp[n - i - <span class="number">1</span>], temp[<span class="number">0</span>]</span><br><span class="line">            result.append(temp[n - i - <span class="number">1</span>])</span><br><span class="line">            <span class="variable language_">self</span>.maxHeap(temp, <span class="number">0</span>, n - i - <span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><h4 id="思路1-性能分析"><a class="markdownIt-Anchor" href="#思路1-性能分析"></a> 思路1：📊 性能分析</h4><h5 id="提交结果"><a class="markdownIt-Anchor" href="#提交结果"></a> 提交结果</h5><ul><li><strong>运行时间</strong>：103ms击败18.65%</li><li><strong>内存消耗</strong>：20.32MB击败21.89%</li></ul><h5 id="复杂度验证"><a class="markdownIt-Anchor" href="#复杂度验证"></a> 复杂度验证</h5><ul><li>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(Nlogn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></li><li>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></li></ul><h4 id="思考"><a class="markdownIt-Anchor" href="#思考"></a> 思考</h4>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="作业练习" scheme="https://id-zy.github.io/categories/%E4%BD%9C%E4%B8%9A%E7%BB%83%E4%B9%A0/"/>
    
    
    <category term="LeetCode" scheme="https://id-zy.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>数组种的第k个最大元素-LeetCode</title>
    <link href="https://id-zy.github.io/2026/01/19/%E6%95%B0%E7%BB%84%E7%A7%8D%E7%9A%84%E7%AC%ACk%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0/"/>
    <id>https://id-zy.github.io/2026/01/19/%E6%95%B0%E7%BB%84%E7%A7%8D%E7%9A%84%E7%AC%ACk%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0/</id>
    <published>2026-01-18T16:00:00.000Z</published>
    <updated>2026-01-19T06:56:36.304Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="数组种的第k个最大元素"><a class="markdownIt-Anchor" href="#数组种的第k个最大元素"></a> 数组种的第k个最大元素</h1><h2 id="问题描述来源于leetcode"><a class="markdownIt-Anchor" href="#问题描述来源于leetcode"></a> 🎯 问题描述（来源于LeetCode）</h2><p><strong>描述</strong>：<br />给定整数数组 <code>nums</code> 和整数 <code>k</code>，请返回数组中第 <strong>k</strong>个最大的元素。</p><p>请注意，你需要找的是数组排序后的第 <code>k</code> 个最大的元素，而不是第 <code>k</code> 个不同的元素。</p><p>你必须设计并实现时间复杂度为 <code>O(n)</code> 的算法解决此问题。<br /><strong>说明</strong>：</p><ul><li><code>1 &lt;= k &lt;= nums.length &lt;= 105</code></li><li><code>-104 &lt;= nums[i] &lt;= 104</code></li></ul><p><strong>示例</strong>：</p><ul><li>示例 1：</li></ul><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [3,2,1,5,6,4], k = 2</span><br><span class="line">输出: 5</span><br></pre></td></tr></table></figure><ul><li>示例 2：</li></ul><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入:[3,2,3,1,2,4,5,5,6],k = 4</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure><h2 id="解题思路"><a class="markdownIt-Anchor" href="#解题思路"></a> 💻 解题思路</h2><h3 id="思路1堆排序"><a class="markdownIt-Anchor" href="#思路1堆排序"></a> 思路1：堆排序</h3><h4 id="思路1代码实现"><a class="markdownIt-Anchor" href="#思路1代码实现"></a> 思路1：代码实现</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxHeap</span>(<span class="params">self,nums:[<span class="built_in">int</span>],i:<span class="built_in">int</span>,heap_size:<span class="built_in">int</span></span>):</span><br><span class="line">        <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">            l_i=<span class="number">2</span>*i+<span class="number">1</span></span><br><span class="line">            r_i=<span class="number">2</span>*i+<span class="number">2</span></span><br><span class="line">            lst=i</span><br><span class="line">            <span class="keyword">if</span> l_i&lt;heap_size <span class="keyword">and</span> nums[l_i]&gt;nums[lst]:</span><br><span class="line">                lst=l_i</span><br><span class="line">            <span class="keyword">if</span> r_i&lt;heap_size <span class="keyword">and</span> nums[r_i]&gt;nums[lst]:</span><br><span class="line">                lst=r_i</span><br><span class="line">            <span class="keyword">if</span> lst==i:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            nums[i],nums[lst]=nums[lst],nums[i]</span><br><span class="line">            i=lst</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">buildmaxHeap</span>(<span class="params">self,nums:[<span class="built_in">int</span>],heap_size:<span class="built_in">int</span></span>)-&gt;<span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span> (heap_size//<span class="number">2</span>-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>):</span><br><span class="line">            <span class="variable language_">self</span>.maxHeap(nums,i,heap_size)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findKthLargest</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n=<span class="built_in">len</span>(nums)</span><br><span class="line">        heap_size=n</span><br><span class="line">        <span class="variable language_">self</span>.buildmaxHeap(nums,heap_size)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,k):</span><br><span class="line">            nums[<span class="number">0</span>],nums[n-i]=nums[n-i],nums[<span class="number">0</span>]</span><br><span class="line">            heap_size-=<span class="number">1</span></span><br><span class="line">            <span class="variable language_">self</span>.maxHeap(nums,<span class="number">0</span>,heap_size)</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br></pre></td></tr></table></figure><h4 id="思路1-性能分析"><a class="markdownIt-Anchor" href="#思路1-性能分析"></a> 思路1：📊 性能分析</h4><h5 id="提交结果"><a class="markdownIt-Anchor" href="#提交结果"></a> 提交结果</h5><ul><li><strong>运行时间</strong>：423ms击败10.94%</li><li><strong>内存消耗</strong>：30.50MB击败17.30%</li></ul><h5 id="复杂度验证"><a class="markdownIt-Anchor" href="#复杂度验证"></a> 复杂度验证</h5><ul><li>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(Nlogn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></li><li>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></li></ul><h4 id="思考"><a class="markdownIt-Anchor" href="#思考"></a> 思考</h4>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="作业练习" scheme="https://id-zy.github.io/categories/%E4%BD%9C%E4%B8%9A%E7%BB%83%E4%B9%A0/"/>
    
    
    <category term="LeetCode" scheme="https://id-zy.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>链栈</title>
    <link href="https://id-zy.github.io/2025/12/17/%E9%93%BE%E6%A0%88/"/>
    <id>https://id-zy.github.io/2025/12/17/%E9%93%BE%E6%A0%88/</id>
    <published>2025-12-17T15:20:58.091Z</published>
    <updated>2025-12-05T12:40:12.107Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="链栈"><a class="markdownIt-Anchor" href="#链栈"></a> 链栈</h1><h2 id="基本概念"><a class="markdownIt-Anchor" href="#基本概念"></a> 基本概念</h2><h2 id="数据结构的三要素"><a class="markdownIt-Anchor" href="#数据结构的三要素"></a> 数据结构的三要素</h2><ul><li>逻辑结构<ul><li>线性结构</li></ul></li><li>存储结构<ul><li>链式存储</li></ul></li><li>数据的运算</li></ul><h3 id="费曼理解"><a class="markdownIt-Anchor" href="#费曼理解"></a> 费曼理解</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">栈结构：</span><br><span class="line">头指针L → [栈顶节点] → [节点2] → ... → [栈底节点] → NULL</span><br></pre></td></tr></table></figure><p>就像编绳结一样，一个节点一个结从右往左遍就得从左往右解</p><h2 id="内部实现"><a class="markdownIt-Anchor" href="#内部实现"></a> 内部实现：</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Linknode</span>&#123;</span></span><br><span class="line">ElemType data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Linknode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;*LiStack</span><br></pre></td></tr></table></figure><h2 id="复杂度分析"><a class="markdownIt-Anchor" href="#复杂度分析"></a> 复杂度分析：</h2><h3 id="初始化"><a class="markdownIt-Anchor" href="#初始化"></a> 初始化</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">InitStack</span><span class="params">(LiStack &amp;L)</span>&#123;</span><br><span class="line">L= new Linknode;</span><br><span class="line">L-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="判断栈空"><a class="markdownIt-Anchor" href="#判断栈空"></a> 判断栈空</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">isEmpty</span><span class="params">(LiStack &amp;L)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(L-next==<span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="入栈"><a class="markdownIt-Anchor" href="#入栈"></a> 入栈</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Push</span><span class="params">(LiStack &amp;L,ElemType e)</span>&#123;</span><br><span class="line">Linknode s;</span><br><span class="line">s =new Linknode;</span><br><span class="line">s-&gt;data=e;</span><br><span class="line">s-next=L-&gt;next;</span><br><span class="line">L-&gt;next=s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="复杂度分析-2"><a class="markdownIt-Anchor" href="#复杂度分析-2"></a> 复杂度分析</h4><ul><li>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></li><li>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></li></ul><h3 id="出栈"><a class="markdownIt-Anchor" href="#出栈"></a> 出栈</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">Pop</span><span class="params">(LiStack &amp;L,ElemType &amp;e)</span>&#123;</span><br><span class="line">Linknode s;</span><br><span class="line"><span class="keyword">if</span> <span class="title function_">isEmpty</span><span class="params">(L)</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">s=L-&gt;next;</span><br><span class="line">e=s-&gt;data;</span><br><span class="line">L-&gt;next=L-&gt;next-&gt;next;</span><br><span class="line">delete(s);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="复杂度分析-3"><a class="markdownIt-Anchor" href="#复杂度分析-3"></a> 复杂度分析</h4><ul><li>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></li><li>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></li></ul><h2 id="应用场景"><a class="markdownIt-Anchor" href="#应用场景"></a> 应用场景：</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="数据结构" scheme="https://id-zy.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>快速排序</title>
    <link href="https://id-zy.github.io/2025/12/17/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
    <id>https://id-zy.github.io/2025/12/17/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</id>
    <published>2025-12-17T15:20:20.675Z</published>
    <updated>2025-12-17T01:47:27.074Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="快速排序"><a class="markdownIt-Anchor" href="#快速排序"></a> 快速排序</h1><h2 id="基本概念"><a class="markdownIt-Anchor" href="#基本概念"></a> 基本概念</h2><p><strong>快速排序（Quick Sort）基本思想</strong>：<br />采用分治策略，选择一个基准元素，将数组分为两部分：小于基准的元素放在左侧，大于基准的元素放在右侧。然后递归地对左右两部分进行排序，最终得到有序数组。</p><h2 id="算法步骤"><a class="markdownIt-Anchor" href="#算法步骤"></a> 算法步骤</h2><p>快速排序的核心是 <strong>分区操作</strong>，具体步骤如下：</p><ol><li><strong>选择基准</strong>：从数组中选择一个元素作为基准值（通常选择第一个元素）</li><li><strong>分区操作</strong>：<ul><li>使用双指针法，左指针从数组开始，右指针从数组末尾</li><li>右指针向左移动，找到第一个小于基准值的元素</li><li>左指针向右移动，找到第一个大于基准值的元素</li><li>交换这两个元素</li><li>重复上述过程，直到左右指针相遇</li><li>将基准值放到正确位置（左右指针相遇处）</li></ul></li><li><strong>递归排序</strong>：对基准值左右的两个子数组分别进行快速排序</li></ol><h2 id="内部实现"><a class="markdownIt-Anchor" href="#内部实现"></a> 内部实现：</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">randomPartition</span>(<span class="params">self,nums:[<span class="built_in">int</span>],low:<span class="built_in">int</span>,high:<span class="built_in">int</span></span>)-&gt;<span class="built_in">int</span>:</span><br><span class="line">i=random.randint(low,high)</span><br><span class="line">nums[low],nums[i]=nums[i],nums[low]</span><br><span class="line"><span class="keyword">return</span> <span class="variable language_">self</span>.partition(nums,low,high)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">partition</span>(<span class="params">self,nums:[<span class="built_in">int</span>],low:<span class="built_in">int</span>,high,<span class="built_in">int</span></span>)-&gt;<span class="built_in">int</span>:</span><br><span class="line">pivot=nums[low]</span><br><span class="line">i,j=low,high</span><br><span class="line"><span class="keyword">while</span> i&lt;j:</span><br><span class="line"><span class="keyword">while</span> i&lt;j <span class="keyword">and</span> nums[j]&gt;=pivot:</span><br><span class="line">j-=<span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> i&lt;j <span class="keyword">and</span> nums[i]&lt;=pivot:</span><br><span class="line">i+=<span class="number">1</span></span><br><span class="line">nums[i],nums[j]=nums[j],nums[i]</span><br><span class="line">nums[i],nums[low]=nums[low],nums[i]</span><br><span class="line"><span class="keyword">return</span> i</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">quicksort</span>(<span class="params">self,nums:[<span class="built_in">int</span>],low:<span class="built_in">int</span>,high:<span class="built_in">int</span></span>)-&gt;[<span class="built_in">int</span>]:</span><br><span class="line"><span class="keyword">if</span> low&lt;high:</span><br><span class="line">pivot_i=<span class="variable language_">self</span>.randomPartition(nums,low,high)</span><br><span class="line"><span class="variable language_">self</span>.quicksort(nums,low,pivot_i-<span class="number">1</span>)</span><br><span class="line"><span class="variable language_">self</span>.quicksort(nums,pivot_i+<span class="number">1</span>,high)</span><br><span class="line"><span class="keyword">return</span> nums</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sortArray</span>(<span class="params">self,nums:[<span class="built_in">int</span>]</span>)-&gt;[<span class="built_in">int</span>]:</span><br><span class="line"><span class="keyword">return</span> <span class="variable language_">self</span>.quicksort(nums,<span class="number">0</span>,<span class="built_in">len</span>(nums)-<span class="number">1</span>)</span><br></pre></td></tr></table></figure><h2 id="复杂度分析"><a class="markdownIt-Anchor" href="#复杂度分析"></a> 复杂度分析：</h2><table><thead><tr><th>指标</th><th>复杂度</th><th>说明</th></tr></thead><tbody><tr><td><strong>最佳时间复杂度</strong></td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mtext>⁡</mtext><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(nlog⁡n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord">⁡</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></td><td>每次都能将数组平均分成两半</td></tr><tr><td><strong>最坏时间复杂度</strong></td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></td><td>每次选择的基准值都是极值（如已排序数组）</td></tr><tr><td><strong>平均时间复杂度</strong></td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mtext>⁡</mtext><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(nlog⁡n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord">⁡</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></td><td>随机选择基准值时的期望复杂度</td></tr><tr><td><strong>空间复杂度</strong></td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mtext>⁡</mtext><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(log⁡n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord">⁡</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></td><td>递归栈空间，最坏情况下为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></td></tr><tr><td><strong>稳定性</strong></td><td>不稳定</td><td>交换操作可能改变相等元素的相对位置</td></tr></tbody></table><p><strong>适用场景</strong>：</p><ul><li>大规模数据排序（n≥1000）</li><li>对平均性能要求高的场景</li><li>数据分布相对均匀的情况</li></ul><p><strong>优化策略</strong>：</p><ul><li><p>随机选择基准值，避免最坏情况</p></li><li><p>三数取中法选择基准值</p></li><li><p>小数组使用插入排序</p></li><li><p>处理重复元素时使用三路快排<br />快速排序是一种高效的排序算法，采用分治策略，通过分区操作将数组分成两部分，然后递归排序。</p></li><li><p><strong>优点</strong>：</p><ul><li>平均情况下效率高，时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mtext>⁡</mtext><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(nlog⁡n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord">⁡</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></li><li>原地排序，空间复杂度低</li><li>缓存友好，局部性良好</li><li>实际应用中常数因子较小</li></ul></li><li><p><strong>缺点</strong>：</p><ul><li>不稳定排序</li><li>最坏情况下性能较差，时间复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></li><li>对于小数组，其他算法可能更快</li><li>递归调用可能导致栈溢出</li></ul></li></ul><p>快速排序是许多编程语言内置排序函数的实现基础，在实际应用中非常广泛。通过合理的优化策略，可以显著提高其性能和稳定性。</p><h2 id="应用场景"><a class="markdownIt-Anchor" href="#应用场景"></a> 应用场景：</h2><ul><li>912<a href="%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84.md">排序数组</a><ul><li>问题描述：给你一个整数数组 <code>nums</code>，请你将该数组升序排列。</li><li>解决方案：快速排序即可</li></ul></li><li>169<a href="%E5%A4%9A%E6%95%B0%E5%85%83%E7%B4%A0.md">多数元素</a><ul><li>问题描述：寻找多数元素</li><li>解决方案：多数元素总是出现在已排序数组中间</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="数据结构" scheme="https://id-zy.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>归并排序</title>
    <link href="https://id-zy.github.io/2025/12/17/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
    <id>https://id-zy.github.io/2025/12/17/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</id>
    <published>2025-12-17T15:20:20.673Z</published>
    <updated>2025-12-16T12:22:37.225Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="归并排序"><a class="markdownIt-Anchor" href="#归并排序"></a> 归并排序</h1><h2 id="基本概念"><a class="markdownIt-Anchor" href="#基本概念"></a> 基本概念</h2><p><strong>归并排序（Merge Sort）基本思想</strong>：<br />利用分治法，将数组递归地一分为二，直至每个子数组只包含一个元素。随后，将这些有序子数组两两合并，最终得到一个整体有序的数组。</p><h2 id="算法步骤"><a class="markdownIt-Anchor" href="#算法步骤"></a> 算法步骤</h2><p>假设数组的元素个数为 n 个，则归并排序的算法步骤如下：</p><ol><li><strong>分解过程</strong>：递归地将当前数组平分为两部分，直到每个子数组只包含一个元素为止。<ol><li>找到数组的中间位置 mid，将数组划分为左、右两个子数组left_nums 和 right_nums。</li><li>分别对 left_nums 和 right_numsr递归执行分解操作。</li><li>最终将原数组拆分为 n 个长度为 1 的有序子数组。</li></ol></li><li><strong>归并过程</strong>：从长度为 1 的有序子数组开始，逐步将相邻的有序子数组两两合并，最终合并为一个长度为 n 的有序数组。<ol><li>新建数组 nums 用于存放合并后的有序结果。</li><li>设置两个指针 left_i 和 right_i，分别指向 left_nums 和 right_nums的起始位置。</li><li>比较两个指针所指元素，将较小者加入结果数组 numsnums，并将对应指针后移一位。</li><li>重复上述操作，直到某一指针到达对应子数组末尾。</li><li>将另一个子数组剩余的所有元素依次加入结果数组 nums。</li><li>返回合并后的有序数组 nums。</li></ol></li></ol><h2 id="内部实现"><a class="markdownIt-Anchor" href="#内部实现"></a> 内部实现：</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">solution</span>:</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">merge</span>(<span class="params">self,left_nums:[<span class="built_in">int</span>],right_nums:[<span class="built_in">int</span>]</span>):</span><br><span class="line">nums=[]</span><br><span class="line">left_i,right_i=<span class="number">0</span>,<span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> left_i &lt; <span class="built_in">len</span>(left_nums)<span class="keyword">and</span> right_i&lt;<span class="built_in">len</span>(right_nums):</span><br><span class="line"><span class="keyword">if</span> left_nums[left_i]&lt;=right_nums[right_i]:</span><br><span class="line">nums.append(left_nums[left_i])</span><br><span class="line">left_i+=<span class="number">1</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">nums.append(right_nums[right_i])</span><br><span class="line">right_i+=<span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> left_i &lt;<span class="built_in">len</span>(left_nums):</span><br><span class="line">nums.append(left_nums[left_i])</span><br><span class="line">left_i+=<span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> right_i &lt;<span class="built_in">len</span>(right_nums):</span><br><span class="line">nums.append(right_nums[right_i])</span><br><span class="line">right_i+=<span class="number">1</span></span><br><span class="line"><span class="keyword">return</span> nums</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">mergesort</span>(<span class="params">self,nums:[<span class="built_in">int</span>]</span>)-&gt;[<span class="built_in">int</span>]:</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(nums)&lt;=<span class="number">1</span>:</span><br><span class="line"><span class="keyword">return</span> nums</span><br><span class="line">mid = <span class="built_in">len</span>(nums)//<span class="number">2</span></span><br><span class="line">left_nums=<span class="variable language_">self</span>.mergesort(nums[<span class="number">0</span>:mid])</span><br><span class="line">right_nums=<span class="variable language_">self</span>.mergesort(nums[mid:])</span><br><span class="line"><span class="keyword">return</span> <span class="variable language_">self</span>.merge(left_nums,right_nums)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sortrray</span>(<span class="params">self,nums:[<span class="built_in">int</span>]</span>)-&gt;[<span class="built_in">int</span>]:</span><br><span class="line"><span class="keyword">return</span> <span class="variable language_">self</span>.mergesort(nums)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="复杂度分析"><a class="markdownIt-Anchor" href="#复杂度分析"></a> 复杂度分析：</h2><table><thead><tr><th>指标</th><th>复杂度</th><th>说明</th></tr></thead><tbody><tr><td><strong>最佳时间复杂度</strong></td><td>O(nlog⁡n)</td><td>无论数组状态如何，都需要 log⁡n 次分解和 n 次合并</td></tr><tr><td><strong>最坏时间复杂度</strong></td><td>O(nlog⁡n)</td><td>无论数组状态如何，都需要 log⁡n次分解和 n 次合并</td></tr><tr><td><strong>平均时间复杂度</strong></td><td>O(nlog⁡n)</td><td>归并排序的时间复杂度与数据状态无关</td></tr><tr><td><strong>空间复杂度</strong></td><td>O(n)</td><td>需要额外的辅助数组来存储合并结果</td></tr><tr><td><strong>稳定性</strong></td><td>稳定</td><td>合并过程中相等元素的相对顺序保持不变</td></tr><tr><td><strong>补充说明：</strong></td><td></td><td></td></tr></tbody></table><ul><li>归并排序采用分治策略，将数组递归地分成两半，每次分解的时间复杂度为 O(1)，分解次数为logn。</li><li>合并过程的时间复杂度为 O(n)，因为需要遍历两个子数组的所有元素。</li><li>总的时间复杂度为 O(nlogn)，这是基于比较的排序算法的理论下界。</li></ul><p><strong>适用场景：</strong></p><ul><li>大规模数据排序（n&gt;1000）</li><li>对稳定性有要求的场景</li><li>外部排序（数据无法全部加载到内存）</li><li>链表排序<br />归并排序是一种高效稳定的排序算法，采用分治策略将数组递归分解后合并排序。</li><li><strong>优点</strong>：<ul><li>时间复杂度稳定，始终为 O(nlogn)</li><li>稳定排序，相等元素相对位置不变</li><li>适合大规模数据排序</li><li>可用于外部排序和链表排序</li></ul></li><li><strong>缺点</strong>：<ul><li>空间复杂度较高，需要 O(n) 额外空间</li><li>对于小规模数据，常数因子较大</li><li>不是原地排序算法</li></ul></li></ul><h2 id="应用场景"><a class="markdownIt-Anchor" href="#应用场景"></a> 应用场景：</h2><ul><li>912<a href="%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84.md">排序数组</a><ul><li>问题描述：给你一个整数数组 <code>nums</code>，请你将该数组升序排列。</li><li>解决方案：归并排序即可</li></ul></li><li>88<a href="%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84.md">合并两个有序数组</a><ul><li>问题描述：请你 <strong>合并</strong> <code>nums2</code> 到 <code>nums1</code> 中，使合并后的数组同样按 <strong>非递减顺序</strong> 排列。</li><li>解决方案：仿照归并排序的思想合并</li></ul></li><li>LCR170<a href="%E4%BA%A4%E6%98%93%E9%80%86%E5%BA%8F%E5%AF%B9%E7%9A%84%E6%80%BB%E6%95%B0.md">交易逆序对的总数</a><ul><li>问题描述：设计一个程序，输入一段时间内的股票交易记录 <code>record</code>，返回其中存在的「交易逆序对」总数。</li><li>解决方案：归并排序合并数组过程统计逆序对数量</li></ul></li><li>315<a href="%E8%AE%A1%E7%AE%97%E5%8F%B3%E4%BE%A7%E5%B0%8F%E4%BA%8E%E5%BD%93%E5%89%8D%E5%85%83%E7%B4%A0%E7%9A%84%E4%B8%AA%E6%95%B0.md">计算右侧小于当前元素的个数</a><ul><li>问题描述：按要求返回一个新数组 <code>counts</code> 。数组 <code>counts</code> 有该性质： <code>counts[i]</code> 的值是  <code>nums[i]</code> 右侧小于 <code>nums[i]</code> 的元素的数量。</li><li>解决方案：归并过程实际上已经在对逆序对小于数计数了，我们只需要在过程将其记录即可</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="数据结构" scheme="https://id-zy.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>希尔排序</title>
    <link href="https://id-zy.github.io/2025/12/17/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/"/>
    <id>https://id-zy.github.io/2025/12/17/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/</id>
    <published>2025-12-17T15:20:20.662Z</published>
    <updated>2025-12-13T09:15:49.345Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="希尔排序"><a class="markdownIt-Anchor" href="#希尔排序"></a> 希尔排序</h1><h2 id="基本概念"><a class="markdownIt-Anchor" href="#基本概念"></a> 基本概念</h2><p><strong>希尔排序（Shell Sort）基本思想</strong>：<br />通过设定不同的间隔（gap），将数组分组进行插入排序，然后逐步缩小间隔直至为 11，最终完成整个数组的排序。</p><h2 id="算法实现步骤"><a class="markdownIt-Anchor" href="#算法实现步骤"></a> 算法实现步骤</h2><p>假设数组长度为 n，算法步骤如下：</p><ol><li>设定初始间隔 <code>gap = n / 2</code>。</li><li>按间隔将数组分组，对每组进行插入排序。</li><li>缩小间隔 <code>gap = gap / 2</code>。</li><li>重复步骤 2∼3，直到 <code>gap = 1</code>。</li><li>最后对整个数组进行一次插入排序。</li></ol><h3 id="费曼理解"><a class="markdownIt-Anchor" href="#费曼理解"></a> 费曼理解</h3><h2 id="内部实现"><a class="markdownIt-Anchor" href="#内部实现"></a> 内部实现：</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">solution</span>:</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">shellsort</span>(<span class="params">self,nums:[<span class="built_in">int</span>]</span>)-&gt;[<span class="built_in">int</span>]:</span><br><span class="line">size=<span class="built_in">len</span>(nums)</span><br><span class="line">gap=size//<span class="number">2</span></span><br><span class="line"><span class="keyword">while</span> gap&gt;<span class="number">0</span>:</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(gap,size):</span><br><span class="line">temp=nums[i]</span><br><span class="line">j=i</span><br><span class="line"><span class="keyword">while</span> j&gt;=gap <span class="keyword">and</span> nums[j-gap]&gt;temp:</span><br><span class="line">nums[j]=nums[j-gap]</span><br><span class="line">j-=gap</span><br><span class="line">nums[j]=temp</span><br><span class="line">gap//=<span class="number">2</span></span><br><span class="line"><span class="keyword">return</span> nums</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sortarray</span>(<span class="params">self,nums:[<span class="built_in">int</span>]</span>)-&gt;[<span class="built_in">int</span>]:</span><br><span class="line"><span class="keyword">return</span> <span class="variable language_">self</span>.shellsort(nums)</span><br></pre></td></tr></table></figure><h2 id="复杂度分析"><a class="markdownIt-Anchor" href="#复杂度分析"></a> 复杂度分析：</h2><table><thead><tr><th>指标</th><th>复杂度</th><th>说明</th></tr></thead><tbody><tr><td><strong>最佳时间复杂度</strong></td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></td><td>当数组已有序时</td></tr><tr><td><strong>最坏时间复杂度</strong></td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></td><td>使用普通间隔序列时</td></tr><tr><td><strong>平均时间复杂度</strong></td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>1.3</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^{1.3})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">.</span><span class="mord mtight">3</span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>~ <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>1.5</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^{1.5})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">.</span><span class="mord mtight">5</span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></td><td>取决于间隔序列选择，如果选取得当接近于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mtext>⁡</mtext><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(nlog⁡n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord">⁡</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></td></tr><tr><td><strong>空间复杂度</strong></td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></td><td>原地排序，只使用常数空间</td></tr><tr><td><strong>稳定性</strong></td><td>不稳定</td><td>不同组间的相等元素可能改变相对顺序</td></tr><tr><td><strong>补充说明：</strong></td><td></td><td></td></tr></tbody></table><ul><li>希尔排序的时间复杂度高度依赖于间隔序列的选择。</li><li>当采用常见的 <code>gap = gap // 2</code> 间隔序列时，排序过程大约需要 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>o</mi><mi>g</mi><mtext>⁡</mtext><mn>2</mn><mi>n</mi></mrow><annotation encoding="application/x-tex">log⁡2n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord">⁡</span><span class="mord">2</span><span class="mord mathnormal">n</span></span></span></span> 趟，每一趟的操作类似于分组插入排序。</li><li>每一趟的排序时间复杂度约为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，但随着 gap 的减小，实际操作次数逐步减少。</li><li>综合来看，希尔排序的整体时间复杂度通常介于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mtext>⁡</mtext><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(nlog⁡n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord">⁡</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 之间，如果间隔序列选择得当，性能可接近 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mtext>⁡</mtext><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(nlog⁡n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord">⁡</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>。<br /><strong>适用场景</strong>：</li><li>中等规模数据（50≤n≤1000）</li><li>对插入排序的改进需求</li><li>对稳定性要求不高的场景<br />希尔排序是插入排序的改进版本，通过分组排序减少数据移动次数，提高排序效率。</li><li><strong>优点</strong>：比插入排序更快，空间复杂度低，适合中等规模数据</li><li><strong>缺点</strong>：时间复杂度不稳定，不稳定排序，间隔序列选择影响性能</li></ul><h2 id="应用场景"><a class="markdownIt-Anchor" href="#应用场景"></a> 应用场景：</h2><ul><li>912<a href="%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84.md">排序数组</a><ul><li>问题描述：给你一个整数数组 <code>nums</code>，请你将该数组升序排列。</li><li>解决方案：实现一遍希尔排序即可</li></ul></li><li>506<a href="%E7%9B%B8%E5%AF%B9%E5%90%8D%E6%AC%A1.md">相对名次</a><ul><li>问题描述：使用长度为 <code>n</code> 的数组 <code>answer</code> 返回获奖，其中 <code>answer[i]</code> 是第 <code>i</code> 位运动员的获奖情况。</li><li>解决方案：使用希尔排序后再建立索引与值的关系</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="数据结构" scheme="https://id-zy.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>多数元素-LeetCode</title>
    <link href="https://id-zy.github.io/2025/12/17/%E5%A4%9A%E6%95%B0%E5%85%83%E7%B4%A0/"/>
    <id>https://id-zy.github.io/2025/12/17/%E5%A4%9A%E6%95%B0%E5%85%83%E7%B4%A0/</id>
    <published>2025-12-16T16:00:00.000Z</published>
    <updated>2025-12-17T01:45:36.856Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="多数元素"><a class="markdownIt-Anchor" href="#多数元素"></a> 多数元素</h1><h2 id="问题描述来源于leetcode"><a class="markdownIt-Anchor" href="#问题描述来源于leetcode"></a> 🎯 问题描述（来源于LeetCode）</h2><p><strong>描述</strong>：<br />给定一个大小为 <code>n</code> 的数组 <code>nums</code> ，返回其中的多数元素。多数元素是指在数组中出现次数 <strong>大于</strong> <code>⌊ n/2 ⌋</code> 的元素。<br />你可以假设数组是非空的，并且给定的数组总是存在多数元素。<br /><strong>说明</strong>：</p><ul><li><code>n == nums.length</code></li><li><code>1 &lt;= n &lt;= 5 * 104</code></li><li><code>-109 &lt;= nums[i] &lt;= 109</code></li><li>输入保证数组中一定有一个多数元素。</li></ul><p><strong>示例</strong>：</p><ul><li>示例 1：</li></ul><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [3,2,3]</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure><ul><li>示例 2：</li></ul><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [2,2,1,1,1,2,2]</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure><h2 id="解题思路"><a class="markdownIt-Anchor" href="#解题思路"></a> 💻 解题思路</h2><h3 id="思路1快速排序"><a class="markdownIt-Anchor" href="#思路1快速排序"></a> 思路1：快速排序</h3><h4 id="思路1代码实现"><a class="markdownIt-Anchor" href="#思路1代码实现"></a> 思路1：代码实现</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">majorityElement</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        nums.sort()</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="built_in">len</span>(nums)//<span class="number">2</span>]</span><br></pre></td></tr></table></figure><h4 id="思路1-性能分析"><a class="markdownIt-Anchor" href="#思路1-性能分析"></a> 思路1：📊 性能分析</h4><h5 id="提交结果"><a class="markdownIt-Anchor" href="#提交结果"></a> 提交结果</h5><ul><li><strong>运行时间</strong>：0ms击败100.00%</li><li><strong>内存消耗</strong>：19.10MB击败26.44%</li></ul><h5 id="复杂度验证"><a class="markdownIt-Anchor" href="#复杂度验证"></a> 复杂度验证</h5><ul><li>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(Nlogn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></li><li>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></li></ul><h4 id="思考"><a class="markdownIt-Anchor" href="#思考"></a> 思考</h4><p>众数一定会出现在排序后的数组中间</p><h3 id="思路2哈希表"><a class="markdownIt-Anchor" href="#思路2哈希表"></a> 思路2：哈希表</h3><h4 id="思路2代码实现"><a class="markdownIt-Anchor" href="#思路2代码实现"></a> 思路2：代码实现</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">majorityElement</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        arr= defaultdict(<span class="built_in">int</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">            arr[i]+=<span class="number">1</span></span><br><span class="line">        n=<span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">for</span> i,count <span class="keyword">in</span> arr.items():</span><br><span class="line">            <span class="keyword">if</span> count&gt;n//<span class="number">2</span>:</span><br><span class="line">                <span class="keyword">return</span> i</span><br></pre></td></tr></table></figure><h4 id="思路2-性能分析"><a class="markdownIt-Anchor" href="#思路2-性能分析"></a> 思路2：📊 性能分析</h4><h5 id="提交结果-2"><a class="markdownIt-Anchor" href="#提交结果-2"></a> 提交结果</h5><ul><li><strong>运行时间</strong>：7ms击败52.43%</li><li><strong>内存消耗</strong>：18.99MB击败59.30%</li></ul><h5 id="复杂度验证-2"><a class="markdownIt-Anchor" href="#复杂度验证-2"></a> 复杂度验证</h5><ul><li>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span></li><li>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span></li></ul><h4 id="思考-2"><a class="markdownIt-Anchor" href="#思考-2"></a> 思考</h4><p>哈希表统计数字出现个数</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="作业练习" scheme="https://id-zy.github.io/categories/%E4%BD%9C%E4%B8%9A%E7%BB%83%E4%B9%A0/"/>
    
    
    <category term="LeetCode" scheme="https://id-zy.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>计算右侧小于当前元素的个数-LeetCode</title>
    <link href="https://id-zy.github.io/2025/12/16/%E8%AE%A1%E7%AE%97%E5%8F%B3%E4%BE%A7%E5%B0%8F%E4%BA%8E%E5%BD%93%E5%89%8D%E5%85%83%E7%B4%A0%E7%9A%84%E4%B8%AA%E6%95%B0/"/>
    <id>https://id-zy.github.io/2025/12/16/%E8%AE%A1%E7%AE%97%E5%8F%B3%E4%BE%A7%E5%B0%8F%E4%BA%8E%E5%BD%93%E5%89%8D%E5%85%83%E7%B4%A0%E7%9A%84%E4%B8%AA%E6%95%B0/</id>
    <published>2025-12-15T16:00:00.000Z</published>
    <updated>2025-12-16T12:21:54.936Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="计算右侧小于当前元素的个数"><a class="markdownIt-Anchor" href="#计算右侧小于当前元素的个数"></a> 计算右侧小于当前元素的个数</h1><h2 id="问题描述来源于leetcode"><a class="markdownIt-Anchor" href="#问题描述来源于leetcode"></a> 🎯 问题描述（来源于LeetCode）</h2><p><strong>描述</strong>：<br />给你一个整数数组 <code>nums</code> ，按要求返回一个新数组 <code>counts</code> 。数组 <code>counts</code> 有该性质： <code>counts[i]</code> 的值是  <code>nums[i]</code> 右侧小于 <code>nums[i]</code> 的元素的数量。<br /><strong>说明</strong>：</p><ul><li><p><code>1 &lt;= nums.length &lt;= 105</code></p></li><li><p><code>-104 &lt;= nums[i] &lt;= 104</code><br /><strong>示例</strong>：</p></li><li><p>示例 1：</p></li></ul><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [5,2,6,1]</span><br><span class="line">输出：[2,1,1,0]  </span><br><span class="line">解释：</span><br><span class="line">5 的右侧有 2 个更小的元素 (2 和 1)</span><br><span class="line">2 的右侧仅有 1 个更小的元素 (1)</span><br><span class="line">6 的右侧有1个更小的元素 (1)</span><br><span class="line">1 的右侧有0个更小的元素</span><br></pre></td></tr></table></figure><ul><li>示例 2：</li></ul><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [-1]</span><br><span class="line">输出：[0]</span><br></pre></td></tr></table></figure><h2 id="解题思路"><a class="markdownIt-Anchor" href="#解题思路"></a> 💻 解题思路</h2><h3 id="思路1在归并过程中计数"><a class="markdownIt-Anchor" href="#思路1在归并过程中计数"></a> 思路1：在归并过程中计数</h3><h4 id="思路1代码实现"><a class="markdownIt-Anchor" href="#思路1代码实现"></a> 思路1：代码实现</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">countSmaller</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        ans = [<span class="number">0</span>] * n        </span><br><span class="line">        arr = [(nums[i], i) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">merge_sort</span>(<span class="params">arr, left, right</span>):</span><br><span class="line">            <span class="keyword">if</span> left &gt;= right:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            mid = (left + right) // <span class="number">2</span></span><br><span class="line">            merge_sort(arr, left, mid)</span><br><span class="line">            merge_sort(arr, mid + <span class="number">1</span>, right)</span><br><span class="line">            merge(arr, left, mid, right)</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">merge</span>(<span class="params">arr, left, mid, right</span>):</span><br><span class="line">            temp = []</span><br><span class="line">            i, j = left, mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> i &lt;= mid <span class="keyword">and</span> j &lt;= right:</span><br><span class="line">                <span class="keyword">if</span> arr[i][<span class="number">0</span>] &lt;= arr[j][<span class="number">0</span>]:</span><br><span class="line">                    ans[arr[i][<span class="number">1</span>]] += (j - (mid + <span class="number">1</span>))</span><br><span class="line">                    temp.append(arr[i])</span><br><span class="line">                    i += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    temp.append(arr[j])</span><br><span class="line">                    j += <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> i &lt;= mid:</span><br><span class="line">                ans[arr[i][<span class="number">1</span>]] += (j - (mid + <span class="number">1</span>))</span><br><span class="line">                temp.append(arr[i])</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> j &lt;= right:</span><br><span class="line">                temp.append(arr[j])</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(left, right + <span class="number">1</span>):</span><br><span class="line">                arr[k] = temp[k - left]</span><br><span class="line">        </span><br><span class="line">        merge_sort(arr, <span class="number">0</span>, n - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><h4 id="思路1-性能分析"><a class="markdownIt-Anchor" href="#思路1-性能分析"></a> 思路1：📊 性能分析</h4><h5 id="提交结果"><a class="markdownIt-Anchor" href="#提交结果"></a> 提交结果</h5><ul><li><strong>运行时间</strong>：1459ms击败39.86%</li><li><strong>内存消耗</strong>：47.17MB击败36.36%</li></ul><h5 id="复杂度验证"><a class="markdownIt-Anchor" href="#复杂度验证"></a> 复杂度验证</h5><ul><li>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mi>L</mi><mi>o</mi><mi>g</mi><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(NLogN)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mord mathnormal">L</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span></li><li>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span></li></ul><h4 id="思考"><a class="markdownIt-Anchor" href="#思考"></a> 思考</h4><p>归并过程实际上已经在对逆序对小于数计数了，我们只需要在过程将其记录即可</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="作业练习" scheme="https://id-zy.github.io/categories/%E4%BD%9C%E4%B8%9A%E7%BB%83%E4%B9%A0/"/>
    
    
    <category term="LeetCode" scheme="https://id-zy.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>交易逆序对的总数-LeetCode</title>
    <link href="https://id-zy.github.io/2025/12/15/%E4%BA%A4%E6%98%93%E9%80%86%E5%BA%8F%E5%AF%B9%E7%9A%84%E6%80%BB%E6%95%B0/"/>
    <id>https://id-zy.github.io/2025/12/15/%E4%BA%A4%E6%98%93%E9%80%86%E5%BA%8F%E5%AF%B9%E7%9A%84%E6%80%BB%E6%95%B0/</id>
    <published>2025-12-14T16:00:00.000Z</published>
    <updated>2025-12-15T07:57:10.094Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="交易逆序对的总数"><a class="markdownIt-Anchor" href="#交易逆序对的总数"></a> 交易逆序对的总数</h1><h2 id="问题描述来源于leetcode"><a class="markdownIt-Anchor" href="#问题描述来源于leetcode"></a> 🎯 问题描述（来源于LeetCode）</h2><p><strong>描述</strong>：<br />在股票交易中，如果前一天的股价高于后一天的股价，则可以认为存在一个「交易逆序对」。请设计一个程序，输入一段时间内的股票交易记录 <code>record</code>，返回其中存在的「交易逆序对」总数。<br /><strong>说明</strong>：</p><ul><li>0 &lt;= record.length &lt;= 50000</li></ul><p><strong>示例</strong>：</p><ul><li>示例 1：</li></ul><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：record = [9, 7, 5, 4, 6]</span><br><span class="line">输出：8</span><br><span class="line">解释：交易中的逆序对为 (9, 7), (9, 5), (9, 4), (9, 6), (7, 5), (7, 4), (7, 6), (5, 4)。</span><br></pre></td></tr></table></figure><h2 id="解题思路"><a class="markdownIt-Anchor" href="#解题思路"></a> 💻 解题思路</h2><h3 id="思路1暴力破解"><a class="markdownIt-Anchor" href="#思路1暴力破解"></a> 思路1：暴力破解</h3><h4 id="思路1代码实现"><a class="markdownIt-Anchor" href="#思路1代码实现"></a> 思路1：代码实现</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reversePairs</span>(<span class="params">self, record: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        i=count=<span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i&lt;<span class="built_in">len</span>(record):</span><br><span class="line">            <span class="keyword">for</span> d <span class="keyword">in</span> <span class="built_in">range</span>(i,<span class="built_in">len</span>(record)):</span><br><span class="line">                <span class="keyword">if</span> record[i]&gt;record[d]:</span><br><span class="line">                    count+=<span class="number">1</span></span><br><span class="line">            i+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure><h4 id="思路1-性能分析"><a class="markdownIt-Anchor" href="#思路1-性能分析"></a> 思路1：📊 性能分析</h4><h5 id="提交结果"><a class="markdownIt-Anchor" href="#提交结果"></a> 提交结果</h5><ul><li><strong>运行时间</strong>：超时</li><li><strong>内存消耗</strong>：</li></ul><h5 id="复杂度验证"><a class="markdownIt-Anchor" href="#复杂度验证"></a> 复杂度验证</h5><ul><li>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>N</mi><mn>2</mn></msup><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N^2))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></li><li>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></li></ul><h3 id="思路2归并"><a class="markdownIt-Anchor" href="#思路2归并"></a> 思路2：归并</h3><h4 id="思路2代码实现"><a class="markdownIt-Anchor" href="#思路2代码实现"></a> 思路2：代码实现</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reversePairs</span>(<span class="params">self, record: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.merge_sort(record)[<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">merge_sort</span>(<span class="params">self, nums</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nums) &lt;= <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> nums, <span class="number">0</span></span><br><span class="line">        mid = <span class="built_in">len</span>(nums) // <span class="number">2</span></span><br><span class="line">        left, left_count = <span class="variable language_">self</span>.merge_sort(nums[:mid])</span><br><span class="line">        right, right_count = <span class="variable language_">self</span>.merge_sort(nums[mid:])</span><br><span class="line">        </span><br><span class="line">        merged, merge_count = <span class="variable language_">self</span>.merge(left, right)</span><br><span class="line">        <span class="keyword">return</span> merged, left_count + right_count + merge_count</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">merge</span>(<span class="params">self, left, right</span>):</span><br><span class="line">        result = []</span><br><span class="line">        i = j = <span class="number">0</span></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(left) <span class="keyword">and</span> j &lt; <span class="built_in">len</span>(right):</span><br><span class="line">            <span class="keyword">if</span> left[i] &lt;= right[j]:</span><br><span class="line">                result.append(left[i])</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                result.append(right[j])</span><br><span class="line">                <span class="comment"># 计算逆序对</span></span><br><span class="line">                count += <span class="built_in">len</span>(left) - i</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        result.extend(left[i:])</span><br><span class="line">        result.extend(right[j:])</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result, count</span><br></pre></td></tr></table></figure><h4 id="思路2-性能分析"><a class="markdownIt-Anchor" href="#思路2-性能分析"></a> 思路2：📊 性能分析</h4><h5 id="提交结果-2"><a class="markdownIt-Anchor" href="#提交结果-2"></a> 提交结果</h5><ul><li><strong>运行时间</strong>：663ms击败57.22%</li><li><strong>内存消耗</strong>：23.94MB击败65.88%</li></ul><h5 id="复杂度验证-2"><a class="markdownIt-Anchor" href="#复杂度验证-2"></a> 复杂度验证</h5><ul><li>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(Nlogn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></li><li>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span></li></ul><h4 id="思考"><a class="markdownIt-Anchor" href="#思考"></a> 思考</h4>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="作业练习" scheme="https://id-zy.github.io/categories/%E4%BD%9C%E4%B8%9A%E7%BB%83%E4%B9%A0/"/>
    
    
    <category term="LeetCode" scheme="https://id-zy.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>合并两个有序数组-LeetCode</title>
    <link href="https://id-zy.github.io/2025/12/14/%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/"/>
    <id>https://id-zy.github.io/2025/12/14/%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/</id>
    <published>2025-12-13T16:00:00.000Z</published>
    <updated>2025-12-14T13:58:37.101Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="合并两个有序数组"><a class="markdownIt-Anchor" href="#合并两个有序数组"></a> 合并两个有序数组</h1><h2 id="问题描述来源于leetcode"><a class="markdownIt-Anchor" href="#问题描述来源于leetcode"></a> 🎯 问题描述（来源于LeetCode）</h2><p><strong>描述</strong>：<br />给你两个按 <strong>非递减顺序</strong> 排列的整数数组 <code>nums1</code> 和 <code>nums2</code>，另有两个整数 <code>m</code> 和 <code>n</code> ，分别表示 <code>nums1</code> 和 <code>nums2</code> 中的元素数目。<br />请你 <strong>合并</strong> <code>nums2</code> 到 <code>nums1</code> 中，使合并后的数组同样按 <strong>非递减顺序</strong> 排列。<br />注意：最终，合并后数组不应由函数返回，而是存储在数组 <code>nums1</code> 中。为了应对这种情况，<code>nums1</code> 的初始长度为 <code>m + n</code>，其中前 <code>m</code> 个元素表示应合并的元素，后 <code>n</code> 个元素为 <code>0</code> ，应忽略。<code>nums2</code> 的长度为 <code>n</code> 。</p><p><strong>说明</strong>：</p><ul><li><code>nums1.length == m + n</code></li><li><code>nums2.length == n</code></li><li><code>0 &lt;= m, n &lt;= 200</code></li><li><code>1 &lt;= m + n &lt;= 200</code></li><li><code>-109 &lt;= nums1[i], nums2[j] &lt;= 109</code></li></ul><p><strong>示例</strong>：</p><ul><li>示例 1：</li></ul><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [1], m = 1, nums2 = [], n = 0</span><br><span class="line">输出：[1]</span><br><span class="line">解释：需要合并 [1] 和 [] 。</span><br><span class="line">合并结果是 [1] 。</span><br></pre></td></tr></table></figure><ul><li>示例 2：</li></ul><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3</span><br><span class="line">输出：[1,2,2,3,5,6]</span><br><span class="line">解释：需要合并 [1,2,3] 和 [2,5,6] 。</span><br><span class="line">合并结果是 [1,2,2,3,5,6]</span><br></pre></td></tr></table></figure><h2 id="解题思路"><a class="markdownIt-Anchor" href="#解题思路"></a> 💻 解题思路</h2><h3 id="思路1归并排序"><a class="markdownIt-Anchor" href="#思路1归并排序"></a> 思路1：归并排序</h3><h4 id="思路1代码实现"><a class="markdownIt-Anchor" href="#思路1代码实现"></a> 思路1：代码实现</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">merge</span>(<span class="params">self, nums1: <span class="type">List</span>[<span class="built_in">int</span>], m: <span class="built_in">int</span>, nums2: <span class="type">List</span>[<span class="built_in">int</span>], n: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        nums1_copy = nums1[:m]</span><br><span class="line">        p1, p2, p = <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> p1 &lt; m <span class="keyword">and</span> p2 &lt; n:</span><br><span class="line">            <span class="keyword">if</span> nums1_copy[p1] &lt; nums2[p2]:</span><br><span class="line">                nums1[p] = nums1_copy[p1]</span><br><span class="line">                p1 += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                nums1[p] = nums2[p2]</span><br><span class="line">                p2 += <span class="number">1</span></span><br><span class="line">            p += <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> p1 &lt; m:</span><br><span class="line">            nums1[p] = nums1_copy[p1]</span><br><span class="line">            p1 += <span class="number">1</span></span><br><span class="line">            p += <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> p2 &lt; n:</span><br><span class="line">            nums1[p] = nums2[p2]</span><br><span class="line">            p2 += <span class="number">1</span></span><br><span class="line">            p += <span class="number">1</span></span><br></pre></td></tr></table></figure><h4 id="思路1-性能分析"><a class="markdownIt-Anchor" href="#思路1-性能分析"></a> 思路1：📊 性能分析</h4><h5 id="提交结果"><a class="markdownIt-Anchor" href="#提交结果"></a> 提交结果</h5><ul><li><strong>运行时间</strong>：0ms击败100.00%</li><li><strong>内存消耗</strong>：17.77MB击败5.23%</li></ul><h5 id="复杂度验证"><a class="markdownIt-Anchor" href="#复杂度验证"></a> 复杂度验证</h5><ul><li>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>M</mi><mo>+</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(M+N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span></li><li>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>M</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(M)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mclose">)</span></span></span></span></li></ul><h4 id="思考"><a class="markdownIt-Anchor" href="#思考"></a> 思考</h4><p>仿照归并排序的思想合并</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="作业练习" scheme="https://id-zy.github.io/categories/%E4%BD%9C%E4%B8%9A%E7%BB%83%E4%B9%A0/"/>
    
    
    <category term="LeetCode" scheme="https://id-zy.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>对角线遍历-LeetCode</title>
    <link href="https://id-zy.github.io/2025/12/13/%E5%AF%B9%E8%A7%92%E7%BA%BF%E9%81%8D%E5%8E%86/"/>
    <id>https://id-zy.github.io/2025/12/13/%E5%AF%B9%E8%A7%92%E7%BA%BF%E9%81%8D%E5%8E%86/</id>
    <published>2025-12-12T16:00:00.000Z</published>
    <updated>2025-12-13T08:14:32.784Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="对角线遍历"><a class="markdownIt-Anchor" href="#对角线遍历"></a> 对角线遍历</h1><h2 id="问题描述来源于leetcode"><a class="markdownIt-Anchor" href="#问题描述来源于leetcode"></a> 🎯 问题描述（来源于LeetCode）</h2><p><strong>描述</strong>：<br />给你一个大小为 <code>m x n</code> 的矩阵 <code>mat</code> ，请以对角线遍历的顺序，用一个数组返回这个矩阵中的所有元素。<br /><strong>说明</strong>：</p><ul><li><p><code>m == mat.length</code></p></li><li><p><code>n == mat[i].length</code></p></li><li><p><code>1 &lt;= m, n &lt;= 104</code></p></li><li><p><code>1 &lt;= m * n &lt;= 104</code></p></li><li><p><code>-105 &lt;= mat[i][j] &lt;= 105</code><br /><strong>示例</strong>：</p></li><li><p>示例 1：</p></li></ul><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：mat = [[1,2,3],[4,5,6],[7,8,9]]</span><br><span class="line">输出：[1,2,4,7,5,3,6,8,9]</span><br></pre></td></tr></table></figure><ul><li>示例 2：</li></ul><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：mat = [[1,2],[3,4]]</span><br><span class="line">输出：[1,2,3,4]</span><br></pre></td></tr></table></figure><h2 id="解题思路"><a class="markdownIt-Anchor" href="#解题思路"></a> 💻 解题思路</h2><h3 id="思路1遍历"><a class="markdownIt-Anchor" href="#思路1遍历"></a> 思路1：遍历</h3><h4 id="思路1代码实现"><a class="markdownIt-Anchor" href="#思路1代码实现"></a> 思路1：代码实现</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findDiagonalOrder</span>(<span class="params">self, mat: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> mat <span class="keyword">or</span> <span class="keyword">not</span> mat[<span class="number">0</span>]:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        m, n = <span class="built_in">len</span>(mat), <span class="built_in">len</span>(mat[<span class="number">0</span>])</span><br><span class="line">        ans = []</span><br><span class="line">        row, col = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        direction = <span class="number">1</span>  </span><br><span class="line">        <span class="keyword">while</span> <span class="built_in">len</span>(ans) &lt; m * n:</span><br><span class="line">            ans.append(mat[row][col])</span><br><span class="line">            <span class="keyword">if</span> direction == <span class="number">1</span>:  </span><br><span class="line">                new_row = row - <span class="number">1</span></span><br><span class="line">                new_col = col + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:  </span><br><span class="line">                new_row = row + <span class="number">1</span></span><br><span class="line">                new_col = col - <span class="number">1</span></span><br><span class="line">            is_out_of_bounds = new_row &lt; <span class="number">0</span> <span class="keyword">or</span> new_row &gt;= m <span class="keyword">or</span> new_col &lt; <span class="number">0</span> <span class="keyword">or</span> new_col &gt;= n</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> is_out_of_bounds:</span><br><span class="line">                row, col = new_row, new_col</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> direction == <span class="number">1</span>: </span><br><span class="line">                    <span class="keyword">if</span> col + <span class="number">1</span> &lt; n:</span><br><span class="line">                        col += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        row += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:  </span><br><span class="line">                    <span class="keyword">if</span> row + <span class="number">1</span> &lt; m:</span><br><span class="line">                        row += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        col += <span class="number">1</span></span><br><span class="line">                direction *= -<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><h4 id="思路1-性能分析"><a class="markdownIt-Anchor" href="#思路1-性能分析"></a> 思路1：📊 性能分析</h4><h5 id="提交结果"><a class="markdownIt-Anchor" href="#提交结果"></a> 提交结果</h5><ul><li><strong>运行时间</strong>：13ms击败50.65%</li><li><strong>内存消耗</strong>：19.50MB击败25.22%</li></ul><h5 id="复杂度验证"><a class="markdownIt-Anchor" href="#复杂度验证"></a> 复杂度验证</h5><ul><li>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mo>∗</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m*n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></li><li>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mo>∗</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m*n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></li></ul><h4 id="思考"><a class="markdownIt-Anchor" href="#思考"></a> 思考</h4><p>记录遍历方向，越界反转</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="作业练习" scheme="https://id-zy.github.io/categories/%E4%BD%9C%E4%B8%9A%E7%BB%83%E4%B9%A0/"/>
    
    
    <category term="LeetCode" scheme="https://id-zy.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>排序数组-LeetCode</title>
    <link href="https://id-zy.github.io/2025/12/13/%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84/"/>
    <id>https://id-zy.github.io/2025/12/13/%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84/</id>
    <published>2025-12-12T16:00:00.000Z</published>
    <updated>2025-12-17T01:29:23.886Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="排序数组"><a class="markdownIt-Anchor" href="#排序数组"></a> 排序数组</h1><h2 id="问题描述来源于leetcode"><a class="markdownIt-Anchor" href="#问题描述来源于leetcode"></a> 🎯 问题描述（来源于LeetCode）</h2><p><strong>描述</strong>：<br />给你一个整数数组 <code>nums</code>，请你将该数组升序排列。<br />你必须在 <strong>不使用任何内置函数</strong> 的情况下解决问题，时间复杂度为 <code>O(nlog(n))</code>，并且空间复杂度尽可能小。<br /><strong>说明</strong>：</p><ul><li><code>1 &lt;= nums.length &lt;= 5 * 104</code></li><li><code>-5 * 104 &lt;= nums[i] &lt;= 5 * 104</code></li></ul><p><strong>示例</strong>：</p><ul><li>示例 1：</li></ul><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [5,2,3,1]</span><br><span class="line">输出：[1,2,3,5]</span><br><span class="line">解释：数组排序后，某些数字的位置没有改变（例如，2 和 3），而其他数字的位置发生了改变（例如，1 和 5）。</span><br></pre></td></tr></table></figure><ul><li>示例 2：</li></ul><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [5,1,1,2,0,0]</span><br><span class="line">输出：[0,0,1,1,2,5]</span><br><span class="line">解释：请注意，nums 的值不一定唯一。</span><br></pre></td></tr></table></figure><h2 id="解题思路"><a class="markdownIt-Anchor" href="#解题思路"></a> 💻 解题思路</h2><h3 id="思路1希尔排序"><a class="markdownIt-Anchor" href="#思路1希尔排序"></a> 思路1：希尔排序</h3><h4 id="思路1代码实现"><a class="markdownIt-Anchor" href="#思路1代码实现"></a> 思路1：代码实现</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sortArray</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        size=<span class="built_in">len</span>(nums)</span><br><span class="line">        gap=size // <span class="number">2</span></span><br><span class="line">        <span class="keyword">while</span> gap&gt;<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(gap,size):</span><br><span class="line">                temp=nums[i]</span><br><span class="line">                j=i</span><br><span class="line">                <span class="keyword">while</span> j&gt;=gap <span class="keyword">and</span> nums[j-gap]&gt;temp:</span><br><span class="line">                    nums[j]=nums[j-gap]</span><br><span class="line">                    j-=gap</span><br><span class="line">                nums[j]=temp</span><br><span class="line">            gap//=<span class="number">2</span></span><br><span class="line">        <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure><h4 id="思路1-性能分析"><a class="markdownIt-Anchor" href="#思路1-性能分析"></a> 思路1：📊 性能分析</h4><h5 id="提交结果"><a class="markdownIt-Anchor" href="#提交结果"></a> 提交结果</h5><ul><li><strong>运行时间</strong>：635ms击败39.21%</li><li><strong>内存消耗</strong>：23.51MB击败92.42%</li></ul><h5 id="复杂度验证"><a class="markdownIt-Anchor" href="#复杂度验证"></a> 复杂度验证</h5><ul><li>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></li><li>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></li></ul><h3 id="思路2归并排序"><a class="markdownIt-Anchor" href="#思路2归并排序"></a> 思路2：归并排序</h3><h4 id="思路2代码实现"><a class="markdownIt-Anchor" href="#思路2代码实现"></a> 思路2：代码实现</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">merge</span>(<span class="params">self,left_nums:[<span class="built_in">int</span>],right_nums:[<span class="built_in">int</span>]</span>):</span><br><span class="line">        nums=[]</span><br><span class="line">        left_i=right_i=<span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> left_i&lt;<span class="built_in">len</span>(left_nums)<span class="keyword">and</span> right_i&lt;<span class="built_in">len</span>(right_nums):</span><br><span class="line">            <span class="keyword">if</span> left_nums[left_i]&lt;right_nums[right_i]:</span><br><span class="line">                nums.append(left_nums[left_i])</span><br><span class="line">                left_i+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                nums.append(right_nums[right_i])</span><br><span class="line">                right_i+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left_i&lt;<span class="built_in">len</span>(left_nums):</span><br><span class="line">            nums.append(left_nums[left_i])</span><br><span class="line">            left_i+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> right_i&lt;<span class="built_in">len</span>(right_nums):</span><br><span class="line">            nums.append(right_nums[right_i])</span><br><span class="line">            right_i+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> nums</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">mergesort</span>(<span class="params">self,nums:[<span class="built_in">int</span>]</span>)-&gt;[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nums)&lt;=<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> nums</span><br><span class="line">        mid=<span class="built_in">len</span>(nums)//<span class="number">2</span></span><br><span class="line">        left_nums=<span class="variable language_">self</span>.mergesort(nums[<span class="number">0</span>:mid])</span><br><span class="line">        right_nums=<span class="variable language_">self</span>.mergesort(nums[mid:])</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.merge(left_nums,right_nums)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sortArray</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.mergesort(nums)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure><h4 id="思路2-性能分析"><a class="markdownIt-Anchor" href="#思路2-性能分析"></a> 思路2：📊 性能分析</h4><h5 id="提交结果-2"><a class="markdownIt-Anchor" href="#提交结果-2"></a> 提交结果</h5><ul><li><strong>运行时间</strong>：771ms击败19.44%</li><li><strong>内存消耗</strong>：25.03MB击败43.20%</li></ul><h5 id="复杂度验证-2"><a class="markdownIt-Anchor" href="#复杂度验证-2"></a> 复杂度验证</h5><ul><li>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(Nlogn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></li><li>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span></li></ul><h3 id="思路3快速排序"><a class="markdownIt-Anchor" href="#思路3快速排序"></a> 思路3：快速排序</h3><h4 id="思路3代码实现"><a class="markdownIt-Anchor" href="#思路3代码实现"></a> 思路3：代码实现</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">randomPartition</span>(<span class="params">self,nums:[<span class="built_in">int</span>],low:<span class="built_in">int</span>,high:<span class="built_in">int</span></span>)-&gt;<span class="built_in">int</span>:</span><br><span class="line">        i=random.randint(low,high)</span><br><span class="line">        nums[low],nums[i]=nums[i],nums[low]</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.partition(nums,low,high)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">partition</span>(<span class="params">self,nums:[<span class="built_in">int</span>],low:<span class="built_in">int</span>,high:<span class="built_in">int</span></span>)-&gt;<span class="built_in">int</span>:</span><br><span class="line">        pivot=nums[low]</span><br><span class="line">        i,j=low,high</span><br><span class="line">        <span class="keyword">while</span> i&lt;j:</span><br><span class="line">            <span class="keyword">while</span> i&lt;j <span class="keyword">and</span> nums[j]&gt;=pivot:</span><br><span class="line">                j-=<span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> i&lt;j <span class="keyword">and</span> nums[i]&lt;=pivot:</span><br><span class="line">                i+=<span class="number">1</span></span><br><span class="line">            nums[i],nums[j]=nums[j],nums[i]</span><br><span class="line">        nums[low],nums[j]=nums[j],nums[low]</span><br><span class="line">        <span class="keyword">return</span> i</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">quicksort</span>(<span class="params">self,nums:[<span class="built_in">int</span>],low:<span class="built_in">int</span>,high:<span class="built_in">int</span></span>)-&gt;[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="keyword">if</span> low &lt;high:</span><br><span class="line">            pivot_i=<span class="variable language_">self</span>.randomPartition(nums,low,high)</span><br><span class="line">            <span class="variable language_">self</span>.quicksort(nums,low,pivot_i-<span class="number">1</span>)</span><br><span class="line">            <span class="variable language_">self</span>.quicksort(nums,pivot_i+<span class="number">1</span>,high)</span><br><span class="line">        <span class="keyword">return</span> nums</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sortArray</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.quicksort(nums,<span class="number">0</span>,<span class="built_in">len</span>(nums)-<span class="number">1</span>)</span><br></pre></td></tr></table></figure><h4 id="思路3-性能分析"><a class="markdownIt-Anchor" href="#思路3-性能分析"></a> 思路3：📊 性能分析</h4><h5 id="提交结果-3"><a class="markdownIt-Anchor" href="#提交结果-3"></a> 提交结果</h5><ul><li><strong>运行时间</strong>：超时</li><li><strong>内存消耗</strong>：</li></ul><h5 id="复杂度验证-3"><a class="markdownIt-Anchor" href="#复杂度验证-3"></a> 复杂度验证</h5><ul><li>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(Nlogn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></li><li>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="作业练习" scheme="https://id-zy.github.io/categories/%E4%BD%9C%E4%B8%9A%E7%BB%83%E4%B9%A0/"/>
    
    
    <category term="LeetCode" scheme="https://id-zy.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>相对名次-LeetCode</title>
    <link href="https://id-zy.github.io/2025/12/13/%E7%9B%B8%E5%AF%B9%E5%90%8D%E6%AC%A1/"/>
    <id>https://id-zy.github.io/2025/12/13/%E7%9B%B8%E5%AF%B9%E5%90%8D%E6%AC%A1/</id>
    <published>2025-12-12T16:00:00.000Z</published>
    <updated>2025-12-13T09:14:32.862Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="相对名次"><a class="markdownIt-Anchor" href="#相对名次"></a> 相对名次</h1><h2 id="问题描述来源于leetcode"><a class="markdownIt-Anchor" href="#问题描述来源于leetcode"></a> 🎯 问题描述（来源于LeetCode）</h2><p><strong>描述</strong>：<br />给你一个长度为 <code>n</code> 的整数数组 <code>score</code> ，其中 <code>score[i]</code> 是第 <code>i</code> 位运动员在比赛中的得分。所有得分都 <strong>互不相同</strong> 。<br />运动员将根据得分 <strong>决定名次</strong> ，其中名次第 <code>1</code> 的运动员得分最高，名次第 <code>2</code> 的运动员得分第 <code>2</code> 高，依此类推。运动员的名次决定了他们的获奖情况：</p><ul><li>名次第 <code>1</code> 的运动员获金牌 <code>&quot;Gold Medal&quot;</code> 。</li><li>名次第 <code>2</code> 的运动员获银牌 <code>&quot;Silver Medal&quot;</code> 。</li><li>名次第 <code>3</code> 的运动员获铜牌 <code>&quot;Bronze Medal&quot;</code> 。</li><li>从名次第 <code>4</code> 到第 <code>n</code> 的运动员，只能获得他们的名次编号（即，名次第 <code>x</code> 的运动员获得编号 <code>&quot;x&quot;</code>）。<br />使用长度为 <code>n</code> 的数组 <code>answer</code> 返回获奖，其中 <code>answer[i]</code> 是第 <code>i</code> 位运动员的获奖情况。<br /><strong>说明</strong>：</li><li><code>n == score.length</code></li><li><code>1 &lt;= n &lt;= 104</code></li><li><code>0 &lt;= score[i] &lt;= 106</code></li><li><code>score</code> 中的所有值 <strong>互不相同</strong></li></ul><p><strong>示例</strong>：</p><ul><li>示例 1：</li></ul><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：score = [5,4,3,2,1]</span><br><span class="line">输出：[&quot;Gold Medal&quot;,&quot;Silver Medal&quot;,&quot;Bronze Medal&quot;,&quot;4&quot;,&quot;5&quot;]</span><br><span class="line">解释：名次为 [1st, 2nd, 3rd, 4th, 5th] 。</span><br></pre></td></tr></table></figure><ul><li>示例 2：</li></ul><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：score = [10,3,8,9,4]</span><br><span class="line">输出：[&quot;Gold Medal&quot;,&quot;5&quot;,&quot;Bronze Medal&quot;,&quot;Silver Medal&quot;,&quot;4&quot;]</span><br><span class="line">解释：名次为 [1st, 5th, 3rd, 2nd, 4th] 。</span><br></pre></td></tr></table></figure><h2 id="解题思路"><a class="markdownIt-Anchor" href="#解题思路"></a> 💻 解题思路</h2><h3 id="思路1希尔排序"><a class="markdownIt-Anchor" href="#思路1希尔排序"></a> 思路1：希尔排序</h3><h4 id="思路1代码实现"><a class="markdownIt-Anchor" href="#思路1代码实现"></a> 思路1：代码实现</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findRelativeRanks</span>(<span class="params">self, score: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">str</span>]:</span><br><span class="line">        n=<span class="built_in">len</span>(score)</span><br><span class="line">        nums=score.copy()</span><br><span class="line">        indices = <span class="built_in">list</span>(<span class="built_in">range</span>(n))</span><br><span class="line">        gap=n//<span class="number">2</span></span><br><span class="line">        <span class="keyword">while</span> gap&gt;<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(gap,n):</span><br><span class="line">                temp=nums[i]</span><br><span class="line">                idx = indices[i]</span><br><span class="line">                j=i</span><br><span class="line">                <span class="keyword">while</span> j&gt;=gap <span class="keyword">and</span> nums[j-gap]&lt;temp:</span><br><span class="line">                    nums[j]=nums[j-gap]</span><br><span class="line">                    indices[j]=indices[j-gap]</span><br><span class="line">                    j-=gap</span><br><span class="line">                nums[j]=temp</span><br><span class="line">                indices[j]=idx</span><br><span class="line">            gap//=<span class="number">2</span></span><br><span class="line">        result = [<span class="string">&quot;&quot;</span>] * n</span><br><span class="line">        <span class="keyword">for</span> rank, idx <span class="keyword">in</span> <span class="built_in">enumerate</span>(indices):</span><br><span class="line">            <span class="keyword">if</span> rank == <span class="number">0</span>:</span><br><span class="line">                result[idx] = <span class="string">&quot;Gold Medal&quot;</span></span><br><span class="line">            <span class="keyword">elif</span> rank == <span class="number">1</span>:</span><br><span class="line">                result[idx] = <span class="string">&quot;Silver Medal&quot;</span></span><br><span class="line">            <span class="keyword">elif</span> rank == <span class="number">2</span>:</span><br><span class="line">                result[idx] = <span class="string">&quot;Bronze Medal&quot;</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                result[idx] = <span class="built_in">str</span>(rank + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><h4 id="思路1-性能分析"><a class="markdownIt-Anchor" href="#思路1-性能分析"></a> 思路1：📊 性能分析</h4><h5 id="提交结果"><a class="markdownIt-Anchor" href="#提交结果"></a> 提交结果</h5><ul><li><strong>运行时间</strong>：31ms击败23.85%</li><li><strong>内存消耗</strong>：18.61MB击败77.56%</li></ul><h5 id="复杂度验证"><a class="markdownIt-Anchor" href="#复杂度验证"></a> 复杂度验证</h5><ul><li>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(nlog(n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></li><li>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></li></ul><h4 id="思考"><a class="markdownIt-Anchor" href="#思考"></a> 思考</h4><p>使用希尔排序后再建立索引与值的关系</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="作业练习" scheme="https://id-zy.github.io/categories/%E4%BD%9C%E4%B8%9A%E7%BB%83%E4%B9%A0/"/>
    
    
    <category term="LeetCode" scheme="https://id-zy.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>加一-LeetCode</title>
    <link href="https://id-zy.github.io/2025/12/12/%E5%8A%A0%E4%B8%80/"/>
    <id>https://id-zy.github.io/2025/12/12/%E5%8A%A0%E4%B8%80/</id>
    <published>2025-12-11T16:00:00.000Z</published>
    <updated>2025-12-12T12:33:02.277Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="加一"><a class="markdownIt-Anchor" href="#加一"></a> 加一</h1><h2 id="问题描述来源于leetcode"><a class="markdownIt-Anchor" href="#问题描述来源于leetcode"></a> 🎯 问题描述（来源于LeetCode）</h2><p><strong>描述</strong>：<br />给定一个表示 <strong>大整数</strong> 的整数数组 <code>digits</code>，其中 <code>digits[i]</code> 是整数的第 <code>i</code> 位数字。这些数字按从左到右，从最高位到最低位排列。这个大整数不包含任何前导 <code>0</code>。<br />将大整数加 1，并返回结果的数字数组。<br /><strong>说明</strong>：</p><ul><li><p><code>1 &lt;= digits.length &lt;= 100</code></p></li><li><p><code>0 &lt;= digits[i] &lt;= 9</code></p></li><li><p><code>digits</code> 不包含任何前导 <code>0</code>。<br /><strong>示例</strong>：</p></li><li><p>示例 1：</p></li></ul><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：digits = [1,2,3]</span><br><span class="line">输出：[1,2,4]</span><br><span class="line">解释：输入数组表示数字 123。</span><br><span class="line">加 1 后得到 123 + 1 = 124。</span><br><span class="line">因此，结果应该是 [1,2,4]。</span><br></pre></td></tr></table></figure><ul><li>示例 2：</li></ul><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：digits = [9]</span><br><span class="line">输出：[1,0]</span><br><span class="line">解释：输入数组表示数字 9。</span><br><span class="line">加 1 得到了 9 + 1 = 10。</span><br><span class="line">因此，结果应该是 [1,0]。</span><br></pre></td></tr></table></figure><h2 id="解题思路"><a class="markdownIt-Anchor" href="#解题思路"></a> 💻 解题思路</h2><h3 id="思路1反向遍历"><a class="markdownIt-Anchor" href="#思路1反向遍历"></a> 思路1：反向遍历</h3><h4 id="思路1代码实现"><a class="markdownIt-Anchor" href="#思路1代码实现"></a> 思路1：代码实现</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">plusOne</span>(<span class="params">self, digits: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        n=<span class="built_in">len</span>(digits)</span><br><span class="line">        x=[]</span><br><span class="line">        d=n-<span class="number">1</span></span><br><span class="line">        digits[n-<span class="number">1</span>]+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> d&gt;-<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">while</span> digits[d]==<span class="number">10</span>:</span><br><span class="line">                x.append(<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">if</span> d==<span class="number">0</span>:</span><br><span class="line">                    x.append(<span class="number">1</span>)</span><br><span class="line">                    m=x[::-<span class="number">1</span>]</span><br><span class="line">                    <span class="keyword">return</span> m          </span><br><span class="line">                d-=<span class="number">1</span></span><br><span class="line">                digits[d]+=<span class="number">1</span></span><br><span class="line">            x.append(digits[d])</span><br><span class="line">            d-=<span class="number">1</span></span><br><span class="line">        m=x[::-<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> m</span><br></pre></td></tr></table></figure><h4 id="思路1-性能分析"><a class="markdownIt-Anchor" href="#思路1-性能分析"></a> 思路1：📊 性能分析</h4><h5 id="提交结果"><a class="markdownIt-Anchor" href="#提交结果"></a> 提交结果</h5><ul><li><strong>运行时间</strong>：0ms击败100.00%</li><li><strong>内存消耗</strong>：17.30MB击败97.07%</li></ul><h5 id="复杂度验证"><a class="markdownIt-Anchor" href="#复杂度验证"></a> 复杂度验证</h5><ul><li>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></li><li>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></li></ul><h4 id="思考"><a class="markdownIt-Anchor" href="#思考"></a> 思考</h4><p>反向遍历数组，判断当前数字+1后是否等于10，返回反转数组</p><h3 id="思路2判断当前数位是否进1观看灵神的思路"><a class="markdownIt-Anchor" href="#思路2判断当前数位是否进1观看灵神的思路"></a> 思路2：判断当前数位是否进1（观看灵神的思路）</h3><h4 id="思路2代码实现"><a class="markdownIt-Anchor" href="#思路2代码实现"></a> 思路2：代码实现</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">plusOne</span>(<span class="params">self, digits: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        n=<span class="built_in">len</span>(digits)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> digits[i]&lt;<span class="number">9</span>:</span><br><span class="line">                digits[i]+=<span class="number">1</span></span><br><span class="line">                <span class="keyword">return</span> digits</span><br><span class="line">            digits[i]=<span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> [<span class="number">1</span>]+digits</span><br></pre></td></tr></table></figure><h4 id="思路2-性能分析"><a class="markdownIt-Anchor" href="#思路2-性能分析"></a> 思路2：📊 性能分析</h4><h5 id="提交结果-2"><a class="markdownIt-Anchor" href="#提交结果-2"></a> 提交结果</h5><ul><li><strong>运行时间</strong>：0ms击败100.00%</li><li><strong>内存消耗</strong>：17.67MB击败14.25%</li></ul><h5 id="复杂度验证-2"><a class="markdownIt-Anchor" href="#复杂度验证-2"></a> 复杂度验证</h5><ul><li>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></li><li>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></li></ul><h4 id="思考-2"><a class="markdownIt-Anchor" href="#思考-2"></a> 思考</h4><p>反向遍历数组，判断当前数位是否需要进1，直到不进位返回数组</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="作业练习" scheme="https://id-zy.github.io/categories/%E4%BD%9C%E4%B8%9A%E7%BB%83%E4%B9%A0/"/>
    
    
    <category term="LeetCode" scheme="https://id-zy.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>各赛事的注册率-LeetCode</title>
    <link href="https://id-zy.github.io/2025/12/12/%E5%90%84%E8%B5%9B%E4%BA%8B%E7%9A%84%E6%B3%A8%E5%86%8C%E7%8E%87/"/>
    <id>https://id-zy.github.io/2025/12/12/%E5%90%84%E8%B5%9B%E4%BA%8B%E7%9A%84%E6%B3%A8%E5%86%8C%E7%8E%87/</id>
    <published>2025-12-11T16:00:00.000Z</published>
    <updated>2025-12-12T15:51:59.583Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="各赛事的注册率"><a class="markdownIt-Anchor" href="#各赛事的注册率"></a> 各赛事的注册率</h1><h2 id="问题描述来源于leetcode"><a class="markdownIt-Anchor" href="#问题描述来源于leetcode"></a> 🎯 问题描述（来源于LeetCode）</h2><p><strong>描述</strong>：<br />用户表： <code>Users</code><br />±------------±--------+<br />| Column Name | Type    |<br />±------------±--------+<br />| user_id     | int     |<br />| user_name   | varchar |<br />±------------±--------+<br />user_id 是该表的主键(具有唯一值的列)。<br />该表中的每行包括用户 ID 和用户名。<br />注册表： <code>Register</code><br />±------------±--------+<br />| Column Name | Type    |<br />±------------±--------+<br />| contest_id  | int     |<br />| user_id     | int     |<br />±------------±--------+<br />(contest_id, user_id) 是该表的主键(具有唯一值的列的组合)。<br />该表中的每行包含用户的 ID 和他们注册的赛事。<br />编写解决方案统计出各赛事的用户注册百分率，保留两位小数。<br />返回的结果表按 <code>percentage</code> 的 <strong>降序</strong> 排序，若相同则按 <code>contest_id</code> 的 <strong>升序</strong> 排序。</p><h2 id="解题思路"><a class="markdownIt-Anchor" href="#解题思路"></a> 💻 解题思路</h2><h3 id="思路1子查询"><a class="markdownIt-Anchor" href="#思路1子查询"></a> 思路1：子查询</h3><h4 id="思路1代码实现"><a class="markdownIt-Anchor" href="#思路1代码实现"></a> 思路1：代码实现</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># Write your MySQL query statement below</span><br><span class="line"><span class="keyword">SELECT</span> contest_id,</span><br><span class="line">ROUND(<span class="built_in">COUNT</span>(<span class="operator">*</span>)<span class="operator">*</span><span class="number">100.0</span><span class="operator">/</span></span><br><span class="line">(<span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>)</span><br><span class="line"><span class="keyword">FROM</span> Users )</span><br><span class="line">,<span class="number">2</span>)<span class="keyword">AS</span> percentage</span><br><span class="line"><span class="keyword">FROM</span> Register</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> contest_id</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> percentage <span class="keyword">DESC</span>,contest_id</span><br></pre></td></tr></table></figure><h4 id="思路1-性能分析"><a class="markdownIt-Anchor" href="#思路1-性能分析"></a> 思路1：📊 性能分析</h4><h5 id="提交结果"><a class="markdownIt-Anchor" href="#提交结果"></a> 提交结果</h5><ul><li><strong>运行时间</strong>：1287ms击败76.16%</li></ul><h4 id="思考"><a class="markdownIt-Anchor" href="#思考"></a> 思考</h4><p>分别查询行数相除即可</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="作业练习" scheme="https://id-zy.github.io/categories/%E4%BD%9C%E4%B8%9A%E7%BB%83%E4%B9%A0/"/>
    
    
    <category term="LeetCode" scheme="https://id-zy.github.io/tags/LeetCode/"/>
    
  </entry>
  
</feed>
