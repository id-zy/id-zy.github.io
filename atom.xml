<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>笺札</title>
  
  
  <link href="https://id-zy.github.io/atom.xml" rel="self"/>
  
  <link href="https://id-zy.github.io/"/>
  <updated>2025-12-05T12:40:12.107Z</updated>
  <id>https://id-zy.github.io/</id>
  
  <author>
    <name>zhaoyuan</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>链栈</title>
    <link href="https://id-zy.github.io/2025/12/17/%E9%93%BE%E6%A0%88/"/>
    <id>https://id-zy.github.io/2025/12/17/%E9%93%BE%E6%A0%88/</id>
    <published>2025-12-17T15:20:58.091Z</published>
    <updated>2025-12-05T12:40:12.107Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="链栈"><a class="markdownIt-Anchor" href="#链栈"></a> 链栈</h1><h2 id="基本概念"><a class="markdownIt-Anchor" href="#基本概念"></a> 基本概念</h2><h2 id="数据结构的三要素"><a class="markdownIt-Anchor" href="#数据结构的三要素"></a> 数据结构的三要素</h2><ul><li>逻辑结构<ul><li>线性结构</li></ul></li><li>存储结构<ul><li>链式存储</li></ul></li><li>数据的运算</li></ul><h3 id="费曼理解"><a class="markdownIt-Anchor" href="#费曼理解"></a> 费曼理解</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">栈结构：</span><br><span class="line">头指针L → [栈顶节点] → [节点2] → ... → [栈底节点] → NULL</span><br></pre></td></tr></table></figure><p>就像编绳结一样，一个节点一个结从右往左遍就得从左往右解</p><h2 id="内部实现"><a class="markdownIt-Anchor" href="#内部实现"></a> 内部实现：</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Linknode</span>&#123;</span></span><br><span class="line">ElemType data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Linknode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;*LiStack</span><br></pre></td></tr></table></figure><h2 id="复杂度分析"><a class="markdownIt-Anchor" href="#复杂度分析"></a> 复杂度分析：</h2><h3 id="初始化"><a class="markdownIt-Anchor" href="#初始化"></a> 初始化</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">InitStack</span><span class="params">(LiStack &amp;L)</span>&#123;</span><br><span class="line">L= new Linknode;</span><br><span class="line">L-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="判断栈空"><a class="markdownIt-Anchor" href="#判断栈空"></a> 判断栈空</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">isEmpty</span><span class="params">(LiStack &amp;L)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(L-next==<span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="入栈"><a class="markdownIt-Anchor" href="#入栈"></a> 入栈</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Push</span><span class="params">(LiStack &amp;L,ElemType e)</span>&#123;</span><br><span class="line">Linknode s;</span><br><span class="line">s =new Linknode;</span><br><span class="line">s-&gt;data=e;</span><br><span class="line">s-next=L-&gt;next;</span><br><span class="line">L-&gt;next=s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="复杂度分析-2"><a class="markdownIt-Anchor" href="#复杂度分析-2"></a> 复杂度分析</h4><ul><li>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></li><li>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></li></ul><h3 id="出栈"><a class="markdownIt-Anchor" href="#出栈"></a> 出栈</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">Pop</span><span class="params">(LiStack &amp;L,ElemType &amp;e)</span>&#123;</span><br><span class="line">Linknode s;</span><br><span class="line"><span class="keyword">if</span> <span class="title function_">isEmpty</span><span class="params">(L)</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">s=L-&gt;next;</span><br><span class="line">e=s-&gt;data;</span><br><span class="line">L-&gt;next=L-&gt;next-&gt;next;</span><br><span class="line">delete(s);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="复杂度分析-3"><a class="markdownIt-Anchor" href="#复杂度分析-3"></a> 复杂度分析</h4><ul><li>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></li><li>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></li></ul><h2 id="应用场景"><a class="markdownIt-Anchor" href="#应用场景"></a> 应用场景：</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="数据结构" scheme="https://id-zy.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>快速排序</title>
    <link href="https://id-zy.github.io/2025/12/17/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
    <id>https://id-zy.github.io/2025/12/17/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</id>
    <published>2025-12-17T15:20:20.675Z</published>
    <updated>2025-12-17T01:47:27.074Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="快速排序"><a class="markdownIt-Anchor" href="#快速排序"></a> 快速排序</h1><h2 id="基本概念"><a class="markdownIt-Anchor" href="#基本概念"></a> 基本概念</h2><p><strong>快速排序（Quick Sort）基本思想</strong>：<br />采用分治策略，选择一个基准元素，将数组分为两部分：小于基准的元素放在左侧，大于基准的元素放在右侧。然后递归地对左右两部分进行排序，最终得到有序数组。</p><h2 id="算法步骤"><a class="markdownIt-Anchor" href="#算法步骤"></a> 算法步骤</h2><p>快速排序的核心是 <strong>分区操作</strong>，具体步骤如下：</p><ol><li><strong>选择基准</strong>：从数组中选择一个元素作为基准值（通常选择第一个元素）</li><li><strong>分区操作</strong>：<ul><li>使用双指针法，左指针从数组开始，右指针从数组末尾</li><li>右指针向左移动，找到第一个小于基准值的元素</li><li>左指针向右移动，找到第一个大于基准值的元素</li><li>交换这两个元素</li><li>重复上述过程，直到左右指针相遇</li><li>将基准值放到正确位置（左右指针相遇处）</li></ul></li><li><strong>递归排序</strong>：对基准值左右的两个子数组分别进行快速排序</li></ol><h2 id="内部实现"><a class="markdownIt-Anchor" href="#内部实现"></a> 内部实现：</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">randomPartition</span>(<span class="params">self,nums:[<span class="built_in">int</span>],low:<span class="built_in">int</span>,high:<span class="built_in">int</span></span>)-&gt;<span class="built_in">int</span>:</span><br><span class="line">i=random.randint(low,high)</span><br><span class="line">nums[low],nums[i]=nums[i],nums[low]</span><br><span class="line"><span class="keyword">return</span> <span class="variable language_">self</span>.partition(nums,low,high)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">partition</span>(<span class="params">self,nums:[<span class="built_in">int</span>],low:<span class="built_in">int</span>,high,<span class="built_in">int</span></span>)-&gt;<span class="built_in">int</span>:</span><br><span class="line">pivot=nums[low]</span><br><span class="line">i,j=low,high</span><br><span class="line"><span class="keyword">while</span> i&lt;j:</span><br><span class="line"><span class="keyword">while</span> i&lt;j <span class="keyword">and</span> nums[j]&gt;=pivot:</span><br><span class="line">j-=<span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> i&lt;j <span class="keyword">and</span> nums[i]&lt;=pivot:</span><br><span class="line">i+=<span class="number">1</span></span><br><span class="line">nums[i],nums[j]=nums[j],nums[i]</span><br><span class="line">nums[i],nums[low]=nums[low],nums[i]</span><br><span class="line"><span class="keyword">return</span> i</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">quicksort</span>(<span class="params">self,nums:[<span class="built_in">int</span>],low:<span class="built_in">int</span>,high:<span class="built_in">int</span></span>)-&gt;[<span class="built_in">int</span>]:</span><br><span class="line"><span class="keyword">if</span> low&lt;high:</span><br><span class="line">pivot_i=<span class="variable language_">self</span>.randomPartition(nums,low,high)</span><br><span class="line"><span class="variable language_">self</span>.quicksort(nums,low,pivot_i-<span class="number">1</span>)</span><br><span class="line"><span class="variable language_">self</span>.quicksort(nums,pivot_i+<span class="number">1</span>,high)</span><br><span class="line"><span class="keyword">return</span> nums</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sortArray</span>(<span class="params">self,nums:[<span class="built_in">int</span>]</span>)-&gt;[<span class="built_in">int</span>]:</span><br><span class="line"><span class="keyword">return</span> <span class="variable language_">self</span>.quicksort(nums,<span class="number">0</span>,<span class="built_in">len</span>(nums)-<span class="number">1</span>)</span><br></pre></td></tr></table></figure><h2 id="复杂度分析"><a class="markdownIt-Anchor" href="#复杂度分析"></a> 复杂度分析：</h2><table><thead><tr><th>指标</th><th>复杂度</th><th>说明</th></tr></thead><tbody><tr><td><strong>最佳时间复杂度</strong></td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mtext>⁡</mtext><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(nlog⁡n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord">⁡</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></td><td>每次都能将数组平均分成两半</td></tr><tr><td><strong>最坏时间复杂度</strong></td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></td><td>每次选择的基准值都是极值（如已排序数组）</td></tr><tr><td><strong>平均时间复杂度</strong></td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mtext>⁡</mtext><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(nlog⁡n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord">⁡</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></td><td>随机选择基准值时的期望复杂度</td></tr><tr><td><strong>空间复杂度</strong></td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mtext>⁡</mtext><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(log⁡n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord">⁡</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></td><td>递归栈空间，最坏情况下为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></td></tr><tr><td><strong>稳定性</strong></td><td>不稳定</td><td>交换操作可能改变相等元素的相对位置</td></tr></tbody></table><p><strong>适用场景</strong>：</p><ul><li>大规模数据排序（n≥1000）</li><li>对平均性能要求高的场景</li><li>数据分布相对均匀的情况</li></ul><p><strong>优化策略</strong>：</p><ul><li><p>随机选择基准值，避免最坏情况</p></li><li><p>三数取中法选择基准值</p></li><li><p>小数组使用插入排序</p></li><li><p>处理重复元素时使用三路快排<br />快速排序是一种高效的排序算法，采用分治策略，通过分区操作将数组分成两部分，然后递归排序。</p></li><li><p><strong>优点</strong>：</p><ul><li>平均情况下效率高，时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mtext>⁡</mtext><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(nlog⁡n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord">⁡</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></li><li>原地排序，空间复杂度低</li><li>缓存友好，局部性良好</li><li>实际应用中常数因子较小</li></ul></li><li><p><strong>缺点</strong>：</p><ul><li>不稳定排序</li><li>最坏情况下性能较差，时间复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></li><li>对于小数组，其他算法可能更快</li><li>递归调用可能导致栈溢出</li></ul></li></ul><p>快速排序是许多编程语言内置排序函数的实现基础，在实际应用中非常广泛。通过合理的优化策略，可以显著提高其性能和稳定性。</p><h2 id="应用场景"><a class="markdownIt-Anchor" href="#应用场景"></a> 应用场景：</h2><ul><li>912<a href="%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84.md">排序数组</a><ul><li>问题描述：给你一个整数数组 <code>nums</code>，请你将该数组升序排列。</li><li>解决方案：快速排序即可</li></ul></li><li>169<a href="%E5%A4%9A%E6%95%B0%E5%85%83%E7%B4%A0.md">多数元素</a><ul><li>问题描述：寻找多数元素</li><li>解决方案：多数元素总是出现在已排序数组中间</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="数据结构" scheme="https://id-zy.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>归并排序</title>
    <link href="https://id-zy.github.io/2025/12/17/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
    <id>https://id-zy.github.io/2025/12/17/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</id>
    <published>2025-12-17T15:20:20.673Z</published>
    <updated>2025-12-16T12:22:37.225Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="归并排序"><a class="markdownIt-Anchor" href="#归并排序"></a> 归并排序</h1><h2 id="基本概念"><a class="markdownIt-Anchor" href="#基本概念"></a> 基本概念</h2><p><strong>归并排序（Merge Sort）基本思想</strong>：<br />利用分治法，将数组递归地一分为二，直至每个子数组只包含一个元素。随后，将这些有序子数组两两合并，最终得到一个整体有序的数组。</p><h2 id="算法步骤"><a class="markdownIt-Anchor" href="#算法步骤"></a> 算法步骤</h2><p>假设数组的元素个数为 n 个，则归并排序的算法步骤如下：</p><ol><li><strong>分解过程</strong>：递归地将当前数组平分为两部分，直到每个子数组只包含一个元素为止。<ol><li>找到数组的中间位置 mid，将数组划分为左、右两个子数组left_nums 和 right_nums。</li><li>分别对 left_nums 和 right_numsr递归执行分解操作。</li><li>最终将原数组拆分为 n 个长度为 1 的有序子数组。</li></ol></li><li><strong>归并过程</strong>：从长度为 1 的有序子数组开始，逐步将相邻的有序子数组两两合并，最终合并为一个长度为 n 的有序数组。<ol><li>新建数组 nums 用于存放合并后的有序结果。</li><li>设置两个指针 left_i 和 right_i，分别指向 left_nums 和 right_nums的起始位置。</li><li>比较两个指针所指元素，将较小者加入结果数组 numsnums，并将对应指针后移一位。</li><li>重复上述操作，直到某一指针到达对应子数组末尾。</li><li>将另一个子数组剩余的所有元素依次加入结果数组 nums。</li><li>返回合并后的有序数组 nums。</li></ol></li></ol><h2 id="内部实现"><a class="markdownIt-Anchor" href="#内部实现"></a> 内部实现：</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">solution</span>:</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">merge</span>(<span class="params">self,left_nums:[<span class="built_in">int</span>],right_nums:[<span class="built_in">int</span>]</span>):</span><br><span class="line">nums=[]</span><br><span class="line">left_i,right_i=<span class="number">0</span>,<span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> left_i &lt; <span class="built_in">len</span>(left_nums)<span class="keyword">and</span> right_i&lt;<span class="built_in">len</span>(right_nums):</span><br><span class="line"><span class="keyword">if</span> left_nums[left_i]&lt;=right_nums[right_i]:</span><br><span class="line">nums.append(left_nums[left_i])</span><br><span class="line">left_i+=<span class="number">1</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">nums.append(right_nums[right_i])</span><br><span class="line">right_i+=<span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> left_i &lt;<span class="built_in">len</span>(left_nums):</span><br><span class="line">nums.append(left_nums[left_i])</span><br><span class="line">left_i+=<span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> right_i &lt;<span class="built_in">len</span>(right_nums):</span><br><span class="line">nums.append(right_nums[right_i])</span><br><span class="line">right_i+=<span class="number">1</span></span><br><span class="line"><span class="keyword">return</span> nums</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">mergesort</span>(<span class="params">self,nums:[<span class="built_in">int</span>]</span>)-&gt;[<span class="built_in">int</span>]:</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(nums)&lt;=<span class="number">1</span>:</span><br><span class="line"><span class="keyword">return</span> nums</span><br><span class="line">mid = <span class="built_in">len</span>(nums)//<span class="number">2</span></span><br><span class="line">left_nums=<span class="variable language_">self</span>.mergesort(nums[<span class="number">0</span>:mid])</span><br><span class="line">right_nums=<span class="variable language_">self</span>.mergesort(nums[mid:])</span><br><span class="line"><span class="keyword">return</span> <span class="variable language_">self</span>.merge(left_nums,right_nums)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sortrray</span>(<span class="params">self,nums:[<span class="built_in">int</span>]</span>)-&gt;[<span class="built_in">int</span>]:</span><br><span class="line"><span class="keyword">return</span> <span class="variable language_">self</span>.mergesort(nums)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="复杂度分析"><a class="markdownIt-Anchor" href="#复杂度分析"></a> 复杂度分析：</h2><table><thead><tr><th>指标</th><th>复杂度</th><th>说明</th></tr></thead><tbody><tr><td><strong>最佳时间复杂度</strong></td><td>O(nlog⁡n)</td><td>无论数组状态如何，都需要 log⁡n 次分解和 n 次合并</td></tr><tr><td><strong>最坏时间复杂度</strong></td><td>O(nlog⁡n)</td><td>无论数组状态如何，都需要 log⁡n次分解和 n 次合并</td></tr><tr><td><strong>平均时间复杂度</strong></td><td>O(nlog⁡n)</td><td>归并排序的时间复杂度与数据状态无关</td></tr><tr><td><strong>空间复杂度</strong></td><td>O(n)</td><td>需要额外的辅助数组来存储合并结果</td></tr><tr><td><strong>稳定性</strong></td><td>稳定</td><td>合并过程中相等元素的相对顺序保持不变</td></tr><tr><td><strong>补充说明：</strong></td><td></td><td></td></tr></tbody></table><ul><li>归并排序采用分治策略，将数组递归地分成两半，每次分解的时间复杂度为 O(1)，分解次数为logn。</li><li>合并过程的时间复杂度为 O(n)，因为需要遍历两个子数组的所有元素。</li><li>总的时间复杂度为 O(nlogn)，这是基于比较的排序算法的理论下界。</li></ul><p><strong>适用场景：</strong></p><ul><li>大规模数据排序（n&gt;1000）</li><li>对稳定性有要求的场景</li><li>外部排序（数据无法全部加载到内存）</li><li>链表排序<br />归并排序是一种高效稳定的排序算法，采用分治策略将数组递归分解后合并排序。</li><li><strong>优点</strong>：<ul><li>时间复杂度稳定，始终为 O(nlogn)</li><li>稳定排序，相等元素相对位置不变</li><li>适合大规模数据排序</li><li>可用于外部排序和链表排序</li></ul></li><li><strong>缺点</strong>：<ul><li>空间复杂度较高，需要 O(n) 额外空间</li><li>对于小规模数据，常数因子较大</li><li>不是原地排序算法</li></ul></li></ul><h2 id="应用场景"><a class="markdownIt-Anchor" href="#应用场景"></a> 应用场景：</h2><ul><li>912<a href="%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84.md">排序数组</a><ul><li>问题描述：给你一个整数数组 <code>nums</code>，请你将该数组升序排列。</li><li>解决方案：归并排序即可</li></ul></li><li>88<a href="%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84.md">合并两个有序数组</a><ul><li>问题描述：请你 <strong>合并</strong> <code>nums2</code> 到 <code>nums1</code> 中，使合并后的数组同样按 <strong>非递减顺序</strong> 排列。</li><li>解决方案：仿照归并排序的思想合并</li></ul></li><li>LCR170<a href="%E4%BA%A4%E6%98%93%E9%80%86%E5%BA%8F%E5%AF%B9%E7%9A%84%E6%80%BB%E6%95%B0.md">交易逆序对的总数</a><ul><li>问题描述：设计一个程序，输入一段时间内的股票交易记录 <code>record</code>，返回其中存在的「交易逆序对」总数。</li><li>解决方案：归并排序合并数组过程统计逆序对数量</li></ul></li><li>315<a href="%E8%AE%A1%E7%AE%97%E5%8F%B3%E4%BE%A7%E5%B0%8F%E4%BA%8E%E5%BD%93%E5%89%8D%E5%85%83%E7%B4%A0%E7%9A%84%E4%B8%AA%E6%95%B0.md">计算右侧小于当前元素的个数</a><ul><li>问题描述：按要求返回一个新数组 <code>counts</code> 。数组 <code>counts</code> 有该性质： <code>counts[i]</code> 的值是  <code>nums[i]</code> 右侧小于 <code>nums[i]</code> 的元素的数量。</li><li>解决方案：归并过程实际上已经在对逆序对小于数计数了，我们只需要在过程将其记录即可</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="数据结构" scheme="https://id-zy.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>希尔排序</title>
    <link href="https://id-zy.github.io/2025/12/17/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/"/>
    <id>https://id-zy.github.io/2025/12/17/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/</id>
    <published>2025-12-17T15:20:20.662Z</published>
    <updated>2025-12-13T09:15:49.345Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="希尔排序"><a class="markdownIt-Anchor" href="#希尔排序"></a> 希尔排序</h1><h2 id="基本概念"><a class="markdownIt-Anchor" href="#基本概念"></a> 基本概念</h2><p><strong>希尔排序（Shell Sort）基本思想</strong>：<br />通过设定不同的间隔（gap），将数组分组进行插入排序，然后逐步缩小间隔直至为 11，最终完成整个数组的排序。</p><h2 id="算法实现步骤"><a class="markdownIt-Anchor" href="#算法实现步骤"></a> 算法实现步骤</h2><p>假设数组长度为 n，算法步骤如下：</p><ol><li>设定初始间隔 <code>gap = n / 2</code>。</li><li>按间隔将数组分组，对每组进行插入排序。</li><li>缩小间隔 <code>gap = gap / 2</code>。</li><li>重复步骤 2∼3，直到 <code>gap = 1</code>。</li><li>最后对整个数组进行一次插入排序。</li></ol><h3 id="费曼理解"><a class="markdownIt-Anchor" href="#费曼理解"></a> 费曼理解</h3><h2 id="内部实现"><a class="markdownIt-Anchor" href="#内部实现"></a> 内部实现：</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">solution</span>:</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">shellsort</span>(<span class="params">self,nums:[<span class="built_in">int</span>]</span>)-&gt;[<span class="built_in">int</span>]:</span><br><span class="line">size=<span class="built_in">len</span>(nums)</span><br><span class="line">gap=size//<span class="number">2</span></span><br><span class="line"><span class="keyword">while</span> gap&gt;<span class="number">0</span>:</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(gap,size):</span><br><span class="line">temp=nums[i]</span><br><span class="line">j=i</span><br><span class="line"><span class="keyword">while</span> j&gt;=gap <span class="keyword">and</span> nums[j-gap]&gt;temp:</span><br><span class="line">nums[j]=nums[j-gap]</span><br><span class="line">j-=gap</span><br><span class="line">nums[j]=temp</span><br><span class="line">gap//=<span class="number">2</span></span><br><span class="line"><span class="keyword">return</span> nums</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sortarray</span>(<span class="params">self,nums:[<span class="built_in">int</span>]</span>)-&gt;[<span class="built_in">int</span>]:</span><br><span class="line"><span class="keyword">return</span> <span class="variable language_">self</span>.shellsort(nums)</span><br></pre></td></tr></table></figure><h2 id="复杂度分析"><a class="markdownIt-Anchor" href="#复杂度分析"></a> 复杂度分析：</h2><table><thead><tr><th>指标</th><th>复杂度</th><th>说明</th></tr></thead><tbody><tr><td><strong>最佳时间复杂度</strong></td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></td><td>当数组已有序时</td></tr><tr><td><strong>最坏时间复杂度</strong></td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></td><td>使用普通间隔序列时</td></tr><tr><td><strong>平均时间复杂度</strong></td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>1.3</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^{1.3})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">.</span><span class="mord mtight">3</span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>~ <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>1.5</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^{1.5})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">.</span><span class="mord mtight">5</span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></td><td>取决于间隔序列选择，如果选取得当接近于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mtext>⁡</mtext><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(nlog⁡n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord">⁡</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></td></tr><tr><td><strong>空间复杂度</strong></td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></td><td>原地排序，只使用常数空间</td></tr><tr><td><strong>稳定性</strong></td><td>不稳定</td><td>不同组间的相等元素可能改变相对顺序</td></tr><tr><td><strong>补充说明：</strong></td><td></td><td></td></tr></tbody></table><ul><li>希尔排序的时间复杂度高度依赖于间隔序列的选择。</li><li>当采用常见的 <code>gap = gap // 2</code> 间隔序列时，排序过程大约需要 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>o</mi><mi>g</mi><mtext>⁡</mtext><mn>2</mn><mi>n</mi></mrow><annotation encoding="application/x-tex">log⁡2n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord">⁡</span><span class="mord">2</span><span class="mord mathnormal">n</span></span></span></span> 趟，每一趟的操作类似于分组插入排序。</li><li>每一趟的排序时间复杂度约为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，但随着 gap 的减小，实际操作次数逐步减少。</li><li>综合来看，希尔排序的整体时间复杂度通常介于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mtext>⁡</mtext><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(nlog⁡n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord">⁡</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 之间，如果间隔序列选择得当，性能可接近 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mtext>⁡</mtext><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(nlog⁡n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord">⁡</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>。<br /><strong>适用场景</strong>：</li><li>中等规模数据（50≤n≤1000）</li><li>对插入排序的改进需求</li><li>对稳定性要求不高的场景<br />希尔排序是插入排序的改进版本，通过分组排序减少数据移动次数，提高排序效率。</li><li><strong>优点</strong>：比插入排序更快，空间复杂度低，适合中等规模数据</li><li><strong>缺点</strong>：时间复杂度不稳定，不稳定排序，间隔序列选择影响性能</li></ul><h2 id="应用场景"><a class="markdownIt-Anchor" href="#应用场景"></a> 应用场景：</h2><ul><li>912<a href="%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84.md">排序数组</a><ul><li>问题描述：给你一个整数数组 <code>nums</code>，请你将该数组升序排列。</li><li>解决方案：实现一遍希尔排序即可</li></ul></li><li>506<a href="%E7%9B%B8%E5%AF%B9%E5%90%8D%E6%AC%A1.md">相对名次</a><ul><li>问题描述：使用长度为 <code>n</code> 的数组 <code>answer</code> 返回获奖，其中 <code>answer[i]</code> 是第 <code>i</code> 位运动员的获奖情况。</li><li>解决方案：使用希尔排序后再建立索引与值的关系</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="数据结构" scheme="https://id-zy.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>多数元素-LeetCode</title>
    <link href="https://id-zy.github.io/2025/12/17/%E5%A4%9A%E6%95%B0%E5%85%83%E7%B4%A0/"/>
    <id>https://id-zy.github.io/2025/12/17/%E5%A4%9A%E6%95%B0%E5%85%83%E7%B4%A0/</id>
    <published>2025-12-16T16:00:00.000Z</published>
    <updated>2025-12-17T01:45:36.856Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="多数元素"><a class="markdownIt-Anchor" href="#多数元素"></a> 多数元素</h1><h2 id="问题描述来源于leetcode"><a class="markdownIt-Anchor" href="#问题描述来源于leetcode"></a> 🎯 问题描述（来源于LeetCode）</h2><p><strong>描述</strong>：<br />给定一个大小为 <code>n</code> 的数组 <code>nums</code> ，返回其中的多数元素。多数元素是指在数组中出现次数 <strong>大于</strong> <code>⌊ n/2 ⌋</code> 的元素。<br />你可以假设数组是非空的，并且给定的数组总是存在多数元素。<br /><strong>说明</strong>：</p><ul><li><code>n == nums.length</code></li><li><code>1 &lt;= n &lt;= 5 * 104</code></li><li><code>-109 &lt;= nums[i] &lt;= 109</code></li><li>输入保证数组中一定有一个多数元素。</li></ul><p><strong>示例</strong>：</p><ul><li>示例 1：</li></ul><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [3,2,3]</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure><ul><li>示例 2：</li></ul><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [2,2,1,1,1,2,2]</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure><h2 id="解题思路"><a class="markdownIt-Anchor" href="#解题思路"></a> 💻 解题思路</h2><h3 id="思路1快速排序"><a class="markdownIt-Anchor" href="#思路1快速排序"></a> 思路1：快速排序</h3><h4 id="思路1代码实现"><a class="markdownIt-Anchor" href="#思路1代码实现"></a> 思路1：代码实现</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">majorityElement</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        nums.sort()</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="built_in">len</span>(nums)//<span class="number">2</span>]</span><br></pre></td></tr></table></figure><h4 id="思路1-性能分析"><a class="markdownIt-Anchor" href="#思路1-性能分析"></a> 思路1：📊 性能分析</h4><h5 id="提交结果"><a class="markdownIt-Anchor" href="#提交结果"></a> 提交结果</h5><ul><li><strong>运行时间</strong>：0ms击败100.00%</li><li><strong>内存消耗</strong>：19.10MB击败26.44%</li></ul><h5 id="复杂度验证"><a class="markdownIt-Anchor" href="#复杂度验证"></a> 复杂度验证</h5><ul><li>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(Nlogn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></li><li>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></li></ul><h4 id="思考"><a class="markdownIt-Anchor" href="#思考"></a> 思考</h4><p>众数一定会出现在排序后的数组中间</p><h3 id="思路2哈希表"><a class="markdownIt-Anchor" href="#思路2哈希表"></a> 思路2：哈希表</h3><h4 id="思路2代码实现"><a class="markdownIt-Anchor" href="#思路2代码实现"></a> 思路2：代码实现</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">majorityElement</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        arr= defaultdict(<span class="built_in">int</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">            arr[i]+=<span class="number">1</span></span><br><span class="line">        n=<span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">for</span> i,count <span class="keyword">in</span> arr.items():</span><br><span class="line">            <span class="keyword">if</span> count&gt;n//<span class="number">2</span>:</span><br><span class="line">                <span class="keyword">return</span> i</span><br></pre></td></tr></table></figure><h4 id="思路2-性能分析"><a class="markdownIt-Anchor" href="#思路2-性能分析"></a> 思路2：📊 性能分析</h4><h5 id="提交结果-2"><a class="markdownIt-Anchor" href="#提交结果-2"></a> 提交结果</h5><ul><li><strong>运行时间</strong>：7ms击败52.43%</li><li><strong>内存消耗</strong>：18.99MB击败59.30%</li></ul><h5 id="复杂度验证-2"><a class="markdownIt-Anchor" href="#复杂度验证-2"></a> 复杂度验证</h5><ul><li>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span></li><li>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span></li></ul><h4 id="思考-2"><a class="markdownIt-Anchor" href="#思考-2"></a> 思考</h4><p>哈希表统计数字出现个数</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="作业练习" scheme="https://id-zy.github.io/categories/%E4%BD%9C%E4%B8%9A%E7%BB%83%E4%B9%A0/"/>
    
    
    <category term="LeetCode" scheme="https://id-zy.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>计算右侧小于当前元素的个数-LeetCode</title>
    <link href="https://id-zy.github.io/2025/12/16/%E8%AE%A1%E7%AE%97%E5%8F%B3%E4%BE%A7%E5%B0%8F%E4%BA%8E%E5%BD%93%E5%89%8D%E5%85%83%E7%B4%A0%E7%9A%84%E4%B8%AA%E6%95%B0/"/>
    <id>https://id-zy.github.io/2025/12/16/%E8%AE%A1%E7%AE%97%E5%8F%B3%E4%BE%A7%E5%B0%8F%E4%BA%8E%E5%BD%93%E5%89%8D%E5%85%83%E7%B4%A0%E7%9A%84%E4%B8%AA%E6%95%B0/</id>
    <published>2025-12-15T16:00:00.000Z</published>
    <updated>2025-12-16T12:21:54.936Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="计算右侧小于当前元素的个数"><a class="markdownIt-Anchor" href="#计算右侧小于当前元素的个数"></a> 计算右侧小于当前元素的个数</h1><h2 id="问题描述来源于leetcode"><a class="markdownIt-Anchor" href="#问题描述来源于leetcode"></a> 🎯 问题描述（来源于LeetCode）</h2><p><strong>描述</strong>：<br />给你一个整数数组 <code>nums</code> ，按要求返回一个新数组 <code>counts</code> 。数组 <code>counts</code> 有该性质： <code>counts[i]</code> 的值是  <code>nums[i]</code> 右侧小于 <code>nums[i]</code> 的元素的数量。<br /><strong>说明</strong>：</p><ul><li><p><code>1 &lt;= nums.length &lt;= 105</code></p></li><li><p><code>-104 &lt;= nums[i] &lt;= 104</code><br /><strong>示例</strong>：</p></li><li><p>示例 1：</p></li></ul><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [5,2,6,1]</span><br><span class="line">输出：[2,1,1,0]  </span><br><span class="line">解释：</span><br><span class="line">5 的右侧有 2 个更小的元素 (2 和 1)</span><br><span class="line">2 的右侧仅有 1 个更小的元素 (1)</span><br><span class="line">6 的右侧有1个更小的元素 (1)</span><br><span class="line">1 的右侧有0个更小的元素</span><br></pre></td></tr></table></figure><ul><li>示例 2：</li></ul><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [-1]</span><br><span class="line">输出：[0]</span><br></pre></td></tr></table></figure><h2 id="解题思路"><a class="markdownIt-Anchor" href="#解题思路"></a> 💻 解题思路</h2><h3 id="思路1在归并过程中计数"><a class="markdownIt-Anchor" href="#思路1在归并过程中计数"></a> 思路1：在归并过程中计数</h3><h4 id="思路1代码实现"><a class="markdownIt-Anchor" href="#思路1代码实现"></a> 思路1：代码实现</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">countSmaller</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        ans = [<span class="number">0</span>] * n        </span><br><span class="line">        arr = [(nums[i], i) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">merge_sort</span>(<span class="params">arr, left, right</span>):</span><br><span class="line">            <span class="keyword">if</span> left &gt;= right:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            mid = (left + right) // <span class="number">2</span></span><br><span class="line">            merge_sort(arr, left, mid)</span><br><span class="line">            merge_sort(arr, mid + <span class="number">1</span>, right)</span><br><span class="line">            merge(arr, left, mid, right)</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">merge</span>(<span class="params">arr, left, mid, right</span>):</span><br><span class="line">            temp = []</span><br><span class="line">            i, j = left, mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> i &lt;= mid <span class="keyword">and</span> j &lt;= right:</span><br><span class="line">                <span class="keyword">if</span> arr[i][<span class="number">0</span>] &lt;= arr[j][<span class="number">0</span>]:</span><br><span class="line">                    ans[arr[i][<span class="number">1</span>]] += (j - (mid + <span class="number">1</span>))</span><br><span class="line">                    temp.append(arr[i])</span><br><span class="line">                    i += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    temp.append(arr[j])</span><br><span class="line">                    j += <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> i &lt;= mid:</span><br><span class="line">                ans[arr[i][<span class="number">1</span>]] += (j - (mid + <span class="number">1</span>))</span><br><span class="line">                temp.append(arr[i])</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> j &lt;= right:</span><br><span class="line">                temp.append(arr[j])</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(left, right + <span class="number">1</span>):</span><br><span class="line">                arr[k] = temp[k - left]</span><br><span class="line">        </span><br><span class="line">        merge_sort(arr, <span class="number">0</span>, n - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><h4 id="思路1-性能分析"><a class="markdownIt-Anchor" href="#思路1-性能分析"></a> 思路1：📊 性能分析</h4><h5 id="提交结果"><a class="markdownIt-Anchor" href="#提交结果"></a> 提交结果</h5><ul><li><strong>运行时间</strong>：1459ms击败39.86%</li><li><strong>内存消耗</strong>：47.17MB击败36.36%</li></ul><h5 id="复杂度验证"><a class="markdownIt-Anchor" href="#复杂度验证"></a> 复杂度验证</h5><ul><li>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mi>L</mi><mi>o</mi><mi>g</mi><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(NLogN)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mord mathnormal">L</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span></li><li>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span></li></ul><h4 id="思考"><a class="markdownIt-Anchor" href="#思考"></a> 思考</h4><p>归并过程实际上已经在对逆序对小于数计数了，我们只需要在过程将其记录即可</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="作业练习" scheme="https://id-zy.github.io/categories/%E4%BD%9C%E4%B8%9A%E7%BB%83%E4%B9%A0/"/>
    
    
    <category term="LeetCode" scheme="https://id-zy.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>交易逆序对的总数-LeetCode</title>
    <link href="https://id-zy.github.io/2025/12/15/%E4%BA%A4%E6%98%93%E9%80%86%E5%BA%8F%E5%AF%B9%E7%9A%84%E6%80%BB%E6%95%B0/"/>
    <id>https://id-zy.github.io/2025/12/15/%E4%BA%A4%E6%98%93%E9%80%86%E5%BA%8F%E5%AF%B9%E7%9A%84%E6%80%BB%E6%95%B0/</id>
    <published>2025-12-14T16:00:00.000Z</published>
    <updated>2025-12-15T07:57:10.094Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="交易逆序对的总数"><a class="markdownIt-Anchor" href="#交易逆序对的总数"></a> 交易逆序对的总数</h1><h2 id="问题描述来源于leetcode"><a class="markdownIt-Anchor" href="#问题描述来源于leetcode"></a> 🎯 问题描述（来源于LeetCode）</h2><p><strong>描述</strong>：<br />在股票交易中，如果前一天的股价高于后一天的股价，则可以认为存在一个「交易逆序对」。请设计一个程序，输入一段时间内的股票交易记录 <code>record</code>，返回其中存在的「交易逆序对」总数。<br /><strong>说明</strong>：</p><ul><li>0 &lt;= record.length &lt;= 50000</li></ul><p><strong>示例</strong>：</p><ul><li>示例 1：</li></ul><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：record = [9, 7, 5, 4, 6]</span><br><span class="line">输出：8</span><br><span class="line">解释：交易中的逆序对为 (9, 7), (9, 5), (9, 4), (9, 6), (7, 5), (7, 4), (7, 6), (5, 4)。</span><br></pre></td></tr></table></figure><h2 id="解题思路"><a class="markdownIt-Anchor" href="#解题思路"></a> 💻 解题思路</h2><h3 id="思路1暴力破解"><a class="markdownIt-Anchor" href="#思路1暴力破解"></a> 思路1：暴力破解</h3><h4 id="思路1代码实现"><a class="markdownIt-Anchor" href="#思路1代码实现"></a> 思路1：代码实现</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reversePairs</span>(<span class="params">self, record: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        i=count=<span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i&lt;<span class="built_in">len</span>(record):</span><br><span class="line">            <span class="keyword">for</span> d <span class="keyword">in</span> <span class="built_in">range</span>(i,<span class="built_in">len</span>(record)):</span><br><span class="line">                <span class="keyword">if</span> record[i]&gt;record[d]:</span><br><span class="line">                    count+=<span class="number">1</span></span><br><span class="line">            i+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure><h4 id="思路1-性能分析"><a class="markdownIt-Anchor" href="#思路1-性能分析"></a> 思路1：📊 性能分析</h4><h5 id="提交结果"><a class="markdownIt-Anchor" href="#提交结果"></a> 提交结果</h5><ul><li><strong>运行时间</strong>：超时</li><li><strong>内存消耗</strong>：</li></ul><h5 id="复杂度验证"><a class="markdownIt-Anchor" href="#复杂度验证"></a> 复杂度验证</h5><ul><li>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>N</mi><mn>2</mn></msup><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N^2))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></li><li>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></li></ul><h3 id="思路2归并"><a class="markdownIt-Anchor" href="#思路2归并"></a> 思路2：归并</h3><h4 id="思路2代码实现"><a class="markdownIt-Anchor" href="#思路2代码实现"></a> 思路2：代码实现</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reversePairs</span>(<span class="params">self, record: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.merge_sort(record)[<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">merge_sort</span>(<span class="params">self, nums</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nums) &lt;= <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> nums, <span class="number">0</span></span><br><span class="line">        mid = <span class="built_in">len</span>(nums) // <span class="number">2</span></span><br><span class="line">        left, left_count = <span class="variable language_">self</span>.merge_sort(nums[:mid])</span><br><span class="line">        right, right_count = <span class="variable language_">self</span>.merge_sort(nums[mid:])</span><br><span class="line">        </span><br><span class="line">        merged, merge_count = <span class="variable language_">self</span>.merge(left, right)</span><br><span class="line">        <span class="keyword">return</span> merged, left_count + right_count + merge_count</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">merge</span>(<span class="params">self, left, right</span>):</span><br><span class="line">        result = []</span><br><span class="line">        i = j = <span class="number">0</span></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(left) <span class="keyword">and</span> j &lt; <span class="built_in">len</span>(right):</span><br><span class="line">            <span class="keyword">if</span> left[i] &lt;= right[j]:</span><br><span class="line">                result.append(left[i])</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                result.append(right[j])</span><br><span class="line">                <span class="comment"># 计算逆序对</span></span><br><span class="line">                count += <span class="built_in">len</span>(left) - i</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        result.extend(left[i:])</span><br><span class="line">        result.extend(right[j:])</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result, count</span><br></pre></td></tr></table></figure><h4 id="思路2-性能分析"><a class="markdownIt-Anchor" href="#思路2-性能分析"></a> 思路2：📊 性能分析</h4><h5 id="提交结果-2"><a class="markdownIt-Anchor" href="#提交结果-2"></a> 提交结果</h5><ul><li><strong>运行时间</strong>：663ms击败57.22%</li><li><strong>内存消耗</strong>：23.94MB击败65.88%</li></ul><h5 id="复杂度验证-2"><a class="markdownIt-Anchor" href="#复杂度验证-2"></a> 复杂度验证</h5><ul><li>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(Nlogn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></li><li>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span></li></ul><h4 id="思考"><a class="markdownIt-Anchor" href="#思考"></a> 思考</h4>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="作业练习" scheme="https://id-zy.github.io/categories/%E4%BD%9C%E4%B8%9A%E7%BB%83%E4%B9%A0/"/>
    
    
    <category term="LeetCode" scheme="https://id-zy.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>合并两个有序数组-LeetCode</title>
    <link href="https://id-zy.github.io/2025/12/14/%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/"/>
    <id>https://id-zy.github.io/2025/12/14/%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/</id>
    <published>2025-12-13T16:00:00.000Z</published>
    <updated>2025-12-14T13:58:37.101Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="合并两个有序数组"><a class="markdownIt-Anchor" href="#合并两个有序数组"></a> 合并两个有序数组</h1><h2 id="问题描述来源于leetcode"><a class="markdownIt-Anchor" href="#问题描述来源于leetcode"></a> 🎯 问题描述（来源于LeetCode）</h2><p><strong>描述</strong>：<br />给你两个按 <strong>非递减顺序</strong> 排列的整数数组 <code>nums1</code> 和 <code>nums2</code>，另有两个整数 <code>m</code> 和 <code>n</code> ，分别表示 <code>nums1</code> 和 <code>nums2</code> 中的元素数目。<br />请你 <strong>合并</strong> <code>nums2</code> 到 <code>nums1</code> 中，使合并后的数组同样按 <strong>非递减顺序</strong> 排列。<br />注意：最终，合并后数组不应由函数返回，而是存储在数组 <code>nums1</code> 中。为了应对这种情况，<code>nums1</code> 的初始长度为 <code>m + n</code>，其中前 <code>m</code> 个元素表示应合并的元素，后 <code>n</code> 个元素为 <code>0</code> ，应忽略。<code>nums2</code> 的长度为 <code>n</code> 。</p><p><strong>说明</strong>：</p><ul><li><code>nums1.length == m + n</code></li><li><code>nums2.length == n</code></li><li><code>0 &lt;= m, n &lt;= 200</code></li><li><code>1 &lt;= m + n &lt;= 200</code></li><li><code>-109 &lt;= nums1[i], nums2[j] &lt;= 109</code></li></ul><p><strong>示例</strong>：</p><ul><li>示例 1：</li></ul><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [1], m = 1, nums2 = [], n = 0</span><br><span class="line">输出：[1]</span><br><span class="line">解释：需要合并 [1] 和 [] 。</span><br><span class="line">合并结果是 [1] 。</span><br></pre></td></tr></table></figure><ul><li>示例 2：</li></ul><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3</span><br><span class="line">输出：[1,2,2,3,5,6]</span><br><span class="line">解释：需要合并 [1,2,3] 和 [2,5,6] 。</span><br><span class="line">合并结果是 [1,2,2,3,5,6]</span><br></pre></td></tr></table></figure><h2 id="解题思路"><a class="markdownIt-Anchor" href="#解题思路"></a> 💻 解题思路</h2><h3 id="思路1归并排序"><a class="markdownIt-Anchor" href="#思路1归并排序"></a> 思路1：归并排序</h3><h4 id="思路1代码实现"><a class="markdownIt-Anchor" href="#思路1代码实现"></a> 思路1：代码实现</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">merge</span>(<span class="params">self, nums1: <span class="type">List</span>[<span class="built_in">int</span>], m: <span class="built_in">int</span>, nums2: <span class="type">List</span>[<span class="built_in">int</span>], n: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        nums1_copy = nums1[:m]</span><br><span class="line">        p1, p2, p = <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> p1 &lt; m <span class="keyword">and</span> p2 &lt; n:</span><br><span class="line">            <span class="keyword">if</span> nums1_copy[p1] &lt; nums2[p2]:</span><br><span class="line">                nums1[p] = nums1_copy[p1]</span><br><span class="line">                p1 += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                nums1[p] = nums2[p2]</span><br><span class="line">                p2 += <span class="number">1</span></span><br><span class="line">            p += <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> p1 &lt; m:</span><br><span class="line">            nums1[p] = nums1_copy[p1]</span><br><span class="line">            p1 += <span class="number">1</span></span><br><span class="line">            p += <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> p2 &lt; n:</span><br><span class="line">            nums1[p] = nums2[p2]</span><br><span class="line">            p2 += <span class="number">1</span></span><br><span class="line">            p += <span class="number">1</span></span><br></pre></td></tr></table></figure><h4 id="思路1-性能分析"><a class="markdownIt-Anchor" href="#思路1-性能分析"></a> 思路1：📊 性能分析</h4><h5 id="提交结果"><a class="markdownIt-Anchor" href="#提交结果"></a> 提交结果</h5><ul><li><strong>运行时间</strong>：0ms击败100.00%</li><li><strong>内存消耗</strong>：17.77MB击败5.23%</li></ul><h5 id="复杂度验证"><a class="markdownIt-Anchor" href="#复杂度验证"></a> 复杂度验证</h5><ul><li>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>M</mi><mo>+</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(M+N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span></li><li>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>M</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(M)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mclose">)</span></span></span></span></li></ul><h4 id="思考"><a class="markdownIt-Anchor" href="#思考"></a> 思考</h4><p>仿照归并排序的思想合并</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="作业练习" scheme="https://id-zy.github.io/categories/%E4%BD%9C%E4%B8%9A%E7%BB%83%E4%B9%A0/"/>
    
    
    <category term="LeetCode" scheme="https://id-zy.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>对角线遍历-LeetCode</title>
    <link href="https://id-zy.github.io/2025/12/13/%E5%AF%B9%E8%A7%92%E7%BA%BF%E9%81%8D%E5%8E%86/"/>
    <id>https://id-zy.github.io/2025/12/13/%E5%AF%B9%E8%A7%92%E7%BA%BF%E9%81%8D%E5%8E%86/</id>
    <published>2025-12-12T16:00:00.000Z</published>
    <updated>2025-12-13T08:14:32.784Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="对角线遍历"><a class="markdownIt-Anchor" href="#对角线遍历"></a> 对角线遍历</h1><h2 id="问题描述来源于leetcode"><a class="markdownIt-Anchor" href="#问题描述来源于leetcode"></a> 🎯 问题描述（来源于LeetCode）</h2><p><strong>描述</strong>：<br />给你一个大小为 <code>m x n</code> 的矩阵 <code>mat</code> ，请以对角线遍历的顺序，用一个数组返回这个矩阵中的所有元素。<br /><strong>说明</strong>：</p><ul><li><p><code>m == mat.length</code></p></li><li><p><code>n == mat[i].length</code></p></li><li><p><code>1 &lt;= m, n &lt;= 104</code></p></li><li><p><code>1 &lt;= m * n &lt;= 104</code></p></li><li><p><code>-105 &lt;= mat[i][j] &lt;= 105</code><br /><strong>示例</strong>：</p></li><li><p>示例 1：</p></li></ul><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：mat = [[1,2,3],[4,5,6],[7,8,9]]</span><br><span class="line">输出：[1,2,4,7,5,3,6,8,9]</span><br></pre></td></tr></table></figure><ul><li>示例 2：</li></ul><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：mat = [[1,2],[3,4]]</span><br><span class="line">输出：[1,2,3,4]</span><br></pre></td></tr></table></figure><h2 id="解题思路"><a class="markdownIt-Anchor" href="#解题思路"></a> 💻 解题思路</h2><h3 id="思路1遍历"><a class="markdownIt-Anchor" href="#思路1遍历"></a> 思路1：遍历</h3><h4 id="思路1代码实现"><a class="markdownIt-Anchor" href="#思路1代码实现"></a> 思路1：代码实现</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findDiagonalOrder</span>(<span class="params">self, mat: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> mat <span class="keyword">or</span> <span class="keyword">not</span> mat[<span class="number">0</span>]:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        m, n = <span class="built_in">len</span>(mat), <span class="built_in">len</span>(mat[<span class="number">0</span>])</span><br><span class="line">        ans = []</span><br><span class="line">        row, col = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        direction = <span class="number">1</span>  </span><br><span class="line">        <span class="keyword">while</span> <span class="built_in">len</span>(ans) &lt; m * n:</span><br><span class="line">            ans.append(mat[row][col])</span><br><span class="line">            <span class="keyword">if</span> direction == <span class="number">1</span>:  </span><br><span class="line">                new_row = row - <span class="number">1</span></span><br><span class="line">                new_col = col + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:  </span><br><span class="line">                new_row = row + <span class="number">1</span></span><br><span class="line">                new_col = col - <span class="number">1</span></span><br><span class="line">            is_out_of_bounds = new_row &lt; <span class="number">0</span> <span class="keyword">or</span> new_row &gt;= m <span class="keyword">or</span> new_col &lt; <span class="number">0</span> <span class="keyword">or</span> new_col &gt;= n</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> is_out_of_bounds:</span><br><span class="line">                row, col = new_row, new_col</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> direction == <span class="number">1</span>: </span><br><span class="line">                    <span class="keyword">if</span> col + <span class="number">1</span> &lt; n:</span><br><span class="line">                        col += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        row += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:  </span><br><span class="line">                    <span class="keyword">if</span> row + <span class="number">1</span> &lt; m:</span><br><span class="line">                        row += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        col += <span class="number">1</span></span><br><span class="line">                direction *= -<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><h4 id="思路1-性能分析"><a class="markdownIt-Anchor" href="#思路1-性能分析"></a> 思路1：📊 性能分析</h4><h5 id="提交结果"><a class="markdownIt-Anchor" href="#提交结果"></a> 提交结果</h5><ul><li><strong>运行时间</strong>：13ms击败50.65%</li><li><strong>内存消耗</strong>：19.50MB击败25.22%</li></ul><h5 id="复杂度验证"><a class="markdownIt-Anchor" href="#复杂度验证"></a> 复杂度验证</h5><ul><li>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mo>∗</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m*n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></li><li>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mo>∗</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m*n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></li></ul><h4 id="思考"><a class="markdownIt-Anchor" href="#思考"></a> 思考</h4><p>记录遍历方向，越界反转</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="作业练习" scheme="https://id-zy.github.io/categories/%E4%BD%9C%E4%B8%9A%E7%BB%83%E4%B9%A0/"/>
    
    
    <category term="LeetCode" scheme="https://id-zy.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>排序数组-LeetCode</title>
    <link href="https://id-zy.github.io/2025/12/13/%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84/"/>
    <id>https://id-zy.github.io/2025/12/13/%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84/</id>
    <published>2025-12-12T16:00:00.000Z</published>
    <updated>2025-12-17T01:29:23.886Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="排序数组"><a class="markdownIt-Anchor" href="#排序数组"></a> 排序数组</h1><h2 id="问题描述来源于leetcode"><a class="markdownIt-Anchor" href="#问题描述来源于leetcode"></a> 🎯 问题描述（来源于LeetCode）</h2><p><strong>描述</strong>：<br />给你一个整数数组 <code>nums</code>，请你将该数组升序排列。<br />你必须在 <strong>不使用任何内置函数</strong> 的情况下解决问题，时间复杂度为 <code>O(nlog(n))</code>，并且空间复杂度尽可能小。<br /><strong>说明</strong>：</p><ul><li><code>1 &lt;= nums.length &lt;= 5 * 104</code></li><li><code>-5 * 104 &lt;= nums[i] &lt;= 5 * 104</code></li></ul><p><strong>示例</strong>：</p><ul><li>示例 1：</li></ul><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [5,2,3,1]</span><br><span class="line">输出：[1,2,3,5]</span><br><span class="line">解释：数组排序后，某些数字的位置没有改变（例如，2 和 3），而其他数字的位置发生了改变（例如，1 和 5）。</span><br></pre></td></tr></table></figure><ul><li>示例 2：</li></ul><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [5,1,1,2,0,0]</span><br><span class="line">输出：[0,0,1,1,2,5]</span><br><span class="line">解释：请注意，nums 的值不一定唯一。</span><br></pre></td></tr></table></figure><h2 id="解题思路"><a class="markdownIt-Anchor" href="#解题思路"></a> 💻 解题思路</h2><h3 id="思路1希尔排序"><a class="markdownIt-Anchor" href="#思路1希尔排序"></a> 思路1：希尔排序</h3><h4 id="思路1代码实现"><a class="markdownIt-Anchor" href="#思路1代码实现"></a> 思路1：代码实现</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sortArray</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        size=<span class="built_in">len</span>(nums)</span><br><span class="line">        gap=size // <span class="number">2</span></span><br><span class="line">        <span class="keyword">while</span> gap&gt;<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(gap,size):</span><br><span class="line">                temp=nums[i]</span><br><span class="line">                j=i</span><br><span class="line">                <span class="keyword">while</span> j&gt;=gap <span class="keyword">and</span> nums[j-gap]&gt;temp:</span><br><span class="line">                    nums[j]=nums[j-gap]</span><br><span class="line">                    j-=gap</span><br><span class="line">                nums[j]=temp</span><br><span class="line">            gap//=<span class="number">2</span></span><br><span class="line">        <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure><h4 id="思路1-性能分析"><a class="markdownIt-Anchor" href="#思路1-性能分析"></a> 思路1：📊 性能分析</h4><h5 id="提交结果"><a class="markdownIt-Anchor" href="#提交结果"></a> 提交结果</h5><ul><li><strong>运行时间</strong>：635ms击败39.21%</li><li><strong>内存消耗</strong>：23.51MB击败92.42%</li></ul><h5 id="复杂度验证"><a class="markdownIt-Anchor" href="#复杂度验证"></a> 复杂度验证</h5><ul><li>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></li><li>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></li></ul><h3 id="思路2归并排序"><a class="markdownIt-Anchor" href="#思路2归并排序"></a> 思路2：归并排序</h3><h4 id="思路2代码实现"><a class="markdownIt-Anchor" href="#思路2代码实现"></a> 思路2：代码实现</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">merge</span>(<span class="params">self,left_nums:[<span class="built_in">int</span>],right_nums:[<span class="built_in">int</span>]</span>):</span><br><span class="line">        nums=[]</span><br><span class="line">        left_i=right_i=<span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> left_i&lt;<span class="built_in">len</span>(left_nums)<span class="keyword">and</span> right_i&lt;<span class="built_in">len</span>(right_nums):</span><br><span class="line">            <span class="keyword">if</span> left_nums[left_i]&lt;right_nums[right_i]:</span><br><span class="line">                nums.append(left_nums[left_i])</span><br><span class="line">                left_i+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                nums.append(right_nums[right_i])</span><br><span class="line">                right_i+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left_i&lt;<span class="built_in">len</span>(left_nums):</span><br><span class="line">            nums.append(left_nums[left_i])</span><br><span class="line">            left_i+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> right_i&lt;<span class="built_in">len</span>(right_nums):</span><br><span class="line">            nums.append(right_nums[right_i])</span><br><span class="line">            right_i+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> nums</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">mergesort</span>(<span class="params">self,nums:[<span class="built_in">int</span>]</span>)-&gt;[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nums)&lt;=<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> nums</span><br><span class="line">        mid=<span class="built_in">len</span>(nums)//<span class="number">2</span></span><br><span class="line">        left_nums=<span class="variable language_">self</span>.mergesort(nums[<span class="number">0</span>:mid])</span><br><span class="line">        right_nums=<span class="variable language_">self</span>.mergesort(nums[mid:])</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.merge(left_nums,right_nums)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sortArray</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.mergesort(nums)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure><h4 id="思路2-性能分析"><a class="markdownIt-Anchor" href="#思路2-性能分析"></a> 思路2：📊 性能分析</h4><h5 id="提交结果-2"><a class="markdownIt-Anchor" href="#提交结果-2"></a> 提交结果</h5><ul><li><strong>运行时间</strong>：771ms击败19.44%</li><li><strong>内存消耗</strong>：25.03MB击败43.20%</li></ul><h5 id="复杂度验证-2"><a class="markdownIt-Anchor" href="#复杂度验证-2"></a> 复杂度验证</h5><ul><li>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(Nlogn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></li><li>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span></li></ul><h3 id="思路3快速排序"><a class="markdownIt-Anchor" href="#思路3快速排序"></a> 思路3：快速排序</h3><h4 id="思路3代码实现"><a class="markdownIt-Anchor" href="#思路3代码实现"></a> 思路3：代码实现</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">randomPartition</span>(<span class="params">self,nums:[<span class="built_in">int</span>],low:<span class="built_in">int</span>,high:<span class="built_in">int</span></span>)-&gt;<span class="built_in">int</span>:</span><br><span class="line">        i=random.randint(low,high)</span><br><span class="line">        nums[low],nums[i]=nums[i],nums[low]</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.partition(nums,low,high)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">partition</span>(<span class="params">self,nums:[<span class="built_in">int</span>],low:<span class="built_in">int</span>,high:<span class="built_in">int</span></span>)-&gt;<span class="built_in">int</span>:</span><br><span class="line">        pivot=nums[low]</span><br><span class="line">        i,j=low,high</span><br><span class="line">        <span class="keyword">while</span> i&lt;j:</span><br><span class="line">            <span class="keyword">while</span> i&lt;j <span class="keyword">and</span> nums[j]&gt;=pivot:</span><br><span class="line">                j-=<span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> i&lt;j <span class="keyword">and</span> nums[i]&lt;=pivot:</span><br><span class="line">                i+=<span class="number">1</span></span><br><span class="line">            nums[i],nums[j]=nums[j],nums[i]</span><br><span class="line">        nums[low],nums[j]=nums[j],nums[low]</span><br><span class="line">        <span class="keyword">return</span> i</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">quicksort</span>(<span class="params">self,nums:[<span class="built_in">int</span>],low:<span class="built_in">int</span>,high:<span class="built_in">int</span></span>)-&gt;[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="keyword">if</span> low &lt;high:</span><br><span class="line">            pivot_i=<span class="variable language_">self</span>.randomPartition(nums,low,high)</span><br><span class="line">            <span class="variable language_">self</span>.quicksort(nums,low,pivot_i-<span class="number">1</span>)</span><br><span class="line">            <span class="variable language_">self</span>.quicksort(nums,pivot_i+<span class="number">1</span>,high)</span><br><span class="line">        <span class="keyword">return</span> nums</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sortArray</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.quicksort(nums,<span class="number">0</span>,<span class="built_in">len</span>(nums)-<span class="number">1</span>)</span><br></pre></td></tr></table></figure><h4 id="思路3-性能分析"><a class="markdownIt-Anchor" href="#思路3-性能分析"></a> 思路3：📊 性能分析</h4><h5 id="提交结果-3"><a class="markdownIt-Anchor" href="#提交结果-3"></a> 提交结果</h5><ul><li><strong>运行时间</strong>：超时</li><li><strong>内存消耗</strong>：</li></ul><h5 id="复杂度验证-3"><a class="markdownIt-Anchor" href="#复杂度验证-3"></a> 复杂度验证</h5><ul><li>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(Nlogn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></li><li>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="作业练习" scheme="https://id-zy.github.io/categories/%E4%BD%9C%E4%B8%9A%E7%BB%83%E4%B9%A0/"/>
    
    
    <category term="LeetCode" scheme="https://id-zy.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>相对名次-LeetCode</title>
    <link href="https://id-zy.github.io/2025/12/13/%E7%9B%B8%E5%AF%B9%E5%90%8D%E6%AC%A1/"/>
    <id>https://id-zy.github.io/2025/12/13/%E7%9B%B8%E5%AF%B9%E5%90%8D%E6%AC%A1/</id>
    <published>2025-12-12T16:00:00.000Z</published>
    <updated>2025-12-13T09:14:32.862Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="相对名次"><a class="markdownIt-Anchor" href="#相对名次"></a> 相对名次</h1><h2 id="问题描述来源于leetcode"><a class="markdownIt-Anchor" href="#问题描述来源于leetcode"></a> 🎯 问题描述（来源于LeetCode）</h2><p><strong>描述</strong>：<br />给你一个长度为 <code>n</code> 的整数数组 <code>score</code> ，其中 <code>score[i]</code> 是第 <code>i</code> 位运动员在比赛中的得分。所有得分都 <strong>互不相同</strong> 。<br />运动员将根据得分 <strong>决定名次</strong> ，其中名次第 <code>1</code> 的运动员得分最高，名次第 <code>2</code> 的运动员得分第 <code>2</code> 高，依此类推。运动员的名次决定了他们的获奖情况：</p><ul><li>名次第 <code>1</code> 的运动员获金牌 <code>&quot;Gold Medal&quot;</code> 。</li><li>名次第 <code>2</code> 的运动员获银牌 <code>&quot;Silver Medal&quot;</code> 。</li><li>名次第 <code>3</code> 的运动员获铜牌 <code>&quot;Bronze Medal&quot;</code> 。</li><li>从名次第 <code>4</code> 到第 <code>n</code> 的运动员，只能获得他们的名次编号（即，名次第 <code>x</code> 的运动员获得编号 <code>&quot;x&quot;</code>）。<br />使用长度为 <code>n</code> 的数组 <code>answer</code> 返回获奖，其中 <code>answer[i]</code> 是第 <code>i</code> 位运动员的获奖情况。<br /><strong>说明</strong>：</li><li><code>n == score.length</code></li><li><code>1 &lt;= n &lt;= 104</code></li><li><code>0 &lt;= score[i] &lt;= 106</code></li><li><code>score</code> 中的所有值 <strong>互不相同</strong></li></ul><p><strong>示例</strong>：</p><ul><li>示例 1：</li></ul><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：score = [5,4,3,2,1]</span><br><span class="line">输出：[&quot;Gold Medal&quot;,&quot;Silver Medal&quot;,&quot;Bronze Medal&quot;,&quot;4&quot;,&quot;5&quot;]</span><br><span class="line">解释：名次为 [1st, 2nd, 3rd, 4th, 5th] 。</span><br></pre></td></tr></table></figure><ul><li>示例 2：</li></ul><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：score = [10,3,8,9,4]</span><br><span class="line">输出：[&quot;Gold Medal&quot;,&quot;5&quot;,&quot;Bronze Medal&quot;,&quot;Silver Medal&quot;,&quot;4&quot;]</span><br><span class="line">解释：名次为 [1st, 5th, 3rd, 2nd, 4th] 。</span><br></pre></td></tr></table></figure><h2 id="解题思路"><a class="markdownIt-Anchor" href="#解题思路"></a> 💻 解题思路</h2><h3 id="思路1希尔排序"><a class="markdownIt-Anchor" href="#思路1希尔排序"></a> 思路1：希尔排序</h3><h4 id="思路1代码实现"><a class="markdownIt-Anchor" href="#思路1代码实现"></a> 思路1：代码实现</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findRelativeRanks</span>(<span class="params">self, score: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">str</span>]:</span><br><span class="line">        n=<span class="built_in">len</span>(score)</span><br><span class="line">        nums=score.copy()</span><br><span class="line">        indices = <span class="built_in">list</span>(<span class="built_in">range</span>(n))</span><br><span class="line">        gap=n//<span class="number">2</span></span><br><span class="line">        <span class="keyword">while</span> gap&gt;<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(gap,n):</span><br><span class="line">                temp=nums[i]</span><br><span class="line">                idx = indices[i]</span><br><span class="line">                j=i</span><br><span class="line">                <span class="keyword">while</span> j&gt;=gap <span class="keyword">and</span> nums[j-gap]&lt;temp:</span><br><span class="line">                    nums[j]=nums[j-gap]</span><br><span class="line">                    indices[j]=indices[j-gap]</span><br><span class="line">                    j-=gap</span><br><span class="line">                nums[j]=temp</span><br><span class="line">                indices[j]=idx</span><br><span class="line">            gap//=<span class="number">2</span></span><br><span class="line">        result = [<span class="string">&quot;&quot;</span>] * n</span><br><span class="line">        <span class="keyword">for</span> rank, idx <span class="keyword">in</span> <span class="built_in">enumerate</span>(indices):</span><br><span class="line">            <span class="keyword">if</span> rank == <span class="number">0</span>:</span><br><span class="line">                result[idx] = <span class="string">&quot;Gold Medal&quot;</span></span><br><span class="line">            <span class="keyword">elif</span> rank == <span class="number">1</span>:</span><br><span class="line">                result[idx] = <span class="string">&quot;Silver Medal&quot;</span></span><br><span class="line">            <span class="keyword">elif</span> rank == <span class="number">2</span>:</span><br><span class="line">                result[idx] = <span class="string">&quot;Bronze Medal&quot;</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                result[idx] = <span class="built_in">str</span>(rank + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><h4 id="思路1-性能分析"><a class="markdownIt-Anchor" href="#思路1-性能分析"></a> 思路1：📊 性能分析</h4><h5 id="提交结果"><a class="markdownIt-Anchor" href="#提交结果"></a> 提交结果</h5><ul><li><strong>运行时间</strong>：31ms击败23.85%</li><li><strong>内存消耗</strong>：18.61MB击败77.56%</li></ul><h5 id="复杂度验证"><a class="markdownIt-Anchor" href="#复杂度验证"></a> 复杂度验证</h5><ul><li>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(nlog(n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></li><li>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></li></ul><h4 id="思考"><a class="markdownIt-Anchor" href="#思考"></a> 思考</h4><p>使用希尔排序后再建立索引与值的关系</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="作业练习" scheme="https://id-zy.github.io/categories/%E4%BD%9C%E4%B8%9A%E7%BB%83%E4%B9%A0/"/>
    
    
    <category term="LeetCode" scheme="https://id-zy.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>加一-LeetCode</title>
    <link href="https://id-zy.github.io/2025/12/12/%E5%8A%A0%E4%B8%80/"/>
    <id>https://id-zy.github.io/2025/12/12/%E5%8A%A0%E4%B8%80/</id>
    <published>2025-12-11T16:00:00.000Z</published>
    <updated>2025-12-12T12:33:02.277Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="加一"><a class="markdownIt-Anchor" href="#加一"></a> 加一</h1><h2 id="问题描述来源于leetcode"><a class="markdownIt-Anchor" href="#问题描述来源于leetcode"></a> 🎯 问题描述（来源于LeetCode）</h2><p><strong>描述</strong>：<br />给定一个表示 <strong>大整数</strong> 的整数数组 <code>digits</code>，其中 <code>digits[i]</code> 是整数的第 <code>i</code> 位数字。这些数字按从左到右，从最高位到最低位排列。这个大整数不包含任何前导 <code>0</code>。<br />将大整数加 1，并返回结果的数字数组。<br /><strong>说明</strong>：</p><ul><li><p><code>1 &lt;= digits.length &lt;= 100</code></p></li><li><p><code>0 &lt;= digits[i] &lt;= 9</code></p></li><li><p><code>digits</code> 不包含任何前导 <code>0</code>。<br /><strong>示例</strong>：</p></li><li><p>示例 1：</p></li></ul><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：digits = [1,2,3]</span><br><span class="line">输出：[1,2,4]</span><br><span class="line">解释：输入数组表示数字 123。</span><br><span class="line">加 1 后得到 123 + 1 = 124。</span><br><span class="line">因此，结果应该是 [1,2,4]。</span><br></pre></td></tr></table></figure><ul><li>示例 2：</li></ul><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：digits = [9]</span><br><span class="line">输出：[1,0]</span><br><span class="line">解释：输入数组表示数字 9。</span><br><span class="line">加 1 得到了 9 + 1 = 10。</span><br><span class="line">因此，结果应该是 [1,0]。</span><br></pre></td></tr></table></figure><h2 id="解题思路"><a class="markdownIt-Anchor" href="#解题思路"></a> 💻 解题思路</h2><h3 id="思路1反向遍历"><a class="markdownIt-Anchor" href="#思路1反向遍历"></a> 思路1：反向遍历</h3><h4 id="思路1代码实现"><a class="markdownIt-Anchor" href="#思路1代码实现"></a> 思路1：代码实现</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">plusOne</span>(<span class="params">self, digits: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        n=<span class="built_in">len</span>(digits)</span><br><span class="line">        x=[]</span><br><span class="line">        d=n-<span class="number">1</span></span><br><span class="line">        digits[n-<span class="number">1</span>]+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> d&gt;-<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">while</span> digits[d]==<span class="number">10</span>:</span><br><span class="line">                x.append(<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">if</span> d==<span class="number">0</span>:</span><br><span class="line">                    x.append(<span class="number">1</span>)</span><br><span class="line">                    m=x[::-<span class="number">1</span>]</span><br><span class="line">                    <span class="keyword">return</span> m          </span><br><span class="line">                d-=<span class="number">1</span></span><br><span class="line">                digits[d]+=<span class="number">1</span></span><br><span class="line">            x.append(digits[d])</span><br><span class="line">            d-=<span class="number">1</span></span><br><span class="line">        m=x[::-<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> m</span><br></pre></td></tr></table></figure><h4 id="思路1-性能分析"><a class="markdownIt-Anchor" href="#思路1-性能分析"></a> 思路1：📊 性能分析</h4><h5 id="提交结果"><a class="markdownIt-Anchor" href="#提交结果"></a> 提交结果</h5><ul><li><strong>运行时间</strong>：0ms击败100.00%</li><li><strong>内存消耗</strong>：17.30MB击败97.07%</li></ul><h5 id="复杂度验证"><a class="markdownIt-Anchor" href="#复杂度验证"></a> 复杂度验证</h5><ul><li>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></li><li>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></li></ul><h4 id="思考"><a class="markdownIt-Anchor" href="#思考"></a> 思考</h4><p>反向遍历数组，判断当前数字+1后是否等于10，返回反转数组</p><h3 id="思路2判断当前数位是否进1观看灵神的思路"><a class="markdownIt-Anchor" href="#思路2判断当前数位是否进1观看灵神的思路"></a> 思路2：判断当前数位是否进1（观看灵神的思路）</h3><h4 id="思路2代码实现"><a class="markdownIt-Anchor" href="#思路2代码实现"></a> 思路2：代码实现</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">plusOne</span>(<span class="params">self, digits: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        n=<span class="built_in">len</span>(digits)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> digits[i]&lt;<span class="number">9</span>:</span><br><span class="line">                digits[i]+=<span class="number">1</span></span><br><span class="line">                <span class="keyword">return</span> digits</span><br><span class="line">            digits[i]=<span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> [<span class="number">1</span>]+digits</span><br></pre></td></tr></table></figure><h4 id="思路2-性能分析"><a class="markdownIt-Anchor" href="#思路2-性能分析"></a> 思路2：📊 性能分析</h4><h5 id="提交结果-2"><a class="markdownIt-Anchor" href="#提交结果-2"></a> 提交结果</h5><ul><li><strong>运行时间</strong>：0ms击败100.00%</li><li><strong>内存消耗</strong>：17.67MB击败14.25%</li></ul><h5 id="复杂度验证-2"><a class="markdownIt-Anchor" href="#复杂度验证-2"></a> 复杂度验证</h5><ul><li>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></li><li>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></li></ul><h4 id="思考-2"><a class="markdownIt-Anchor" href="#思考-2"></a> 思考</h4><p>反向遍历数组，判断当前数位是否需要进1，直到不进位返回数组</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="作业练习" scheme="https://id-zy.github.io/categories/%E4%BD%9C%E4%B8%9A%E7%BB%83%E4%B9%A0/"/>
    
    
    <category term="LeetCode" scheme="https://id-zy.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>各赛事的注册率-LeetCode</title>
    <link href="https://id-zy.github.io/2025/12/12/%E5%90%84%E8%B5%9B%E4%BA%8B%E7%9A%84%E6%B3%A8%E5%86%8C%E7%8E%87/"/>
    <id>https://id-zy.github.io/2025/12/12/%E5%90%84%E8%B5%9B%E4%BA%8B%E7%9A%84%E6%B3%A8%E5%86%8C%E7%8E%87/</id>
    <published>2025-12-11T16:00:00.000Z</published>
    <updated>2025-12-12T15:51:59.583Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="各赛事的注册率"><a class="markdownIt-Anchor" href="#各赛事的注册率"></a> 各赛事的注册率</h1><h2 id="问题描述来源于leetcode"><a class="markdownIt-Anchor" href="#问题描述来源于leetcode"></a> 🎯 问题描述（来源于LeetCode）</h2><p><strong>描述</strong>：<br />用户表： <code>Users</code><br />±------------±--------+<br />| Column Name | Type    |<br />±------------±--------+<br />| user_id     | int     |<br />| user_name   | varchar |<br />±------------±--------+<br />user_id 是该表的主键(具有唯一值的列)。<br />该表中的每行包括用户 ID 和用户名。<br />注册表： <code>Register</code><br />±------------±--------+<br />| Column Name | Type    |<br />±------------±--------+<br />| contest_id  | int     |<br />| user_id     | int     |<br />±------------±--------+<br />(contest_id, user_id) 是该表的主键(具有唯一值的列的组合)。<br />该表中的每行包含用户的 ID 和他们注册的赛事。<br />编写解决方案统计出各赛事的用户注册百分率，保留两位小数。<br />返回的结果表按 <code>percentage</code> 的 <strong>降序</strong> 排序，若相同则按 <code>contest_id</code> 的 <strong>升序</strong> 排序。</p><h2 id="解题思路"><a class="markdownIt-Anchor" href="#解题思路"></a> 💻 解题思路</h2><h3 id="思路1子查询"><a class="markdownIt-Anchor" href="#思路1子查询"></a> 思路1：子查询</h3><h4 id="思路1代码实现"><a class="markdownIt-Anchor" href="#思路1代码实现"></a> 思路1：代码实现</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># Write your MySQL query statement below</span><br><span class="line"><span class="keyword">SELECT</span> contest_id,</span><br><span class="line">ROUND(<span class="built_in">COUNT</span>(<span class="operator">*</span>)<span class="operator">*</span><span class="number">100.0</span><span class="operator">/</span></span><br><span class="line">(<span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>)</span><br><span class="line"><span class="keyword">FROM</span> Users )</span><br><span class="line">,<span class="number">2</span>)<span class="keyword">AS</span> percentage</span><br><span class="line"><span class="keyword">FROM</span> Register</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> contest_id</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> percentage <span class="keyword">DESC</span>,contest_id</span><br></pre></td></tr></table></figure><h4 id="思路1-性能分析"><a class="markdownIt-Anchor" href="#思路1-性能分析"></a> 思路1：📊 性能分析</h4><h5 id="提交结果"><a class="markdownIt-Anchor" href="#提交结果"></a> 提交结果</h5><ul><li><strong>运行时间</strong>：1287ms击败76.16%</li></ul><h4 id="思考"><a class="markdownIt-Anchor" href="#思考"></a> 思考</h4><p>分别查询行数相除即可</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="作业练习" scheme="https://id-zy.github.io/categories/%E4%BD%9C%E4%B8%9A%E7%BB%83%E4%B9%A0/"/>
    
    
    <category term="LeetCode" scheme="https://id-zy.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>寻找数组的中心下标-LeetCode</title>
    <link href="https://id-zy.github.io/2025/12/12/%E5%AF%BB%E6%89%BE%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E5%BF%83%E4%B8%8B%E6%A0%87/"/>
    <id>https://id-zy.github.io/2025/12/12/%E5%AF%BB%E6%89%BE%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E5%BF%83%E4%B8%8B%E6%A0%87/</id>
    <published>2025-12-11T16:00:00.000Z</published>
    <updated>2025-12-12T13:02:57.334Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="寻找数组的中心下标"><a class="markdownIt-Anchor" href="#寻找数组的中心下标"></a> 寻找数组的中心下标</h1><h2 id="问题描述来源于leetcode"><a class="markdownIt-Anchor" href="#问题描述来源于leetcode"></a> 🎯 问题描述（来源于LeetCode）</h2><p><strong>描述</strong>：<br />给你一个整数数组 <code>nums</code> ，请计算数组的 <strong>中心下标</strong> 。<br />数组 <strong>中心下标</strong> 是数组的一个下标，其左侧所有元素相加的和等于右侧所有元素相加的和。<br />如果中心下标位于数组最左端，那么左侧数之和视为 <code>0</code> ，因为在下标的左侧不存在元素。这一点对于中心下标位于数组最右端同样适用。<br />如果数组有多个中心下标，应该返回 <strong>最靠近左边</strong> 的那一个。如果数组不存在中心下标，返回 <code>-1</code> 。<br /><strong>说明</strong>：</p><ul><li><p><code>1 &lt;= nums.length &lt;= 104</code></p></li><li><p><code>-1000 &lt;= nums[i] &lt;= 1000</code><br /><strong>示例</strong>：</p></li><li><p>示例 1：</p></li></ul><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1, 7, 3, 6, 5, 6]</span><br><span class="line">输出：3</span><br><span class="line">解释：</span><br><span class="line">中心下标是 3 。</span><br><span class="line">左侧数之和 sum = nums[0] + nums[1] + nums[2] = 1 + 7 + 3 = 11 ，</span><br><span class="line">右侧数之和 sum = nums[4] + nums[5] = 5 + 6 = 11 ，二者相等。</span><br></pre></td></tr></table></figure><ul><li>示例 2：</li></ul><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1, 2, 3]</span><br><span class="line">输出：-1</span><br><span class="line">解释：</span><br><span class="line">数组中不存在满足此条件的中心下标。</span><br></pre></td></tr></table></figure><h2 id="解题思路"><a class="markdownIt-Anchor" href="#解题思路"></a> 💻 解题思路</h2><h3 id="思路1遍历"><a class="markdownIt-Anchor" href="#思路1遍历"></a> 思路1：遍历</h3><h4 id="思路1代码实现"><a class="markdownIt-Anchor" href="#思路1代码实现"></a> 思路1：代码实现</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pivotIndex</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n=<span class="built_in">len</span>(nums)</span><br><span class="line">        i=<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">sum</span>(nums[<span class="number">0</span>:i])==<span class="built_in">sum</span>(nums[i+<span class="number">1</span>:n]):</span><br><span class="line">                <span class="keyword">return</span> i</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure><h4 id="思路1-性能分析"><a class="markdownIt-Anchor" href="#思路1-性能分析"></a> 思路1：📊 性能分析</h4><h5 id="提交结果"><a class="markdownIt-Anchor" href="#提交结果"></a> 提交结果</h5><ul><li><strong>运行时间</strong>：7299ms击败5.81%</li><li><strong>内存消耗</strong>：18.59MB击败9.60%</li></ul><h5 id="复杂度验证"><a class="markdownIt-Anchor" href="#复杂度验证"></a> 复杂度验证</h5><ul><li>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></li><li>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></li></ul><h4 id="思考"><a class="markdownIt-Anchor" href="#思考"></a> 思考</h4><p>遍历判断即可</p><h3 id="思路2遍历优化"><a class="markdownIt-Anchor" href="#思路2遍历优化"></a> 思路2：遍历优化</h3><h4 id="思路2代码实现"><a class="markdownIt-Anchor" href="#思路2代码实现"></a> 思路2：代码实现</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pivotIndex</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n=<span class="built_in">len</span>(nums)</span><br><span class="line">        i=<span class="number">0</span></span><br><span class="line">        sum1=<span class="built_in">sum</span>(nums)</span><br><span class="line">        sum2=<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">if</span> sum2*<span class="number">2</span>==sum1-nums[i]:</span><br><span class="line">                <span class="keyword">return</span> i</span><br><span class="line">            sum2+=nums[i]</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure><h4 id="思路1-性能分析-2"><a class="markdownIt-Anchor" href="#思路1-性能分析-2"></a> 思路1：📊 性能分析</h4><h5 id="提交结果-2"><a class="markdownIt-Anchor" href="#提交结果-2"></a> 提交结果</h5><ul><li><strong>运行时间</strong>：4ms击败75.61%</li><li><strong>内存消耗</strong>：18.55MB击败16.32%</li></ul><h5 id="复杂度验证-2"><a class="markdownIt-Anchor" href="#复杂度验证-2"></a> 复杂度验证</h5><ul><li>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></li><li>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></li></ul><h4 id="思考-2"><a class="markdownIt-Anchor" href="#思考-2"></a> 思考</h4><p>思路一中每次遍历需要重新加一遍前i-1个数的和而思路二只需要加当前数字即可</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="作业练习" scheme="https://id-zy.github.io/categories/%E4%BD%9C%E4%B8%9A%E7%BB%83%E4%B9%A0/"/>
    
    
    <category term="LeetCode" scheme="https://id-zy.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>螺旋矩阵-LeetCode</title>
    <link href="https://id-zy.github.io/2025/12/12/%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5/"/>
    <id>https://id-zy.github.io/2025/12/12/%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5/</id>
    <published>2025-12-11T16:00:00.000Z</published>
    <updated>2025-12-12T11:04:04.905Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="螺旋矩阵"><a class="markdownIt-Anchor" href="#螺旋矩阵"></a> 螺旋矩阵</h1><h2 id="问题描述来源于leetcode"><a class="markdownIt-Anchor" href="#问题描述来源于leetcode"></a> 🎯 问题描述（来源于LeetCode）</h2><p><strong>描述</strong>：<br />给你一个 <code>m</code> 行 <code>n</code> 列的矩阵 <code>matrix</code> ，请按照 <strong>顺时针螺旋顺序</strong> ，返回矩阵中的所有元素。<br /><strong>说明</strong>：</p><ul><li><code>m == matrix.length</code></li><li><code>n == matrix[i].length</code></li><li><code>1 &lt;= m, n &lt;= 10</code></li><li><code>-100 &lt;= matrix[i][j] &lt;= 100</code></li></ul><p><strong>示例</strong>：</p><ul><li>示例 1：</li></ul><p>输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]<br />输出：[1,2,3,6,9,8,7,4,5]</p><ul><li>示例 2：<br />输入：matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]<br />输出：[1,2,3,4,8,12,11,10,9,5,6,7]</li></ul><h2 id="解题思路"><a class="markdownIt-Anchor" href="#解题思路"></a> 💻 解题思路</h2><h3 id="思路1四个方向顺序遍历"><a class="markdownIt-Anchor" href="#思路1四个方向顺序遍历"></a> 思路1：四个方向顺序遍历</h3><h4 id="思路1代码实现"><a class="markdownIt-Anchor" href="#思路1代码实现"></a> 思路1：代码实现</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">spiralOrder</span>(<span class="params">self, matrix: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        m,n=<span class="built_in">len</span>(matrix),<span class="built_in">len</span>(matrix[<span class="number">0</span>])</span><br><span class="line">        nums=matrix</span><br><span class="line">        l=<span class="number">0</span></span><br><span class="line">        r=n-<span class="number">1</span></span><br><span class="line">        b=m-<span class="number">1</span></span><br><span class="line">        t=<span class="number">0</span></span><br><span class="line">        ans=[]</span><br><span class="line">        <span class="keyword">while</span> l&lt;=r <span class="keyword">and</span> t&lt;=b:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(l,r+<span class="number">1</span>):</span><br><span class="line">                num=matrix[t][i]</span><br><span class="line">                ans.append(num)</span><br><span class="line">            t+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(t,b+<span class="number">1</span>):</span><br><span class="line">                num=matrix[i][r]</span><br><span class="line">                ans.append(num)</span><br><span class="line">            r-=<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> t&lt;=b:</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(r,l-<span class="number">1</span>,-<span class="number">1</span>):</span><br><span class="line">                    num=matrix[b][i]</span><br><span class="line">                    ans.append(num)</span><br><span class="line">                b-=<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> l&lt;=r:</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(b,t-<span class="number">1</span>,-<span class="number">1</span>):</span><br><span class="line">                    num=matrix[i][l]</span><br><span class="line">                    ans.append(num)</span><br><span class="line">                l+=<span class="number">1</span>       </span><br><span class="line">        <span class="keyword">return</span> ans                 </span><br></pre></td></tr></table></figure><h4 id="思路1-性能分析"><a class="markdownIt-Anchor" href="#思路1-性能分析"></a> 思路1：📊 性能分析</h4><h5 id="提交结果"><a class="markdownIt-Anchor" href="#提交结果"></a> 提交结果</h5><ul><li><strong>运行时间</strong>：0ms击败100.00%</li><li><strong>内存消耗</strong>：17.45MB击败72.08%</li></ul><h5 id="复杂度验证"><a class="markdownIt-Anchor" href="#复杂度验证"></a> 复杂度验证</h5><ul><li>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mo>∗</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m*n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></li><li>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mo>∗</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m*n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></li></ul><h4 id="思考"><a class="markdownIt-Anchor" href="#思考"></a> 思考</h4><p>通过四个方向的顺序遍历并不断更新四个角的坐标即可</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="作业练习" scheme="https://id-zy.github.io/categories/%E4%BD%9C%E4%B8%9A%E7%BB%83%E4%B9%A0/"/>
    
    
    <category term="LeetCode" scheme="https://id-zy.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>旋转函数-LeetCode</title>
    <link href="https://id-zy.github.io/2025/12/10/%E6%97%8B%E8%BD%AC%E5%87%BD%E6%95%B0/"/>
    <id>https://id-zy.github.io/2025/12/10/%E6%97%8B%E8%BD%AC%E5%87%BD%E6%95%B0/</id>
    <published>2025-12-09T16:00:00.000Z</published>
    <updated>2025-12-10T14:41:31.838Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="旋转函数"><a class="markdownIt-Anchor" href="#旋转函数"></a> 旋转函数</h1><h2 id="问题描述来源于leetcode"><a class="markdownIt-Anchor" href="#问题描述来源于leetcode"></a> 🎯 问题描述（来源于LeetCode）</h2><p><strong>描述</strong>：<br />给定一个长度为 <code>n</code> 的整数数组 <code>nums</code> 。<br />假设 <code>arrk</code> 是数组 <code>nums</code> 顺时针旋转 <code>k</code> 个位置后的数组，我们定义 <code>nums</code> 的 <strong>旋转函数</strong>  <code>F</code> 为：</p><ul><li><p><code>F(k) = 0 * arrk[0] + 1 * arrk[1] + ... + (n - 1) * arrk[n - 1]</code><br /><strong>要求</strong>：<br />返回 <em><code>F(0), F(1), ..., F(n-1)</code>中的最大值</em> 。<br />生成的测试用例让答案符合 <strong>32 位</strong> 整数。<br /><strong>说明</strong>：</p></li><li><p><code>n == nums.length</code></p></li><li><p><code>1 &lt;= n &lt;= 105</code></p></li><li><p><code>-100 &lt;= nums[i] &lt;= 100</code><br /><strong>示例</strong>：</p></li><li><p>示例 1：<br /><strong>输入:</strong> nums = [4,3,2,6]<br /><strong>输出:</strong> 26<br /><strong>解释:</strong><br />F(0) = (0 * 4) + (1 * 3) + (2 * 2) + (3 * 6) = 0 + 3 + 4 + 18 = 25<br />F(1) = (0 * 6) + (1 * 4) + (2 * 3) + (3 * 2) = 0 + 4 + 6 + 6 = 16<br />F(2) = (0 * 2) + (1 * 6) + (2 * 4) + (3 * 3) = 0 + 6 + 8 + 9 = 23<br />F(3) = (0 * 3) + (1 * 2) + (2 * 6) + (3 * 4) = 0 + 2 + 12 + 12 = 26<br />所以 F(0), F(1), F(2), F(3) 中的最大值是 F(3) = 26 。</p></li><li><p>示例 2：<br /><strong>输入:</strong> nums = [100]<br /><strong>输出:</strong> 0</p></li></ul><h2 id="解题思路"><a class="markdownIt-Anchor" href="#解题思路"></a> 💻 解题思路</h2><h3 id="思路1遍历"><a class="markdownIt-Anchor" href="#思路1遍历"></a> 思路1：遍历</h3><h4 id="思路1代码实现"><a class="markdownIt-Anchor" href="#思路1代码实现"></a> 思路1：代码实现</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxRotateFunction</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        F = <span class="built_in">float</span>(<span class="string">&#x27;-inf&#x27;</span>)</span><br><span class="line">        sum1=<span class="number">0</span></span><br><span class="line">        n=<span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                d=(i+j)%n</span><br><span class="line">                sum1+=j*nums[d]</span><br><span class="line">            <span class="keyword">if</span> F&lt;sum1:</span><br><span class="line">                F=sum1</span><br><span class="line">            sum1=<span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> F</span><br></pre></td></tr></table></figure><h4 id="思路1-性能分析"><a class="markdownIt-Anchor" href="#思路1-性能分析"></a> 思路1：📊 性能分析</h4><h5 id="提交结果"><a class="markdownIt-Anchor" href="#提交结果"></a> 提交结果</h5><ul><li><strong>运行时间</strong>：超出时间限制</li><li><strong>内存消耗</strong>：</li></ul><h5 id="复杂度验证"><a class="markdownIt-Anchor" href="#复杂度验证"></a> 复杂度验证</h5><ul><li>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></li><li>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></li></ul><h4 id="思考"><a class="markdownIt-Anchor" href="#思考"></a> 思考</h4><p>虽然观察到函数规律但由于双重for循环的遍历导致时间复杂度过大</p><h3 id="思路1观察递归公式"><a class="markdownIt-Anchor" href="#思路1观察递归公式"></a> 思路1：观察递归公式</h3><h4 id="思路1代码实现-2"><a class="markdownIt-Anchor" href="#思路1代码实现-2"></a> 思路1：代码实现</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxRotateFunction</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        F(k) = 0 * arrk[0] + 1 * arrk[1] + ... + (n - 1) * arrk[n - 1]</span></span><br><span class="line"><span class="string">        F(k+1)=0*arrk[n-1]+1*arrk[2]+...+(n-2)*arrk[n-2]</span></span><br><span class="line"><span class="string">        F(K+1)-F(K)=sum(arrk[0:n])-n*arrk[n-k]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        sum1=<span class="number">0</span></span><br><span class="line">        F=<span class="number">0</span></span><br><span class="line">        sum2=<span class="number">0</span></span><br><span class="line">        n=<span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            sum1+=nums[i]</span><br><span class="line">            F+=i*nums[i]</span><br><span class="line">        a=F</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n):</span><br><span class="line">            d=n*nums[n-i]</span><br><span class="line">            sum2=a+sum1-d</span><br><span class="line">            a=sum2</span><br><span class="line">            <span class="keyword">if</span> sum2&gt;F:</span><br><span class="line">                F=sum2</span><br><span class="line">        <span class="keyword">return</span> F</span><br></pre></td></tr></table></figure><h4 id="思路2-性能分析"><a class="markdownIt-Anchor" href="#思路2-性能分析"></a> 思路2：📊 性能分析</h4><h5 id="提交结果-2"><a class="markdownIt-Anchor" href="#提交结果-2"></a> 提交结果</h5><ul><li><strong>运行时间</strong>：127ms击败90.18%</li><li><strong>内存消耗</strong>：25.38MB击败31.29%</li></ul><h5 id="复杂度验证-2"><a class="markdownIt-Anchor" href="#复杂度验证-2"></a> 复杂度验证</h5><ul><li>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></li><li>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></li></ul><h4 id="思考-2"><a class="markdownIt-Anchor" href="#思考-2"></a> 思考</h4><p>找到递推公式就可以一次遍历了</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="作业练习" scheme="https://id-zy.github.io/categories/%E4%BD%9C%E4%B8%9A%E7%BB%83%E4%B9%A0/"/>
    
    
    <category term="LeetCode" scheme="https://id-zy.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>轮转数组-LeetCode</title>
    <link href="https://id-zy.github.io/2025/12/10/%E8%BD%AE%E8%BD%AC%E6%95%B0%E7%BB%84/"/>
    <id>https://id-zy.github.io/2025/12/10/%E8%BD%AE%E8%BD%AC%E6%95%B0%E7%BB%84/</id>
    <published>2025-12-09T16:00:00.000Z</published>
    <updated>2025-12-10T13:38:10.913Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="轮转数组"><a class="markdownIt-Anchor" href="#轮转数组"></a> 轮转数组</h1><h2 id="问题描述来源于leetcode"><a class="markdownIt-Anchor" href="#问题描述来源于leetcode"></a> 🎯 问题描述（来源于LeetCode）</h2><p><strong>描述</strong>：<br />给定一个整数数组 <code>nums</code>，将数组中的元素向右轮转 <code>k</code> 个位置，其中 <code>k</code> 是非负数。<br /><strong>要求</strong>：<br />  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">  Do not return anything, modify nums in-place instead</span><br></pre></td></tr></table></figure><br /><strong>说明</strong>：</p><ul><li><code>1 &lt;= nums.length &lt;= 105</code></li><li><code>-231 &lt;= nums[i] &lt;= 231 - 1</code></li><li><code>0 &lt;= k &lt;= 105</code></li></ul><p><strong>示例</strong>：</p><ul><li>示例 1：<br /><strong>输入:</strong> nums = [1,2,3,4,5,6,7], k = 3<br /><strong>输出:</strong> <code>[5,6,7,1,2,3,4]</code><br /><strong>解释:</strong><br />向右轮转 1 步: <code>[7,1,2,3,4,5,6]</code><br />向右轮转 2 步: <code>[6,7,1,2,3,4,5]</code><br />向右轮转 3 步: <code>[5,6,7,1,2,3,4]</code></li></ul><h2 id="解题思路"><a class="markdownIt-Anchor" href="#解题思路"></a> 💻 解题思路</h2><h3 id="思路1三次反转"><a class="markdownIt-Anchor" href="#思路1三次反转"></a> 思路1：三次反转</h3><h4 id="思路1代码实现"><a class="markdownIt-Anchor" href="#思路1代码实现"></a> 思路1：代码实现</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">rotate</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        l=<span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">reverse</span>(<span class="params">start:<span class="built_in">int</span>,end:<span class="built_in">int</span></span>)-&gt;<span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">while</span> start&lt;end:</span><br><span class="line">                nums[start],nums[end]=nums[end],nums[start]</span><br><span class="line">                start+=<span class="number">1</span></span><br><span class="line">                end-=<span class="number">1</span></span><br><span class="line">        k%=l</span><br><span class="line">        reverse(<span class="number">0</span>,l-<span class="number">1</span>)</span><br><span class="line">        reverse(<span class="number">0</span>,k-<span class="number">1</span>)</span><br><span class="line">        reverse(k,l-<span class="number">1</span>)</span><br></pre></td></tr></table></figure><h4 id="思路1-性能分析"><a class="markdownIt-Anchor" href="#思路1-性能分析"></a> 思路1：📊 性能分析</h4><h5 id="提交结果"><a class="markdownIt-Anchor" href="#提交结果"></a> 提交结果</h5><ul><li><strong>运行时间</strong>：7ms击败50.31%</li><li><strong>内存消耗</strong>：25.22MB击败37.81%</li></ul><h5 id="复杂度验证"><a class="markdownIt-Anchor" href="#复杂度验证"></a> 复杂度验证</h5><ul><li>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></li><li>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></li></ul><h4 id="思考"><a class="markdownIt-Anchor" href="#思考"></a> 思考</h4><p>通过三次反转实现数组轮转</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="作业练习" scheme="https://id-zy.github.io/categories/%E4%BD%9C%E4%B8%9A%E7%BB%83%E4%B9%A0/"/>
    
    
    <category term="LeetCode" scheme="https://id-zy.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>区间加法II-LeetCode</title>
    <link href="https://id-zy.github.io/2025/12/09/%E5%8C%BA%E9%97%B4%E5%8A%A0%E6%B3%95II/"/>
    <id>https://id-zy.github.io/2025/12/09/%E5%8C%BA%E9%97%B4%E5%8A%A0%E6%B3%95II/</id>
    <published>2025-12-08T16:00:00.000Z</published>
    <updated>2025-12-09T07:21:10.355Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="区间加法ii"><a class="markdownIt-Anchor" href="#区间加法ii"></a> 区间加法II</h1><h2 id="问题描述来源于leetcode"><a class="markdownIt-Anchor" href="#问题描述来源于leetcode"></a> 🎯 问题描述（来源于LeetCode）</h2><p><strong>描述</strong>：<br />给你一个 <code>m x n</code> 的矩阵 <code>M</code> 和一个操作数组 <code>op</code> 。矩阵初始化时所有的单元格都为 <code>0</code> 。<code>ops[i] = [ai, bi]</code> 意味着当所有的 <code>0 &lt;= x &lt; ai</code> 和 <code>0 &lt;= y &lt; bi</code> 时， <code>M[x][y]</code> 应该加 1。<br /><strong>要求</strong>：<br />在 <em>执行完所有操作后</em> ，计算并返回 <em>矩阵中最大整数的个数</em> 。<br /><strong>说明</strong>：</p><ul><li><code>1 &lt;= m, n &lt;= 4 * 104</code></li><li><code>0 &lt;= ops.length &lt;= 104</code></li><li><code>ops[i].length == 2</code></li><li><code>1 &lt;= ai &lt;= m</code></li><li><code>1 &lt;= bi &lt;= n</code></li></ul><p><strong>示例</strong>：</p><ul><li><p>示例 1：<br /><strong>输入:</strong> m = 3, n = 3，ops = [[2,2],[3,3]]<br /><strong>输出:</strong> 4<br /><strong>解释:</strong> M 中最大的整数是 2, 而且 M 中有4个值为2的元素。因此返回 4。</p></li><li><p>示例 2：</p></li></ul><p><strong>输入:</strong> m = 3, n = 3, ops = [[2,2],[3,3],[3,3],[3,3],[2,2],[3,3],[3,3],[3,3],[2,2],[3,3],[3,3],[3,3]]<br /><strong>输出:</strong> 4</p><h2 id="解题思路"><a class="markdownIt-Anchor" href="#解题思路"></a> 💻 解题思路</h2><h3 id="思路1模拟暴力破解"><a class="markdownIt-Anchor" href="#思路1模拟暴力破解"></a> 思路1：模拟（暴力破解）</h3><h4 id="思路1代码实现"><a class="markdownIt-Anchor" href="#思路1代码实现"></a> 思路1：代码实现</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxCount</span>(<span class="params">self, m: <span class="built_in">int</span>, n: <span class="built_in">int</span>, ops: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        M=[[<span class="number">0</span>]*n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m)]</span><br><span class="line">        count=<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(ops)):</span><br><span class="line">            ai,bi=ops[i]</span><br><span class="line">            <span class="keyword">for</span> i,j <span class="keyword">in</span> product(<span class="built_in">range</span>(ai),<span class="built_in">range</span>(bi)):</span><br><span class="line">                M[i][j]+=<span class="number">1</span></span><br><span class="line">        max1=<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i,j <span class="keyword">in</span> product(<span class="built_in">range</span>(m),<span class="built_in">range</span>(n)):</span><br><span class="line">            <span class="keyword">if</span> M[i][j]&gt;max1:</span><br><span class="line">                max1=M[i][j]</span><br><span class="line">        <span class="keyword">for</span> i,j <span class="keyword">in</span> product(<span class="built_in">range</span>(m),<span class="built_in">range</span>(n)):</span><br><span class="line">            <span class="keyword">if</span> M[i][j]==max1:</span><br><span class="line">                count+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure><h4 id="思路1-性能分析"><a class="markdownIt-Anchor" href="#思路1-性能分析"></a> 思路1：📊 性能分析</h4><h5 id="提交结果"><a class="markdownIt-Anchor" href="#提交结果"></a> 提交结果</h5><ul><li><strong>运行时间</strong>：</li><li><strong>内存消耗</strong>：超出内存限制</li></ul><h5 id="复杂度验证"><a class="markdownIt-Anchor" href="#复杂度验证"></a> 复杂度验证</h5><ul><li>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>k</mi><mo>×</mo><mi>a</mi><mo>×</mo><mi>b</mi><mo>+</mo><mi>m</mi><mo>×</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(k × a × b + m × n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中k是操作次数，a和b是每次操作的区域大小</li><li>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mo>∗</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m*n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></li></ul><h4 id="思考"><a class="markdownIt-Anchor" href="#思考"></a> 思考</h4><p>当m,n很大时，二维数组占用空间过大，超出内存限制</p><h3 id="思路2思考重叠区域"><a class="markdownIt-Anchor" href="#思路2思考重叠区域"></a> 思路2：思考重叠区域</h3><h4 id="思路2代码实现"><a class="markdownIt-Anchor" href="#思路2代码实现"></a> 思路2：代码实现</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxCount</span>(<span class="params">self, m: <span class="built_in">int</span>, n: <span class="built_in">int</span>, ops: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(ops)==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> m*n</span><br><span class="line">        a1,b1=ops[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(ops)):</span><br><span class="line">            ai,bi=ops[i]</span><br><span class="line">            <span class="keyword">if</span> a1&gt;ai:</span><br><span class="line">                a1=ai</span><br><span class="line">            <span class="keyword">if</span> b1&gt;bi:</span><br><span class="line">                b1=bi</span><br><span class="line">        <span class="keyword">return</span> a1*b1</span><br></pre></td></tr></table></figure><h4 id="思路2-性能分析"><a class="markdownIt-Anchor" href="#思路2-性能分析"></a> 思路2：📊 性能分析</h4><h5 id="提交结果-2"><a class="markdownIt-Anchor" href="#提交结果-2"></a> 提交结果</h5><ul><li><strong>运行时间</strong>：3ms击败34.41%</li><li><strong>内存消耗</strong>：18.87MB击败54.25%</li></ul><h5 id="复杂度验证-2"><a class="markdownIt-Anchor" href="#复杂度验证-2"></a> 复杂度验证</h5><ul><li>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></li><li>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></li></ul><h4 id="思考-2"><a class="markdownIt-Anchor" href="#思考-2"></a> 思考</h4><p>只需要找到所有相加区域的重叠部分即可</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="作业练习" scheme="https://id-zy.github.io/categories/%E4%BD%9C%E4%B8%9A%E7%BB%83%E4%B9%A0/"/>
    
    
    <category term="LeetCode" scheme="https://id-zy.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>平均售价-LeetCode</title>
    <link href="https://id-zy.github.io/2025/12/09/%E5%B9%B3%E5%9D%87%E5%94%AE%E4%BB%B7/"/>
    <id>https://id-zy.github.io/2025/12/09/%E5%B9%B3%E5%9D%87%E5%94%AE%E4%BB%B7/</id>
    <published>2025-12-08T16:00:00.000Z</published>
    <updated>2025-12-09T12:02:51.633Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="平均售价"><a class="markdownIt-Anchor" href="#平均售价"></a> 平均售价</h1><h2 id="问题描述来源于leetcode"><a class="markdownIt-Anchor" href="#问题描述来源于leetcode"></a> 🎯 问题描述（来源于LeetCode）</h2><p><strong>描述</strong>：<br />表：<code>Prices</code><br />±--------------±--------+<br />| Column Name   | Type    |<br />±--------------±--------+<br />| product_id    | int     |<br />| start_date    | date    |<br />| end_date      | date    |<br />| price         | int     |<br />±--------------±--------+<br />(product_id，start_date，end_date) 是 <code>prices</code> 表的主键（具有唯一值的列的组合）。<br /><code>prices</code> 表的每一行表示的是某个产品在一段时期内的价格。<br />每个产品的对应时间段是不会重叠的，这也意味着同一个产品的价格时段不会出现交叉。<br />表：<code>UnitsSold</code><br />±--------------±--------+<br />| Column Name   | Type    |<br />±--------------±--------+<br />| product_id    | int     |<br />| purchase_date | date    |<br />| units         | int     |<br />±--------------±--------+<br />该表可能包含重复数据。<br />该表的每一行表示的是每种产品的出售日期，单位和产品 id。<br />编写解决方案以查找每种产品的平均售价。<code>average_price</code> 应该 <strong>四舍五入到小数点后两位</strong>。如果产品没有任何售出，则假设其平均售价为 0。<br /><strong>要求</strong>：<br />返回结果表 <strong>无顺序要求</strong> 。<br /><strong>说明</strong>：</p><p><strong>示例</strong>：</p><ul><li>示例 1：<br /><strong>输入：</strong><br />Prices table:<br />±-----------±-----------±-----------±-------+<br />| product_id | start_date | end_date   | price  |<br />±-----------±-----------±-----------±-------+<br />| 1          | 2019-02-17 | 2019-02-28 | 5      |<br />| 1          | 2019-03-01 | 2019-03-22 | 20     |<br />| 2          | 2019-02-01 | 2019-02-20 | 15     |<br />| 2          | 2019-02-21 | 2019-03-31 | 30     |<br />±-----------±-----------±-----------±-------+<br />UnitsSold table:<br />±-----------±--------------±------+<br />| product_id | purchase_date | units |<br />±-----------±--------------±------+<br />| 1          | 2019-02-25    | 100   |<br />| 1          | 2019-03-01    | 15    |<br />| 2          | 2019-02-10    | 200   |<br />| 2          | 2019-03-22    | 30    |<br />±-----------±--------------±------+<br /><strong>输出：</strong><br />±-----------±--------------+<br />| product_id | average_price |<br />±-----------±--------------+<br />| 1          | 6.96          |<br />| 2          | 16.96         |<br />±-----------±--------------+<br /><strong>解释：</strong><br />平均售价 = 产品总价 / 销售的产品数量。<br />产品 1 的平均售价 = ((100 * 5)+(15 * 20) )/ 115 = 6.96<br />产品 2 的平均售价 = ((200 * 15)+(30 * 30) )/ 230 = 16.96</li></ul><h2 id="解题思路"><a class="markdownIt-Anchor" href="#解题思路"></a> 💻 解题思路</h2><h3 id="思路1模拟过程"><a class="markdownIt-Anchor" href="#思路1模拟过程"></a> 思路1：模拟过程</h3><h4 id="思路1代码实现"><a class="markdownIt-Anchor" href="#思路1代码实现"></a> 思路1：代码实现</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># Write your MySQL query statement below</span><br><span class="line"><span class="keyword">SELECT</span> p.product_id,ROUND(ifnull(<span class="built_in">SUM</span>(units<span class="operator">*</span>price)<span class="operator">/</span><span class="built_in">SUM</span>(units),<span class="number">0</span>),<span class="number">2</span>)<span class="keyword">AS</span> average_price</span><br><span class="line"><span class="keyword">FROM</span> prices p</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> unitsSold u</span><br><span class="line"><span class="keyword">ON</span> p.product_id<span class="operator">=</span>u.product_id <span class="keyword">and</span> u.purchase_date <span class="keyword">BETWEEN</span> p.start_date <span class="keyword">AND</span> p.end_date</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> p.product_id</span><br></pre></td></tr></table></figure><h4 id="思路1-性能分析"><a class="markdownIt-Anchor" href="#思路1-性能分析"></a> 思路1：📊 性能分析</h4><h5 id="提交结果"><a class="markdownIt-Anchor" href="#提交结果"></a> 提交结果</h5><ul><li><strong>运行时间</strong>：1155ms击败75.29%</li></ul><h4 id="思考"><a class="markdownIt-Anchor" href="#思考"></a> 思考</h4><p>ROUND、ifnull函数一定要知道参数</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="作业练习" scheme="https://id-zy.github.io/categories/%E4%BD%9C%E4%B8%9A%E7%BB%83%E4%B9%A0/"/>
    
    
    <category term="LeetCode" scheme="https://id-zy.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>甲板上的战舰-LeetCode</title>
    <link href="https://id-zy.github.io/2025/12/09/%E7%94%B2%E6%9D%BF%E4%B8%8A%E7%9A%84%E6%88%98%E8%88%B0/"/>
    <id>https://id-zy.github.io/2025/12/09/%E7%94%B2%E6%9D%BF%E4%B8%8A%E7%9A%84%E6%88%98%E8%88%B0/</id>
    <published>2025-12-08T16:00:00.000Z</published>
    <updated>2025-12-09T11:44:55.579Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="甲板上的战舰"><a class="markdownIt-Anchor" href="#甲板上的战舰"></a> 甲板上的战舰</h1><h2 id="问题描述来源于leetcode"><a class="markdownIt-Anchor" href="#问题描述来源于leetcode"></a> 🎯 问题描述（来源于LeetCode）</h2><p><strong>描述</strong>：<br />给你一个大小为 <code>m x n</code> 的矩阵 <code>board</code> 表示棋盘，其中，每个单元格可以是一艘战舰 <code>'X'</code> 或者是一个空位 <code>'.'</code> <br /><strong>舰队</strong> 只能水平或者垂直放置在 <code>board</code> 上。换句话说，舰队只能按 <code>1 x k</code>（<code>1</code> 行，<code>k</code> 列）或 <code>k x 1</code>（<code>k</code> 行，<code>1</code> 列）的形状放置，其中 <code>k</code> 可以是任意大小。两个舰队之间至少有一个水平或垂直的空格分隔 （即没有相邻的舰队）。<br /><strong>要求</strong>：<br />返回在棋盘 <code>board</code> 上放置的 <strong>舰队</strong> 的数量。<br /><strong>说明</strong>：</p><ul><li><code>m == board.length</code></li><li><code>n == board[i].length</code></li><li><code>1 &lt;= m, n &lt;= 200</code></li><li><code>board[i][j]</code> 是 <code>'.'</code> 或 <code>'X'</code></li></ul><p><strong>示例</strong>：</p><ul><li>示例 1：<br />输入：board = [[“X”,“.”,“.”,“X”],[“.”,“.”,“.”,“X”],[“.”,“.”,“.”,“X”]]<br />输出：2</li><li>示例 2：<br />输入: board = [[“.”]]<br />输出: 0</li></ul><h2 id="解题思路"><a class="markdownIt-Anchor" href="#解题思路"></a> 💻 解题思路</h2><h3 id="思路1找到舰队头部"><a class="markdownIt-Anchor" href="#思路1找到舰队头部"></a> 思路1：找到舰队头部</h3><h4 id="思路1代码实现"><a class="markdownIt-Anchor" href="#思路1代码实现"></a> 思路1：代码实现</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">countBattleships</span>(<span class="params">self, board: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">str</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        count=<span class="number">0</span></span><br><span class="line">        m,n=<span class="built_in">len</span>(board),<span class="built_in">len</span>(board[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">for</span> i,j <span class="keyword">in</span> product(<span class="built_in">range</span>(m),<span class="built_in">range</span>(n)):</span><br><span class="line">            <span class="keyword">if</span> board[i][j]==<span class="string">&#x27;X&#x27;</span> <span class="keyword">and</span> (board[i-<span class="number">1</span>][j]==<span class="string">&#x27;.&#x27;</span><span class="keyword">or</span> i==<span class="number">0</span>)<span class="keyword">and</span> (board[i][j-<span class="number">1</span>]==<span class="string">&#x27;.&#x27;</span> <span class="keyword">or</span> j==<span class="number">0</span>) :</span><br><span class="line">                count+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> count        </span><br><span class="line">          </span><br></pre></td></tr></table></figure><h4 id="思路1-性能分析"><a class="markdownIt-Anchor" href="#思路1-性能分析"></a> 思路1：📊 性能分析</h4><h5 id="提交结果"><a class="markdownIt-Anchor" href="#提交结果"></a> 提交结果</h5><ul><li><strong>运行时间</strong>：4ms击败31.75%</li><li><strong>内存消耗</strong>：19.43MB击败98.41%</li></ul><h5 id="复杂度验证"><a class="markdownIt-Anchor" href="#复杂度验证"></a> 复杂度验证</h5><ul><li>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mo>∗</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m*n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></li><li>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></li></ul><h4 id="思考"><a class="markdownIt-Anchor" href="#思考"></a> 思考</h4><p>观察图形，舰队头部的左边和上边都没有战舰（除非是边界）统计舰队头部数量即是舰队数量</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="作业练习" scheme="https://id-zy.github.io/categories/%E4%BD%9C%E4%B8%9A%E7%BB%83%E4%B9%A0/"/>
    
    
    <category term="LeetCode" scheme="https://id-zy.github.io/tags/LeetCode/"/>
    
  </entry>
  
</feed>
